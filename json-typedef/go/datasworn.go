// Code generated by jtd-codegen for Go v0.2.1. DO NOT EDIT.

package Datasworn

import (
	"encoding/json"
	"fmt"
)

type Ruleset struct {
	ID NamespaceID `json:"id"`

	Source Source `json:"source"`

	// A dictionary object containing asset types, which contain assets.
	Assets map[string]AssetType `json:"assets,omitempty"`

	// A dictionary object containing atlas collections, which contain atlas
	// entries.
	Atlas map[string]Atlas `json:"atlas,omitempty"`

	// A dictionary object of delve sites, like the premade delve sites presented
	// in Ironsworn: Delve
	DelveSites map[string]DelveSite `json:"delve_sites,omitempty"`

	// A dictionary object containing move categories, which contain moves.
	Moves map[string]MoveCategory `json:"moves,omitempty"`

	// A dictionary object containing NPC collections, which contain NPCs.
	Npcs map[string]NpcCollection `json:"npcs,omitempty"`

	// A dictionary object containing oracle collections, which may contain oracle
	// tables and/or oracle collections.
	Oracles map[string]OracleCollection `json:"oracles,omitempty"`

	// A dictionary object containing rarities, like those presented in Ironsworn:
	// Delve.
	Rarities map[string]Rarity `json:"rarities,omitempty"`

	Rules *Rules `json:"rules,omitempty"`

	// A dictionary object containing delve site domains.
	SiteDomains map[string]DelveSiteDomain `json:"site_domains,omitempty"`

	// A dictionary object containing delve site themes.
	SiteThemes map[string]DelveSiteTheme `json:"site_themes,omitempty"`

	// A dictionary object of truth categories.
	Truths map[string]Truth `json:"truths,omitempty"`
}

type ActionRollMethod string

const (
// Use **every** roll option at once.
	ActionRollMethodAll ActionRollMethod = "all"

// Use the roll option with the best/highest value.
	ActionRollMethodHighest ActionRollMethod = "highest"

// Use the roll option with the worst/lowest value.
	ActionRollMethodLowest ActionRollMethod = "lowest"

// An automatic miss.
	ActionRollMethodMiss ActionRollMethod = "miss"

// The player chooses which roll option to use.
	ActionRollMethodPlayerChoice ActionRollMethod = "player_choice"

// An automatic strong hit.
	ActionRollMethodStrongHit ActionRollMethod = "strong_hit"

// An automatic weak hit.
	ActionRollMethodWeakHit ActionRollMethod = "weak_hit"
)

type ActionRollOption struct {
	Using string

	AssetControl ActionRollOptionAssetControl

	AssetOption ActionRollOptionAssetOption

	AttachedAssetControl ActionRollOptionAttachedAssetControl

	AttachedAssetOption ActionRollOptionAttachedAssetOption

	ConditionMeter ActionRollOptionConditionMeter

	Custom ActionRollOptionCustom

	Stat ActionRollOptionStat
}

func (v ActionRollOption) MarshalJSON() ([]byte, error) {
	switch v.Using {
	case "asset_control":
		return json.Marshal(struct { T string `json:"using"`; ActionRollOptionAssetControl }{ v.Using, v.AssetControl })
	case "asset_option":
		return json.Marshal(struct { T string `json:"using"`; ActionRollOptionAssetOption }{ v.Using, v.AssetOption })
	case "attached_asset_control":
		return json.Marshal(struct { T string `json:"using"`; ActionRollOptionAttachedAssetControl }{ v.Using, v.AttachedAssetControl })
	case "attached_asset_option":
		return json.Marshal(struct { T string `json:"using"`; ActionRollOptionAttachedAssetOption }{ v.Using, v.AttachedAssetOption })
	case "condition_meter":
		return json.Marshal(struct { T string `json:"using"`; ActionRollOptionConditionMeter }{ v.Using, v.ConditionMeter })
	case "custom":
		return json.Marshal(struct { T string `json:"using"`; ActionRollOptionCustom }{ v.Using, v.Custom })
	case "stat":
		return json.Marshal(struct { T string `json:"using"`; ActionRollOptionStat }{ v.Using, v.Stat })
	}

	return nil, fmt.Errorf("bad Using value: %s", v.Using)
}

func (v *ActionRollOption) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"using"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "asset_control":
		err = json.Unmarshal(b, &v.AssetControl)
	case "asset_option":
		err = json.Unmarshal(b, &v.AssetOption)
	case "attached_asset_control":
		err = json.Unmarshal(b, &v.AttachedAssetControl)
	case "attached_asset_option":
		err = json.Unmarshal(b, &v.AttachedAssetOption)
	case "condition_meter":
		err = json.Unmarshal(b, &v.ConditionMeter)
	case "custom":
		err = json.Unmarshal(b, &v.Custom)
	case "stat":
		err = json.Unmarshal(b, &v.Stat)
	default:
		err = fmt.Errorf("bad Using value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.Using = t.T
	return nil
}

type ActionRollOptionAssetControl struct {
	Assets []AssetIDWildcard `json:"assets"`

	// The key of the asset control field.
	Control DictKey `json:"control"`
}

type ActionRollOptionAssetOption struct {
	Assets []AssetIDWildcard `json:"assets"`

	// The key of the asset option field.
	Option DictKey `json:"option"`
}

type ActionRollOptionAttachedAssetControl struct {
	// The key of the asset control field.
	Control DictKey `json:"control"`
}

type ActionRollOptionAttachedAssetOption struct {
	// The key of the asset option field.
	Option DictKey `json:"option"`
}

type ActionRollOptionConditionMeter struct {
	ConditionMeter PlayerConditionMeter `json:"condition_meter"`
}

type ActionRollOptionCustom struct {
	Name Label `json:"name"`

	Value int16 `json:"value"`
}

type ActionRollOptionStat struct {
	Stat PlayerStat `json:"stat"`
}

type ActionRollUsing string

const (
// Roll using the value of an asset control.
	ActionRollUsingAssetControl ActionRollUsing = "asset_control"

// Roll using the value of an asset option.
	ActionRollUsingAssetOption ActionRollUsing = "asset_option"

// Roll using the value of an attached asset control. For example, a Module
// asset could use this to roll using the `integrity` control of an attached
// Vehicle.
	ActionRollUsingAttachedAssetControl ActionRollUsing = "attached_asset_control"

// Roll using the value of an attached asset option.
	ActionRollUsingAttachedAssetOption ActionRollUsing = "attached_asset_option"

// Roll using the value of a standard player condition meter.
	ActionRollUsingConditionMeter ActionRollUsing = "condition_meter"

// Roll using an integer value with customizable labels.
	ActionRollUsingCustom ActionRollUsing = "custom"

// Roll using a standard player character stat.
	ActionRollUsingStat ActionRollUsing = "stat"
)

type Asset struct {
	Abilities []AssetAbility `json:"abilities"`

	// A localized category label for this asset. This is the surtitle above the
	// asset's name on the card.
	AssetType Label `json:"asset_type"`

	// If `true`, this asset counts as an impact (Starforged) or a debility
	// (classic Ironsworn).
	CountAsImpact bool `json:"count_as_impact"`

	// The unique Datasworn ID for this item.
	ID AssetID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Most assets only benefit to their owner, but certain assets (like
	// Starforged's module and command vehicle assets) are shared amongst the
	// player's allies, too.
	Shared bool `json:"shared"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	Attachments *AssetAttachment `json:"attachments,omitempty"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this asset.
	Color *CSSColor `json:"color,omitempty"`

	// Controls are condition meters, clocks, counters, and other asset input
	// fields whose values are expected to change throughout the life of the asset.
	Controls map[string]AssetControlField `json:"controls,omitempty"`

	// This asset's icon.
	Icon *SvgImageURL `json:"icon,omitempty"`

	// Options are asset input fields which are set once, usually when the
	// character takes the asset. The most common example is the "name" field on
	// companion assets. A more complex example is the choice of a god's stat for
	// the Devotant asset.
	Options map[string]AssetOptionField `json:"options,omitempty"`

	// Describes prerequisites for purchasing or using this asset.
	Requirement *MarkdownString `json:"requirement,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type AssetAbility struct {
	// Is this asset ability enabled?
	Enabled bool `json:"enabled"`

	// The unique Datasworn ID for this item.
	ID AssetAbilityID `json:"id"`

	Text MarkdownString `json:"text"`

	// Fields whose values are expected to change over the life of the asset.
	Controls map[string]AssetAbilityControlField `json:"controls,omitempty"`

	// Changes made to the asset, when this ability is enabled.
	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	// Describes changes made to various moves by this asset ability. Usually these
	// require specific trigger conditions.
	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`

	// Unique moves added by this asset ability.
	Moves map[string]Move `json:"moves,omitempty"`

	Name *Label `json:"name,omitempty"`

	// Fields that are expected to be set once and remain the same through the life
	// of the asset.
	Options map[string]AssetAbilityOptionField `json:"options,omitempty"`
}

type AssetAbilityControlField struct {
	FieldType string

	Checkbox AssetAbilityControlFieldCheckbox

	Clock AssetAbilityControlFieldClock

	Counter AssetAbilityControlFieldCounter
}

func (v AssetAbilityControlField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "checkbox":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityControlFieldCheckbox }{ v.FieldType, v.Checkbox })
	case "clock":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityControlFieldClock }{ v.FieldType, v.Clock })
	case "counter":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityControlFieldCounter }{ v.FieldType, v.Counter })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetAbilityControlField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "checkbox":
		err = json.Unmarshal(b, &v.Checkbox)
	case "clock":
		err = json.Unmarshal(b, &v.Clock)
	case "counter":
		err = json.Unmarshal(b, &v.Counter)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

type AssetAbilityControlFieldCheckbox struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	// The unique Datasworn ID for this item.
	ID AssetAbilityControlFieldID `json:"id"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	// Is the box checked?
	Value bool `json:"value"`
}

type AssetAbilityControlFieldClock struct {
	// The unique Datasworn ID for this item.
	ID AssetAbilityControlFieldID `json:"id"`

	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	// The size of the clock -- in other words, the maximum number of filled clock
	// segments.
	Max int8 `json:"max"`

	// The minimum number of filled clock segments. This is always 0.
	Min int8 `json:"min"`

	// The current number of filled clock segments.
	Value int8 `json:"value"`
}

type AssetAbilityControlFieldCounter struct {
	// The unique Datasworn ID for this item.
	ID AssetAbilityControlFieldID `json:"id"`

	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	Max int16 `json:"max"`

	// The (inclusive) minimum value.
	Min int8 `json:"min"`

	// The current value of this input.
	Value int16 `json:"value"`
}

type AssetAbilityControlFieldID = string

type AssetAbilityID = string

type AssetAbilityOptionField struct {
	FieldType string

	Text AssetAbilityOptionFieldText
}

func (v AssetAbilityOptionField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "text":
		return json.Marshal(struct { T string `json:"field_type"`; AssetAbilityOptionFieldText }{ v.FieldType, v.Text })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetAbilityOptionField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "text":
		err = json.Unmarshal(b, &v.Text)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

type AssetAbilityOptionFieldText struct {
	// The unique Datasworn ID for this item.
	ID AssetAbilityOptionFieldID `json:"id"`

	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	Value string `json:"value"`
}

type AssetAbilityOptionFieldID = string

// Describes which assets can be attached to this asset. Example: Starforged's
// Module assets, which can be equipped by Command Vehicle assets. See p. 55 of
// Starforged for more info.
type AssetAttachment struct {
	// Asset IDs (which may be wildcards) that may be attached to this asset
	Assets []AssetIDWildcard `json:"assets"`

	Max int16 `json:"max"`
}

// A checkbox control field, rendered as part of an asset condition meter.
type AssetConditionMeterControlField struct {
	FieldType string

	CardFlip AssetConditionMeterControlFieldCardFlip

	Checkbox AssetConditionMeterControlFieldCheckbox
}

func (v AssetConditionMeterControlField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "card_flip":
		return json.Marshal(struct { T string `json:"field_type"`; AssetConditionMeterControlFieldCardFlip }{ v.FieldType, v.CardFlip })
	case "checkbox":
		return json.Marshal(struct { T string `json:"field_type"`; AssetConditionMeterControlFieldCheckbox }{ v.FieldType, v.Checkbox })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetConditionMeterControlField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "card_flip":
		err = json.Unmarshal(b, &v.CardFlip)
	case "checkbox":
		err = json.Unmarshal(b, &v.Checkbox)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

type AssetConditionMeterControlFieldCardFlip struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	// The unique Datasworn ID for this item.
	ID AssetConditionMeterControlFieldID `json:"id"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	// Is the card flipped over?
	Value bool `json:"value"`
}

type AssetConditionMeterControlFieldCheckbox struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	// The unique Datasworn ID for this item.
	ID AssetConditionMeterControlFieldID `json:"id"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	// Is the box checked?
	Value bool `json:"value"`
}

type AssetConditionMeterControlFieldID = string

type AssetControlField struct {
	FieldType string

	CardFlip AssetControlFieldCardFlip

	Checkbox AssetControlFieldCheckbox

	ConditionMeter AssetControlFieldConditionMeter

	SelectEnhancement AssetControlFieldSelectEnhancement
}

func (v AssetControlField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "card_flip":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldCardFlip }{ v.FieldType, v.CardFlip })
	case "checkbox":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldCheckbox }{ v.FieldType, v.Checkbox })
	case "condition_meter":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldConditionMeter }{ v.FieldType, v.ConditionMeter })
	case "select_enhancement":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldSelectEnhancement }{ v.FieldType, v.SelectEnhancement })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetControlField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "card_flip":
		err = json.Unmarshal(b, &v.CardFlip)
	case "checkbox":
		err = json.Unmarshal(b, &v.Checkbox)
	case "condition_meter":
		err = json.Unmarshal(b, &v.ConditionMeter)
	case "select_enhancement":
		err = json.Unmarshal(b, &v.SelectEnhancement)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

type AssetControlFieldCardFlip struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	// The unique Datasworn ID for this item.
	ID AssetControlFieldID `json:"id"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	// Is the card flipped over?
	Value bool `json:"value"`
}

type AssetControlFieldCheckbox struct {
	// Does this field disable the asset when its value is set to `true`?
	DisablesAsset bool `json:"disables_asset"`

	// The unique Datasworn ID for this item.
	ID AssetControlFieldID `json:"id"`

	// Does this field count as an impact (Starforged) or debility (Ironsworn
	// classic) when its value is set to `true`?
	IsImpact bool `json:"is_impact"`

	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	// Is the box checked?
	Value bool `json:"value"`
}

// Provides hints for moves that interact with this condition meter, such as
// suffer and recovery moves.
type AssetControlFieldConditionMeterMoves struct {
	// The ID(s) of recovery moves associated with this meter.
	Recover []MoveIDWildcard `json:"recover,omitempty"`

	// The ID(s) of suffer moves associated with the condition meter. If the
	// suffer move makes an action roll, this condition meter value should be made
	// available as a roll option.
	Suffer []MoveIDWildcard `json:"suffer,omitempty"`
}

type AssetControlFieldConditionMeter struct {
	// The unique Datasworn ID for this item.
	ID AssetControlFieldID `json:"id"`

	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	// The maximum value of this meter.
	Max int8 `json:"max"`

	// The minimum value of this meter.
	Min int8 `json:"min"`

	// The current value of this meter.
	Value int8 `json:"value"`

	// Checkbox controls rendered as part of the condition meter.
	Controls map[string]AssetConditionMeterControlField `json:"controls,omitempty"`

	// Provides hints for moves that interact with this condition meter, such as
	// suffer and recovery moves.
	Moves *AssetControlFieldConditionMeterMoves `json:"moves,omitempty"`
}

type AssetControlFieldSelectEnhancementChoice struct {
	OptionType string

	Option AssetControlFieldSelectEnhancementChoiceOption

	OptionGroup AssetControlFieldSelectEnhancementChoiceOptionGroup
}

func (v AssetControlFieldSelectEnhancementChoice) MarshalJSON() ([]byte, error) {
	switch v.OptionType {
	case "option":
		return json.Marshal(struct { T string `json:"option_type"`; AssetControlFieldSelectEnhancementChoiceOption }{ v.OptionType, v.Option })
	case "option_group":
		return json.Marshal(struct { T string `json:"option_type"`; AssetControlFieldSelectEnhancementChoiceOptionGroup }{ v.OptionType, v.OptionGroup })
	}

	return nil, fmt.Errorf("bad OptionType value: %s", v.OptionType)
}

func (v *AssetControlFieldSelectEnhancementChoice) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"option_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "option":
		err = json.Unmarshal(b, &v.Option)
	case "option_group":
		err = json.Unmarshal(b, &v.OptionGroup)
	default:
		err = fmt.Errorf("bad OptionType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.OptionType = t.T
	return nil
}

// The current value of this input.
type AssetControlFieldSelectEnhancementChoiceOptionValue struct {
	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

type AssetControlFieldSelectEnhancementChoiceOption struct {
	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	// The current value of this input.
	Value AssetControlFieldSelectEnhancementChoiceOptionValue `json:"value"`

	// Is this option currently selected?
	Selected *bool `json:"selected,omitempty"`
}

type AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionType string

const (
	AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionTypeOption AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionType = "option"
)

// The current value of this input.
type AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceValue struct {
	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

// Represents an option in a list of choices.
type AssetControlFieldSelectEnhancementChoiceOptionGroupChoice struct {
	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	OptionType AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionType `json:"option_type"`

	// The current value of this input.
	Value AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceValue `json:"value"`

	// Is this option currently selected?
	Selected *bool `json:"selected,omitempty"`
}

type AssetControlFieldSelectEnhancementChoiceOptionGroup struct {
	Choices map[string]AssetControlFieldSelectEnhancementChoiceOptionGroupChoice `json:"choices"`

	// A label for this option group.
	Name Label `json:"name"`
}

type AssetControlFieldSelectEnhancement struct {
	Choices map[string]AssetControlFieldSelectEnhancementChoice `json:"choices"`

	// The unique Datasworn ID for this item.
	ID AssetControlFieldID `json:"id"`

	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	// The key of the currently selected choice from the `choices` property, or
	// `null` if none is selected.
	Value DictKey `json:"value"`
}

type AssetControlFieldEnhancement struct {
	FieldType string

	ConditionMeter AssetControlFieldEnhancementConditionMeter
}

func (v AssetControlFieldEnhancement) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "condition_meter":
		return json.Marshal(struct { T string `json:"field_type"`; AssetControlFieldEnhancementConditionMeter }{ v.FieldType, v.ConditionMeter })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetControlFieldEnhancement) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "condition_meter":
		err = json.Unmarshal(b, &v.ConditionMeter)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

type AssetControlFieldEnhancementConditionMeter struct {
	// The maximum value of this meter.
	Max int8 `json:"max"`
}

type AssetControlFieldID = string

type AssetControlFieldIDWildcard = string

// Describes enhancements made to this asset in a partial asset object. The
// changes should be applied recursively; only the values that are specified
// should be changed.
type AssetEnhancement struct {
	Attachments *AssetAttachment `json:"attachments,omitempty"`

	// Controls are condition meters, clocks, counters, and other asset input
	// fields whose values are expected to change throughout the life of the asset.
	Controls map[string]AssetControlFieldEnhancement `json:"controls,omitempty"`

	// If `true`, this asset counts as an impact (Starforged) or a debility
	// (classic Ironsworn).
	CountAsImpact *bool `json:"count_as_impact,omitempty"`

	// Most assets only benefit to their owner, but certain assets (like
	// Starforged's module and command vehicle assets) are shared amongst the
	// player's allies, too.
	Shared *bool `json:"shared,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type AssetID = string

type AssetIDWildcard = string

type AssetOptionField struct {
	FieldType string

	SelectEnhancement AssetOptionFieldSelectEnhancement

	SelectStat AssetOptionFieldSelectStat

	Text AssetOptionFieldText
}

func (v AssetOptionField) MarshalJSON() ([]byte, error) {
	switch v.FieldType {
	case "select_enhancement":
		return json.Marshal(struct { T string `json:"field_type"`; AssetOptionFieldSelectEnhancement }{ v.FieldType, v.SelectEnhancement })
	case "select_stat":
		return json.Marshal(struct { T string `json:"field_type"`; AssetOptionFieldSelectStat }{ v.FieldType, v.SelectStat })
	case "text":
		return json.Marshal(struct { T string `json:"field_type"`; AssetOptionFieldText }{ v.FieldType, v.Text })
	}

	return nil, fmt.Errorf("bad FieldType value: %s", v.FieldType)
}

func (v *AssetOptionField) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"field_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "select_enhancement":
		err = json.Unmarshal(b, &v.SelectEnhancement)
	case "select_stat":
		err = json.Unmarshal(b, &v.SelectStat)
	case "text":
		err = json.Unmarshal(b, &v.Text)
	default:
		err = fmt.Errorf("bad FieldType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.FieldType = t.T
	return nil
}

type AssetOptionFieldSelectEnhancementChoice struct {
	OptionType string

	Option AssetOptionFieldSelectEnhancementChoiceOption

	OptionGroup AssetOptionFieldSelectEnhancementChoiceOptionGroup
}

func (v AssetOptionFieldSelectEnhancementChoice) MarshalJSON() ([]byte, error) {
	switch v.OptionType {
	case "option":
		return json.Marshal(struct { T string `json:"option_type"`; AssetOptionFieldSelectEnhancementChoiceOption }{ v.OptionType, v.Option })
	case "option_group":
		return json.Marshal(struct { T string `json:"option_type"`; AssetOptionFieldSelectEnhancementChoiceOptionGroup }{ v.OptionType, v.OptionGroup })
	}

	return nil, fmt.Errorf("bad OptionType value: %s", v.OptionType)
}

func (v *AssetOptionFieldSelectEnhancementChoice) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"option_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "option":
		err = json.Unmarshal(b, &v.Option)
	case "option_group":
		err = json.Unmarshal(b, &v.OptionGroup)
	default:
		err = fmt.Errorf("bad OptionType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.OptionType = t.T
	return nil
}

// The current value of this input.
type AssetOptionFieldSelectEnhancementChoiceOptionValue struct {
	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

type AssetOptionFieldSelectEnhancementChoiceOption struct {
	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	// The current value of this input.
	Value AssetOptionFieldSelectEnhancementChoiceOptionValue `json:"value"`

	// Is this option currently selected?
	Selected *bool `json:"selected,omitempty"`
}

type AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionType string

const (
	AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionTypeOption AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionType = "option"
)

// The current value of this input.
type AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceValue struct {
	EnhanceAsset *AssetEnhancement `json:"enhance_asset,omitempty"`

	EnhanceMoves []MoveEnhancement `json:"enhance_moves,omitempty"`
}

// Represents an option in a list of choices.
type AssetOptionFieldSelectEnhancementChoiceOptionGroupChoice struct {
	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	OptionType AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionType `json:"option_type"`

	// The current value of this input.
	Value AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceValue `json:"value"`

	// Is this option currently selected?
	Selected *bool `json:"selected,omitempty"`
}

type AssetOptionFieldSelectEnhancementChoiceOptionGroup struct {
	Choices map[string]AssetOptionFieldSelectEnhancementChoiceOptionGroupChoice `json:"choices"`

	// A label for this option group.
	Name Label `json:"name"`
}

type AssetOptionFieldSelectEnhancement struct {
	Choices map[string]AssetOptionFieldSelectEnhancementChoice `json:"choices"`

	// The unique Datasworn ID for this item.
	ID AssetOptionFieldID `json:"id"`

	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	// The key of the currently selected choice from the `choices` property, or
	// `null` if none is selected.
	Value DictKey `json:"value"`
}

type AssetOptionFieldSelectStatChoice struct {
	OptionType string

	Option AssetOptionFieldSelectStatChoiceOption

	OptionGroup AssetOptionFieldSelectStatChoiceOptionGroup
}

func (v AssetOptionFieldSelectStatChoice) MarshalJSON() ([]byte, error) {
	switch v.OptionType {
	case "option":
		return json.Marshal(struct { T string `json:"option_type"`; AssetOptionFieldSelectStatChoiceOption }{ v.OptionType, v.Option })
	case "option_group":
		return json.Marshal(struct { T string `json:"option_type"`; AssetOptionFieldSelectStatChoiceOptionGroup }{ v.OptionType, v.OptionGroup })
	}

	return nil, fmt.Errorf("bad OptionType value: %s", v.OptionType)
}

func (v *AssetOptionFieldSelectStatChoice) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"option_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "option":
		err = json.Unmarshal(b, &v.Option)
	case "option_group":
		err = json.Unmarshal(b, &v.OptionGroup)
	default:
		err = fmt.Errorf("bad OptionType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.OptionType = t.T
	return nil
}

type AssetOptionFieldSelectStatChoiceOption struct {
	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	// The current value of this input.
	Value PlayerStat `json:"value"`

	// Is this option currently selected?
	Selected *bool `json:"selected,omitempty"`
}

type AssetOptionFieldSelectStatChoiceOptionGroupChoiceOptionType string

const (
	AssetOptionFieldSelectStatChoiceOptionGroupChoiceOptionTypeOption AssetOptionFieldSelectStatChoiceOptionGroupChoiceOptionType = "option"
)

// Represents an option in a list of choices.
type AssetOptionFieldSelectStatChoiceOptionGroupChoice struct {
	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	OptionType AssetOptionFieldSelectStatChoiceOptionGroupChoiceOptionType `json:"option_type"`

	// The current value of this input.
	Value PlayerStat `json:"value"`

	// Is this option currently selected?
	Selected *bool `json:"selected,omitempty"`
}

type AssetOptionFieldSelectStatChoiceOptionGroup struct {
	Choices map[string]AssetOptionFieldSelectStatChoiceOptionGroupChoice `json:"choices"`

	// A label for this option group.
	Name Label `json:"name"`
}

type AssetOptionFieldSelectStat struct {
	Choices map[string]AssetOptionFieldSelectStatChoice `json:"choices"`

	// The unique Datasworn ID for this item.
	ID AssetOptionFieldID `json:"id"`

	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	// The key of the currently selected choice from the `choices` property, or
	// `null` if none is selected.
	Value DictKey `json:"value"`
}

type AssetOptionFieldText struct {
	// The unique Datasworn ID for this item.
	ID AssetOptionFieldID `json:"id"`

	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	Value string `json:"value"`
}

type AssetOptionFieldID = string

type AssetOptionFieldIDWildcard = string

type AssetType struct {
	Contents map[string]Asset `json:"contents"`

	// The unique Datasworn ID for this item.
	ID AssetTypeID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this collection.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This collection's content enhances the identified collection, rather than
	// being a standalone collection of its own.
	Enhances *AssetTypeID `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This collection replaces the identified collection. References to the
	// replaced collection can be considered equivalent to this collection.
	Replaces *AssetTypeID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`
}

type AssetTypeID = string

type Atlas struct {
	Collections map[string]Atlas `json:"collections"`

	Contents map[string]AtlasEntry `json:"contents"`

	// The unique Datasworn ID for this item.
	ID AtlasID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this collection.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This collection's content enhances the identified collection, rather than
	// being a standalone collection of its own.
	Enhances *AtlasID `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This collection replaces the identified collection. References to the
	// replaced collection can be considered equivalent to this collection.
	Replaces *AtlasID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`
}

// An atlas entry, like the Ironlands region entries found in classic Ironsworn.
type AtlasEntry struct {
	Description MarkdownString `json:"description"`

	Features []MarkdownString `json:"features"`

	// The unique Datasworn ID for this item.
	ID AtlasEntryID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	QuestStarter MarkdownString `json:"quest_starter"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	YourTruth *MarkdownString `json:"your_truth,omitempty"`
}

type AtlasEntryID = string

type AtlasEntryIDWildcard = string

type AtlasID = string

type AtlasIDWildcard = string

// Challenge rank, represented as an integer from 1 (troublesome) to 5 (epic).
type ChallengeRank = uint8

// Describes a standard player character condition meter.
type ConditionMeterRule struct {
	// A description of this condition meter.
	Description MarkdownString `json:"description"`

	// A localized label for this input. In some contexts it may be undesirable to
	// render this text, but it should always be exposed to assistive technology
	// (e.g. with `aria-label` in HTML).
	Label Label `json:"label"`

	// The maximum value of this meter.
	Max int8 `json:"max"`

	// The minimum value of this meter.
	Min int8 `json:"min"`

	// Is this condition meter shared by all players?
	Shared bool `json:"shared"`

	// The current value of this meter.
	Value int8 `json:"value"`
}

type ConditionMeterRuleID = string

// A CSS color value. See: https://developer.mozilla.org/en-
// US/docs/Web/CSS/color_value
type CSSColor = string

// A delve site with a theme, domain, and denizen table.
type DelveSite struct {
	Denizens []DelveSiteDenizen `json:"denizens"`

	Description MarkdownString `json:"description"`

	Domain DelveSiteDomainID `json:"domain"`

	// The unique Datasworn ID for this item.
	ID DelveSiteID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	Rank ChallengeRank `json:"rank"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	Theme DelveSiteThemeID `json:"theme"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// An additional theme or domain card ID, for use with optional rules in
	// Ironsworn: Delve.
	ExtraCard *string `json:"extra_card,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// The ID of an atlas entry representing the region in which this delve site
	// is located.
	Region *AtlasEntryID `json:"region,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type DelveSiteDenizen struct {
	Frequency DelveSiteDenizenFrequency `json:"frequency"`

	// The unique Datasworn ID for this item.
	ID DelveSiteDenizenID `json:"id"`

	Max int16 `json:"max"`

	Min int16 `json:"min"`

	Name *Label `json:"name,omitempty"`

	// The ID of the relevant NPC entry, if one is specified.
	Npc *NpcID `json:"npc,omitempty"`
}

type DelveSiteDenizenFrequency string

const (
	DelveSiteDenizenFrequencyCommon DelveSiteDenizenFrequency = "common"

	DelveSiteDenizenFrequencyRare DelveSiteDenizenFrequency = "rare"

	DelveSiteDenizenFrequencyUncommon DelveSiteDenizenFrequency = "uncommon"

	DelveSiteDenizenFrequencyUnforeseen DelveSiteDenizenFrequency = "unforeseen"

	DelveSiteDenizenFrequencyVeryCommon DelveSiteDenizenFrequency = "very_common"
)

type DelveSiteDenizenID = string

type DelveSiteDomain struct {
	Dangers []DelveSiteDomainDangerRow `json:"dangers"`

	Features []DelveSiteDomainFeatureRow `json:"features"`

	// The unique Datasworn ID for this item.
	ID DelveSiteDomainID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	Summary MarkdownString `json:"summary"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	Description *MarkdownString `json:"description,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	// An oracle table ID containing place name elements. For examples, see
	// oracle ID `delve/oracles/site_name/place/barrow`, and its siblings in
	// oracle collection ID `delve/collections/oracles/site_name/place`. These
	// oracles are used by the site name oracle from Ironsworn: Delve (ID:
	// delve/oracles/site_name/format) to create random names for delve sites.
	NameOracle *OracleTableID `json:"name_oracle,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type DelveSiteDomainDangerRow struct {
	// The unique Datasworn ID for this item.
	ID DomainDangerRowID `json:"id"`

	// High end of the dice range for this table row.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row.
	Min int16 `json:"min"`

	Result MarkdownString `json:"result"`

	Description *MarkdownString `json:"description,omitempty"`

	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

type DelveSiteDomainFeatureRow struct {
	// The unique Datasworn ID for this item.
	ID DomainFeatureRowID `json:"id"`

	// High end of the dice range for this table row.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row.
	Min int16 `json:"min"`

	Result MarkdownString `json:"result"`

	Description *MarkdownString `json:"description,omitempty"`

	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

type DelveSiteDomainID = string

type DelveSiteID = string

type DelveSiteTheme struct {
	Dangers []DelveSiteThemeDangerRow `json:"dangers"`

	Features []DelveSiteThemeFeatureRow `json:"features"`

	// The unique Datasworn ID for this item.
	ID DelveSiteThemeID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	Summary MarkdownString `json:"summary"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	Description *MarkdownString `json:"description,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type DelveSiteThemeDangerRow struct {
	// The unique Datasworn ID for this item.
	ID ThemeDangerRowID `json:"id"`

	// High end of the dice range for this table row.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row.
	Min int16 `json:"min"`

	Result MarkdownString `json:"result"`

	Description *MarkdownString `json:"description,omitempty"`

	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

type DelveSiteThemeFeatureRow struct {
	// The unique Datasworn ID for this item.
	ID ThemeFeatureRowID `json:"id"`

	// High end of the dice range for this table row.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row.
	Min int16 `json:"min"`

	Result MarkdownString `json:"result"`

	Description *MarkdownString `json:"description,omitempty"`

	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

type DelveSiteThemeID = string

type DiceNotation = string

// A key used in a Datasworn dictionary object.
type DictKey = string

type DomainDangerRowID = string

type DomainFeatureRowID = string

type I18nHint struct {
	PartOfSpeech *PartOfSpeech `json:"part_of_speech,omitempty"`
}

type I18nHintsTemplate struct {
	Description *I18nHint `json:"description,omitempty"`

	Result *I18nHint `json:"result,omitempty"`

	Summary *I18nHint `json:"summary,omitempty"`
}

type I18nHints struct {
	Description *I18nHint `json:"description,omitempty"`

	Result *I18nHint `json:"result,omitempty"`

	Summary *I18nHint `json:"summary,omitempty"`

	Template *I18nHintsTemplate `json:"template,omitempty"`
}

// Describes a category of standard impacts/debilities.
type ImpactCategory struct {
	// A dictionary object of the Impacts in this category.
	Contents map[string]ImpactRule `json:"contents"`

	// A description of this impact category.
	Description MarkdownString `json:"description"`

	// A label for this impact category.
	Label Label `json:"label"`
}

// Describes a standard impact/debility.
type ImpactRule struct {
	// A description of this impact.
	Description MarkdownString `json:"description"`

	// The label for this impact.
	Label Label `json:"label"`

	// Is this impact permanent?
	Permanent bool `json:"permanent"`

	// Keys of ruleset condition meters, to which this impact prevents recovery.
	PreventsRecovery []DictKey `json:"prevents_recovery"`

	// Is this impact applied to all players at once?
	Shared bool `json:"shared"`
}

type ImpactRuleCollectionID = string

type ImpactRuleID = string

// A localized plain text name or label.
type Label = string

// Localized text, formatted in Markdown.
// 
// It uses some custom syntax; e.g. `{{table:some_oracle_table_id}}` indicates
// that the referenced oracle table is rendered there part of the source
// material.
type MarkdownString = string

type Move struct {
	RollType string

	ActionRoll MoveActionRoll

	NoRoll MoveNoRoll

	ProgressRoll MoveProgressRoll

	SpecialTrack MoveSpecialTrack
}

func (v Move) MarshalJSON() ([]byte, error) {
	switch v.RollType {
	case "action_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveActionRoll }{ v.RollType, v.ActionRoll })
	case "no_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveNoRoll }{ v.RollType, v.NoRoll })
	case "progress_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveProgressRoll }{ v.RollType, v.ProgressRoll })
	case "special_track":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveSpecialTrack }{ v.RollType, v.SpecialTrack })
	}

	return nil, fmt.Errorf("bad RollType value: %s", v.RollType)
}

func (v *Move) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"roll_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "action_roll":
		err = json.Unmarshal(b, &v.ActionRoll)
	case "no_roll":
		err = json.Unmarshal(b, &v.NoRoll)
	case "progress_roll":
		err = json.Unmarshal(b, &v.ProgressRoll)
	case "special_track":
		err = json.Unmarshal(b, &v.SpecialTrack)
	default:
		err = fmt.Errorf("bad RollType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.RollType = t.T
	return nil
}

type MoveActionRoll struct {
	// The unique Datasworn ID for this item.
	ID MoveID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	Trigger TriggerActionRoll `json:"trigger"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// Oracles associated with this move. It's not recommended to roll these
	// automatically, as almost all moves present them as an option, not a
	// requirement.
	Oracles []OracleTableID `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified move. References to the
	// replaced move can be considered equivalent to this move.
	Replaces *MoveID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type MoveNoRoll struct {
	// The unique Datasworn ID for this item.
	ID MoveID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	Trigger TriggerNoRoll `json:"trigger"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// Oracles associated with this move. It's not recommended to roll these
	// automatically, as almost all moves present them as an option, not a
	// requirement.
	Oracles []OracleTableID `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified move. References to the
	// replaced move can be considered equivalent to this move.
	Replaces *MoveID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type MoveProgressRoll struct {
	// The unique Datasworn ID for this item.
	ID MoveID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	// Describes the common features of progress tracks associated with this move.
	Tracks ProgressTrackTypeInfo `json:"tracks"`

	Trigger TriggerProgressRoll `json:"trigger"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// Oracles associated with this move. It's not recommended to roll these
	// automatically, as almost all moves present them as an option, not a
	// requirement.
	Oracles []OracleTableID `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified move. References to the
	// replaced move can be considered equivalent to this move.
	Replaces *MoveID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type MoveSpecialTrack struct {
	// The unique Datasworn ID for this item.
	ID MoveID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	Outcomes MoveOutcomes `json:"outcomes"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The complete rules text of the move.
	Text MarkdownString `json:"text"`

	Trigger TriggerSpecialTrack `json:"trigger"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// Oracles associated with this move. It's not recommended to roll these
	// automatically, as almost all moves present them as an option, not a
	// requirement.
	Oracles []OracleTableID `json:"oracles,omitempty"`

	// Indicates that this move replaces the identified move. References to the
	// replaced move can be considered equivalent to this move.
	Replaces *MoveID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type MoveCategory struct {
	Contents map[string]Move `json:"contents"`

	// The unique Datasworn ID for this item.
	ID MoveCategoryID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this collection.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This collection's content enhances the identified collection, rather than
	// being a standalone collection of its own.
	Enhances *MoveCategoryID `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This collection replaces the identified collection. References to the
	// replaced collection can be considered equivalent to this collection.
	Replaces *MoveCategoryID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`
}

type MoveCategoryID = string

type MoveEnhancement struct {
	RollType string

	ActionRoll MoveEnhancementActionRoll

	NoRoll MoveEnhancementNoRoll

	ProgressRoll MoveEnhancementProgressRoll

	SpecialTrack MoveEnhancementSpecialTrack
}

func (v MoveEnhancement) MarshalJSON() ([]byte, error) {
	switch v.RollType {
	case "action_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementActionRoll }{ v.RollType, v.ActionRoll })
	case "no_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementNoRoll }{ v.RollType, v.NoRoll })
	case "progress_roll":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementProgressRoll }{ v.RollType, v.ProgressRoll })
	case "special_track":
		return json.Marshal(struct { T string `json:"roll_type"`; MoveEnhancementSpecialTrack }{ v.RollType, v.SpecialTrack })
	}

	return nil, fmt.Errorf("bad RollType value: %s", v.RollType)
}

func (v *MoveEnhancement) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"roll_type"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "action_roll":
		err = json.Unmarshal(b, &v.ActionRoll)
	case "no_roll":
		err = json.Unmarshal(b, &v.NoRoll)
	case "progress_roll":
		err = json.Unmarshal(b, &v.ProgressRoll)
	case "special_track":
		err = json.Unmarshal(b, &v.SpecialTrack)
	default:
		err = fmt.Errorf("bad RollType value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.RollType = t.T
	return nil
}

type MoveEnhancementActionRoll struct {
	Enhances []MoveIDWildcard `json:"enhances,omitempty"`

	Trigger *TriggerActionRollEnhancement `json:"trigger,omitempty"`
}

type MoveEnhancementNoRoll struct {
	Enhances []MoveIDWildcard `json:"enhances,omitempty"`

	Trigger *TriggerNoRollEnhancement `json:"trigger,omitempty"`
}

type MoveEnhancementProgressRoll struct {
	Enhances []MoveIDWildcard `json:"enhances,omitempty"`

	Trigger *TriggerProgressRollEnhancement `json:"trigger,omitempty"`
}

type MoveEnhancementSpecialTrack struct {
	Enhances []MoveIDWildcard `json:"enhances,omitempty"`

	Trigger *TriggerSpecialTrackEnhancement `json:"trigger,omitempty"`
}

// A move ID, for a standard move or a unique asset move
type MoveID = string

// A move ID with wildcards.
type MoveIDWildcard = string

type MoveOutcome struct {
	Text MarkdownString `json:"text"`
}

type MoveOutcomeType string

const (
// The score doesn't beat either challenge die.
	MoveOutcomeTypeMiss MoveOutcomeType = "miss"

// The score is greater than both challenge dice.
	MoveOutcomeTypeStrongHit MoveOutcomeType = "strong_hit"

// The score is greater than one challenge die.
	MoveOutcomeTypeWeakHit MoveOutcomeType = "weak_hit"
)

// A standalone localized description for each move outcome (miss, weak hit,
// or strong hit). This is for for e.g. VTT implementations, where it's often
// useful to display only the rules text relevant to a roll result.
// 
//   This often requires light editorialization to create text that can stand
// alone without reference to the rest of the move. For example, 'as above'
// (in reference to another move outcome) shouldn't be used here; instead, the
// relevant text should be repeated.
type MoveOutcomes struct {
	Miss MoveOutcome `json:"miss"`

	StrongHit MoveOutcome `json:"strong_hit"`

	WeakHit MoveOutcome `json:"weak_hit"`
}

type MoveRollType string

const (
// A move that makes an action roll.
	MoveRollTypeActionRoll MoveRollType = "action_roll"

// A move that makes no action rolls or progress rolls.
	MoveRollTypeNoRoll MoveRollType = "no_roll"

// A progress move that rolls on a standard progress track type (defined by
// this move).
	MoveRollTypeProgressRoll MoveRollType = "progress_roll"

// A progress move that rolls on one or more special tracks, like Bonds (classic
// Ironsworn), Failure (Delve), or Legacies (Starforged).
	MoveRollTypeSpecialTrack MoveRollType = "special_track"
)

type NamespaceID = string

// A non-player character entry, similar to those in Chapter 5 of the Ironsworn
// Rulebook, or Chapter 4 of Starforged.
type Npc struct {
	Description MarkdownString `json:"description"`

	Drives []MarkdownString `json:"drives"`

	Features []MarkdownString `json:"features"`

	// The unique Datasworn ID for this item.
	ID NpcID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	Nature NpcNature `json:"nature"`

	QuestStarter MarkdownString `json:"quest_starter"`

	// The suggested challenge rank for this NPC.
	Rank ChallengeRank `json:"rank"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	Tactics []MarkdownString `json:"tactics"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Variants map[string]NpcVariant `json:"variants,omitempty"`

	YourTruth *MarkdownString `json:"your_truth,omitempty"`
}

type NpcCollection struct {
	Contents map[string]Npc `json:"contents"`

	// The unique Datasworn ID for this item.
	ID NpcCollectionID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this collection.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This collection's content enhances the identified collection, rather than
	// being a standalone collection of its own.
	Enhances *NpcCollectionID `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// This collection replaces the identified collection. References to the
	// replaced collection can be considered equivalent to this collection.
	Replaces *NpcCollectionID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`
}

type NpcCollectionID = string

type NpcID = string

type NpcIDWildcard = string

// A localized category label describing the nature of this NPC.
// 
// In Ironsworn classic, this is probably the singular form of the parent
// collection's name.
// 
// For Starforged, see the table on p. 258 for examples.
type NpcNature = Label

type NpcVariant struct {
	Description MarkdownString `json:"description"`

	// The unique Datasworn ID for this item.
	ID NpcVariantID `json:"id"`

	Name Label `json:"name"`

	Nature NpcNature `json:"nature"`

	// The suggested challenge rank for this NPC.
	Rank ChallengeRank `json:"rank"`

	Summary *MarkdownString `json:"summary,omitempty"`
}

type NpcVariantID = string

type OracleCollection struct {
	Collections map[string]OracleCollection `json:"collections"`

	Contents map[string]OracleTable `json:"contents"`

	// The unique Datasworn ID for this item.
	ID OracleCollectionID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A thematic color associated with this collection.
	Color *CSSColor `json:"color,omitempty"`

	// A longer description of this collection, which might include multiple
	// paragraphs. If it's only a couple sentences, use the `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// This collection's content enhances the identified collection, rather than
	// being a standalone collection of its own.
	Enhances *OracleCollectionID `json:"enhances,omitempty"`

	// An SVG icon associated with this collection.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	Rendering *OracleCollectionRendering `json:"rendering,omitempty"`

	// This collection replaces the identified collection. References to the
	// replaced collection can be considered equivalent to this collection.
	Replaces *OracleCollectionID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of this collection, no more than a few sentences in length.
	// This is intended for use in application tooltips and similar sorts of hints.
	// Longer text should use the "description" key instead.
	Summary *MarkdownString `json:"summary,omitempty"`
}

type OracleCollectionID = string

// Describes the presentation of this oracle collection, which might represent a
// group of separate tables, or a single table with additional columns.
type OracleCollectionRendering struct {
	Style string

	MultiTable OracleCollectionRenderingMultiTable
}

func (v OracleCollectionRendering) MarshalJSON() ([]byte, error) {
	switch v.Style {
	case "multi_table":
		return json.Marshal(struct { T string `json:"style"`; OracleCollectionRenderingMultiTable }{ v.Style, v.MultiTable })
	}

	return nil, fmt.Errorf("bad Style value: %s", v.Style)
}

func (v *OracleCollectionRendering) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"style"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "multi_table":
		err = json.Unmarshal(b, &v.MultiTable)
	default:
		err = fmt.Errorf("bad Style value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.Style = t.T
	return nil
}

type OracleCollectionRenderingMultiTable struct {
	Columns map[string]OracleCollectionTableColumn `json:"columns"`
}

type OracleCollectionStyle string

const (
// Presented as a single table, with its OracleTable children rendered as
// columns.
	OracleCollectionStyleMultiTable OracleCollectionStyle = "multi_table"

// Presented as a collection of separate tables.
	OracleCollectionStyleTables OracleCollectionStyle = "tables"
)

type OracleCollectionTableColumn struct {
	ContentType OracleTableColumnContentKey `json:"content_type"`

	// The column's header text.
	Label Label `json:"label"`

	// The key of the OracleTable (within this collection), whose data is used to
	// render this column.
	TableKey DictKey `json:"table_key"`

	// The thematic color for this column.
	Color *CSSColor `json:"color,omitempty"`
}

// Provides string templates that may be used in place of the static
// row text from `OracleTableRow#result`, `OracleTableRow#summary`, and
// `OracleTableRow#description`.
// 
//   These strings are formatted in Markdown, but use a special syntax for their
// placeholders: `{{result:some_oracle_table_id}}`. The placeholder should be
// replaced with the value of a rolled (or selected) `OracleTableRow#result`
// from the target oracle table ID.
type OracleRollTemplate struct {
	// A string template that may be used in place of OracleTableRow#description.
	Description *TemplateString `json:"description,omitempty"`

	// A string template that may be used in place of OracleTableRow#result.
	Result *TemplateString `json:"result,omitempty"`

	// A string template that may be used in place of OracleTableRow#summary.
	Summary *TemplateString `json:"summary,omitempty"`
}

type OracleTable struct {
	// The roll used to select a result on this table.
	Dice DiceNotation `json:"dice"`

	// The unique Datasworn ID for this item.
	ID OracleTableID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	Table []OracleTableRow `json:"table"`

	I18n *I18nHints `json:"_i18n,omitempty"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	// A longer description of the oracle table's intended usage, which might
	// include multiple paragraphs. If it's only a couple sentences, use the
	// `summary` key instead.
	Description *MarkdownString `json:"description,omitempty"`

	// An icon that represents this table.
	Icon *SvgImageURL `json:"icon,omitempty"`

	Images []WebpImageURL `json:"images,omitempty"`

	// Most oracle tables are insensitive to matches, but a few define special
	// match behavior.
	Match *OracleTableMatchBehavior `json:"match,omitempty"`

	// Describes how how to render this table, when presenting it as a standalone
	// table.
	Rendering *OracleTableRendering `json:"rendering,omitempty"`

	// Indicates that this table replaces the identified table. References to the
	// replaced table can be considered equivalent to this table.
	Replaces *OracleTableID `json:"replaces,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	// A brief summary of the oracle table's intended usage, no more than a few
	// sentences in length. This is intended for use in application tooltips
	// and similar sorts of hints. Longer text should use the "description" key
	// instead.
	Summary *MarkdownString `json:"summary,omitempty"`
}

type OracleTableColumn struct {
	ContentType OracleTableColumnContentKey `json:"content_type"`

	// The column's header text.
	Label Label `json:"label"`

	// The thematic color for this column.
	Color *CSSColor `json:"color,omitempty"`
}

// The value(s) from each OracleTableRow that is rendered in this column.
type OracleTableColumnContentKey string

const (
// Column displays the OracleTableRow's `description` key.
	OracleTableColumnContentKeyDescription OracleTableColumnContentKey = "description"

// Column displays the OracleTableRow's `result` key.
	OracleTableColumnContentKeyResult OracleTableColumnContentKey = "result"

// Column displays the roll range (`min` and `max`) of each OracleTableRow.
	OracleTableColumnContentKeyRoll OracleTableColumnContentKey = "roll"

// Column displays the OracleTableRow's `summary` key.
	OracleTableColumnContentKeySummary OracleTableColumnContentKey = "summary"
)

type OracleTableID = string

// Oracle table wildcards can also use '**' to represent any number of
// collection levels in the oracle tree.
type OracleTableIDWildcard = string

type OracleTableMatchBehavior struct {
	Text MarkdownString `json:"text"`
}

// Describes the presentation of this table.
type OracleTableRendering struct {
	Style string

	Standalone OracleTableRenderingStandalone
}

func (v OracleTableRendering) MarshalJSON() ([]byte, error) {
	switch v.Style {
	case "standalone":
		return json.Marshal(struct { T string `json:"style"`; OracleTableRenderingStandalone }{ v.Style, v.Standalone })
	}

	return nil, fmt.Errorf("bad Style value: %s", v.Style)
}

func (v *OracleTableRendering) UnmarshalJSON(b []byte) error {
	var t struct { T string `json:"style"` }
	if err := json.Unmarshal(b, &t); err != nil {
		return err
	}

	var err error
	switch t.T {
	case "standalone":
		err = json.Unmarshal(b, &v.Standalone)
	default:
		err = fmt.Errorf("bad Style value: %s", t.T)
	}

	if err != nil {
		return err
	}

	v.Style = t.T
	return nil
}

type OracleTableRenderingStandalone struct {
	Columns map[string]OracleTableColumn `json:"columns"`
}

type OracleTableRoll struct {
	// The rulebook explicitly cautions *against* rolling all details at once,
	// so rolling every referenced oracle automatically is not recommended. That
	// said, some oracle results only provide useful information once a secondary
	// roll occurs, such as "Action + Theme". If this value is omitted, assume
	// it's false.
	Auto *bool `json:"auto,omitempty"`

	Method *OracleTableRollMethod `json:"method,omitempty"`

	// The ID of the oracle table to be rolled. If omitted, it defaults to the ID
	// of this oracle table.
	Oracle *OracleTableID `json:"oracle,omitempty"`

	Times *int16 `json:"times,omitempty"`
}

// Special roll instructions to use when rolling multiple times on a single
// oracle table.
type OracleTableRollMethod string

const (
// Duplicates should be kept.
	OracleTableRollMethodKeepDuplicates OracleTableRollMethod = "keep_duplicates"

// Duplicates should be kept, and they compound to make things worse.
	OracleTableRollMethodMakeItWorse OracleTableRollMethod = "make_it_worse"

// Duplicates should be re-rolled.
	OracleTableRollMethodNoDuplicates OracleTableRollMethod = "no_duplicates"
)

type OracleTableRow struct {
	// The unique Datasworn ID for this item.
	ID OracleTableRowID `json:"id"`

	// High end of the dice range for this table row.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row.
	Min int16 `json:"min"`

	Result MarkdownString `json:"result"`

	Description *MarkdownString `json:"description,omitempty"`

	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// Normally, rows will end with two numbers separated by a dash, indicating
// their dice range.
// 
// Rows with a single number represent unrollable rows that are sometimes
// included for rendering purposes; in this case, the number represents the
// row's index.
type OracleTableRowID = string

type OracleTableStyle string

const (
// Render as a single column of a table.
	OracleTableStyleColumn OracleTableStyle = "column"

// Render as a table, within a row in another table.
	OracleTableStyleEmbedInRow OracleTableStyle = "embed_in_row"

// Render as a standalone table.
	OracleTableStyleStandalone OracleTableStyle = "standalone"
)

type PartOfSpeech string

const (
// An adjective.
	PartOfSpeechAdjective PartOfSpeech = "adjective"

// A common noun used as an adjective, to modify another noun.
	PartOfSpeechAdjunctCommonNoun PartOfSpeech = "adjunct_common_noun"

// A proper noun used as an adjective, to modify another noun.
	PartOfSpeechAdjunctProperNoun PartOfSpeech = "adjunct_proper_noun"

// A verb used as an adjective, to modify a noun.
	PartOfSpeechAttributiveVerb PartOfSpeech = "attributive_verb"

// A common noun.
	PartOfSpeechCommonNoun PartOfSpeech = "common_noun"

// Gerund or present participle of a verb, e.g. "going", "seeing", "waving"
	PartOfSpeechGerund PartOfSpeech = "gerund"

// A proper noun.
	PartOfSpeechProperNoun PartOfSpeech = "proper_noun"

// A verb in present tense
	PartOfSpeechVerb PartOfSpeech = "verb"
)

// A basic, rollable player character resource.
type PlayerConditionMeter = DictKey

// A basic player character stat.
type PlayerStat = DictKey

type ProgressRollMethod string

const (
// An automatic miss.
	ProgressRollMethodMiss ProgressRollMethod = "miss"

// Make a progress roll on a progress track associated with this move.
	ProgressRollMethodProgressRoll ProgressRollMethod = "progress_roll"

// An automatic strong hit.
	ProgressRollMethodStrongHit ProgressRollMethod = "strong_hit"

// An automatic weak hit.
	ProgressRollMethodWeakHit ProgressRollMethod = "weak_hit"
)

type ProgressRollOptionUsing string

const (
	ProgressRollOptionUsingProgressTrack ProgressRollOptionUsing = "progress_track"
)

type ProgressRollOption struct {
	Using ProgressRollOptionUsing `json:"using"`
}

// Describes the features of a type of progress track.
type ProgressTrackTypeInfo struct {
	// A category label for progress tracks of this type.
	Category Label `json:"category"`

	Controls map[string]interface{} `json:"controls,omitempty"`
}

// A rarity, as described in Ironsworn: Delve.
type Rarity struct {
	// The asset augmented by this rarity.
	Asset AssetID `json:"asset"`

	Description MarkdownString `json:"description"`

	// The unique Datasworn ID for this item.
	ID RarityID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// From Ironsworn: Delve, p. 174:
	// 
	//       Some assets will bring a rarity into play more often than others, so
	// the experience point cost for a rarity will vary by the linked asset. These
	// costs are shown in the tables on page 175.
	// 
	//       If you are playing solo, and aren’t concerned with the relative
	// balance of rarity abilities, you can ignore these variable costs. If so,
	// spend 3 experience points to purchase a rarity.
	XpCost int16 `json:"xp_cost"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`
}

type RarityID = string

// Describes rules for player characters in this ruleset, such as stats and
// condition meters.
type Rules struct {
	// Describes the standard condition meters used by player characters in this
	// ruleset.
	ConditionMeters map[string]ConditionMeterRule `json:"condition_meters"`

	// Describes the standard impacts/debilities used by player characters in this
	// ruleset.
	Impacts map[string]ImpactCategory `json:"impacts"`

	// Describes the special tracks used by player characters in this ruleset, like
	// Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
	SpecialTracks map[string]SpecialTrackRule `json:"special_tracks"`

	// Describes the standard stats used by player characters in this ruleset.
	Stats map[string]StatRule `json:"stats"`
}

type SourceAuthor struct {
	Name string `json:"name"`

	// An optional email contact for the author
	Email *string `json:"email,omitempty"`

	// An optional URL for the author's website.
	URL *string `json:"url,omitempty"`
}

// Metadata describing the original source of this item
type Source struct {
	Authors []SourceAuthor `json:"authors"`

	// The date of the source documents's last update, formatted YYYY-MM-DD.
	// Required because it's used to determine whether the data needs updating.
	Date string `json:"date"`

	License string `json:"license"`

	// The title of the source document.
	Title string `json:"title"`

	// An absolute URL where the source document is available.
	URL string `json:"url"`

	// The page number where this item is described in full.
	Page *int16 `json:"page,omitempty"`
}

type SpecialTrackRollMethod string

const (
// Use **every** roll option at once.
	SpecialTrackRollMethodAll SpecialTrackRollMethod = "all"

// Use the roll option with the best/highest value.
	SpecialTrackRollMethodHighest SpecialTrackRollMethod = "highest"

// Use the roll option with the worst/lowest value.
	SpecialTrackRollMethodLowest SpecialTrackRollMethod = "lowest"

// An automatic miss.
	SpecialTrackRollMethodMiss SpecialTrackRollMethod = "miss"

// The player chooses which roll option to use.
	SpecialTrackRollMethodPlayerChoice SpecialTrackRollMethod = "player_choice"

// An automatic strong hit.
	SpecialTrackRollMethodStrongHit SpecialTrackRollMethod = "strong_hit"

// An automatic weak hit.
	SpecialTrackRollMethodWeakHit SpecialTrackRollMethod = "weak_hit"
)

// Describes a special track like Bonds (classic Ironsworn), Failure (Delve), or
// Legacies (Starforged).
type SpecialTrackRule struct {
	// A description of this special track.
	Description MarkdownString `json:"description"`

	// A label for this special track.
	Label Label `json:"label"`

	// Is this track an optional rule?
	Optional bool `json:"optional"`

	// Is this track shared by all players?
	Shared bool `json:"shared"`
}

type SpecialTrackRuleID = string

// Special, ruleset-specific progress tracks. Usually, one exists per player
// character, and they persist through the life of the player character.
// 'Canonical' examples:
//   * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged
// legacy track, use `bonds_legacy` instead.
//   * `failure_track`, described in Ironsworn: Delve
//   * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described
// Ironsworn: Starforged
// 
type SpecialTrackType = DictKey

// Describes a standard player character stat.
type StatRule struct {
	// A description of this stat.
	Description MarkdownString `json:"description"`

	// A label for this stat.
	Label Label `json:"label"`
}

type StatRuleID = string

type Suggestions struct {
	Assets []AssetID `json:"assets,omitempty"`

	Atlas []AtlasEntryID `json:"atlas,omitempty"`

	Moves []MoveID `json:"moves,omitempty"`

	Npcs []NpcID `json:"npcs,omitempty"`

	Oracles []OracleTableID `json:"oracles,omitempty"`

	Rarities []RarityID `json:"rarities,omitempty"`

	SiteDomains []DelveSiteDomainID `json:"site_domains,omitempty"`

	SiteThemes []DelveSiteThemeID `json:"site_themes,omitempty"`
}

// A relative URL pointing to a vector image in the SVG format.
type SvgImageURL = string

// A rich text string in Markdown with replaced values from oracle roll results.
// 
// The custom syntax `{{some_row_key:some_oracle_table_id}}` should be replaced
// by the `some_row_key` string of a rolled oracle table. This is usually the
// `result` key, for example `{{result:starforged/oracles/core/action}}`
type TemplateString = string

type ThemeDangerRowID = string

type ThemeFeatureRowID = string

type TriggerActionRoll struct {
	Conditions []TriggerActionRollCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerActionRollCondition struct {
	Method ActionRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []ActionRollOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerActionRollConditionEnhancement struct {
	Method ActionRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []ActionRollOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerActionRollEnhancement struct {
	Conditions []TriggerActionRollConditionEnhancement `json:"conditions"`
}

// Information on who can trigger this trigger condition. Usually this is just
// the player, but some asset abilities can trigger from an ally's move.
type TriggerBy struct {
	Ally bool `json:"ally"`

	Player bool `json:"player"`
}

type TriggerNoRoll struct {
	Conditions []TriggerNoRollCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerNoRollCondition struct {
	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerNoRollEnhancement struct {
	Conditions []TriggerNoRollCondition `json:"conditions"`
}

type TriggerProgressRoll struct {
	Conditions []TriggerProgressRollCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerProgressRollCondition struct {
	Method ProgressRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []ProgressRollOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerProgressRollConditionEnhancement struct {
	Method ProgressRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []ProgressRollOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerProgressRollEnhancement struct {
	Conditions []TriggerProgressRollConditionEnhancement `json:"conditions"`
}

type TriggerSpecialTrack struct {
	Conditions []TriggerSpecialTrackCondition `json:"conditions"`

	// A markdown string containing the primary trigger text for this move.
	// 
	// Secondary trigger text (for specific stats or uses of an asset ability) may
	// be described in individual trigger conditions.
	Text MarkdownString `json:"text"`
}

type TriggerSpecialTrackCondition struct {
	Method SpecialTrackRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []TriggerSpecialTrackConditionOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

// A progress move that rolls on one or more special tracks, like Bonds (classic
// Ironsworn), Failure (Delve), or Legacy (Starforged).
type TriggerSpecialTrackConditionEnhancement struct {
	Method SpecialTrackRollMethod `json:"method"`

	// The options available when rolling with this trigger condition.
	RollOptions []TriggerSpecialTrackConditionOption `json:"roll_options"`

	By *TriggerBy `json:"by,omitempty"`

	// A markdown string of any trigger text specific to this trigger condition.
	Text *MarkdownString `json:"text,omitempty"`
}

type TriggerSpecialTrackConditionOption struct {
	Using SpecialTrackType `json:"using"`
}

type TriggerSpecialTrackEnhancement struct {
	Conditions []TriggerSpecialTrackConditionEnhancement `json:"conditions"`
}

// A setting truth category.
type Truth struct {
	// The unique Datasworn ID for this item.
	ID TruthID `json:"id"`

	// The primary name/label for this item.
	Name Label `json:"name"`

	Options []TruthOption `json:"options"`

	// Attribution for the original source (such as a book or website) of this
	// item, including the author and licensing information.
	Source Source `json:"source"`

	// The name of this item as it appears on the page in the book, if it's
	// different from `name`.
	CanonicalName *Label `json:"canonical_name,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	YourCharacter *MarkdownString `json:"your_character,omitempty"`
}

type TruthID = string

type TruthOption struct {
	Description MarkdownString `json:"description"`

	// The unique Datasworn ID for this item.
	ID TruthOptionID `json:"id"`

	QuestStarter MarkdownString `json:"quest_starter"`

	Max *int16 `json:"max,omitempty"`

	Min *int16 `json:"min,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Table []TruthOptionTableRow `json:"table,omitempty"`
}

type TruthOptionID = string

type TruthOptionTableRow struct {
	// High end of the dice range for this table row.
	Max int16 `json:"max"`

	// Low end of the dice range for this table row.
	Min int16 `json:"min"`

	Result MarkdownString `json:"result"`

	Description *MarkdownString `json:"description,omitempty"`

	EmbedTable *OracleTableID `json:"embed_table,omitempty"`

	I18n *I18nHints `json:"i18n,omitempty"`

	Icon *SvgImageURL `json:"icon,omitempty"`

	Rolls []OracleTableRoll `json:"rolls,omitempty"`

	Suggestions *Suggestions `json:"suggestions,omitempty"`

	Summary *MarkdownString `json:"summary,omitempty"`

	Template *OracleRollTemplate `json:"template,omitempty"`
}

// A relative URL pointing to a raster image in the WEBP format.
type WebpImageURL = string
