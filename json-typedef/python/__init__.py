# Code generated by jtd-codegen for Python v0.3.1

import re
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import Any, Dict, List, Optional, Type, Union, get_args, get_origin


@dataclass
class RulesPackage:
    """
    Describes game rules compatible with the Ironsworn tabletop role-playing
    game by Shawn Tomkin.
    """

    package_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesPackage':
        variants: Dict[str, Type[RulesPackage]] = {
            "expansion": RulesPackageExpansion,
            "ruleset": RulesPackageRuleset,
        }

        return variants[data["package_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class RulesPackageExpansion(RulesPackage):
    """
    A Datasworn package that relies on an external package to provide its
    ruleset.
    """

    datasworn_version: 'SemanticVersion'
    """
    The version of the Datasworn format used by this data.
    """

    id: 'ExpansionID'
    ruleset: 'RulesetID'
    assets: 'Optional[Dict[str, AssetType]]'
    """
    A dictionary object containing asset types, which contain assets.
    """

    atlas: 'Optional[Dict[str, Atlas]]'
    """
    A dictionary object containing atlas collections, which contain atlas
    entries.
    """

    delve_sites: 'Optional[Dict[str, DelveSite]]'
    """
    A dictionary object of delve sites, like the premade delve sites presented
    in Ironsworn: Delve
    """

    moves: 'Optional[Dict[str, MoveCategory]]'
    """
    A dictionary object containing move categories, which contain moves.
    """

    npcs: 'Optional[Dict[str, NpcCollection]]'
    """
    A dictionary object containing NPC collections, which contain NPCs.
    """

    oracles: 'Optional[Dict[str, OracleCollection]]'
    """
    A dictionary object containing oracle collections, which may contain oracle
    tables and/or oracle collections.
    """

    rarities: 'Optional[Dict[str, Rarity]]'
    """
    A dictionary object containing rarities, like those presented in Ironsworn:
    Delve.
    """

    rules: 'Optional[RulesExpansion]'
    site_domains: 'Optional[Dict[str, DelveSiteDomain]]'
    """
    A dictionary object containing delve site domains.
    """

    site_themes: 'Optional[Dict[str, DelveSiteTheme]]'
    """
    A dictionary object containing delve site themes.
    """

    truths: 'Optional[Dict[str, Truth]]'
    """
    A dictionary object of truth categories.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesPackageExpansion':
        return cls(
            "expansion",
            _from_json_data(SemanticVersion, data.get("datasworn_version")),
            _from_json_data(ExpansionID, data.get("id")),
            _from_json_data(RulesetID, data.get("ruleset")),
            _from_json_data(Optional[Dict[str, AssetType]], data.get("assets")),
            _from_json_data(Optional[Dict[str, Atlas]], data.get("atlas")),
            _from_json_data(Optional[Dict[str, DelveSite]], data.get("delve_sites")),
            _from_json_data(Optional[Dict[str, MoveCategory]], data.get("moves")),
            _from_json_data(Optional[Dict[str, NpcCollection]], data.get("npcs")),
            _from_json_data(Optional[Dict[str, OracleCollection]], data.get("oracles")),
            _from_json_data(Optional[Dict[str, Rarity]], data.get("rarities")),
            _from_json_data(Optional[RulesExpansion], data.get("rules")),
            _from_json_data(Optional[Dict[str, DelveSiteDomain]], data.get("site_domains")),
            _from_json_data(Optional[Dict[str, DelveSiteTheme]], data.get("site_themes")),
            _from_json_data(Optional[Dict[str, Truth]], data.get("truths")),
        )

    def to_json_data(self) -> Any:
        data = { "package_type": "expansion" }
        data["datasworn_version"] = _to_json_data(self.datasworn_version)
        data["id"] = _to_json_data(self.id)
        data["ruleset"] = _to_json_data(self.ruleset)
        if self.assets is not None:
             data["assets"] = _to_json_data(self.assets)
        if self.atlas is not None:
             data["atlas"] = _to_json_data(self.atlas)
        if self.delve_sites is not None:
             data["delve_sites"] = _to_json_data(self.delve_sites)
        if self.moves is not None:
             data["moves"] = _to_json_data(self.moves)
        if self.npcs is not None:
             data["npcs"] = _to_json_data(self.npcs)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.rarities is not None:
             data["rarities"] = _to_json_data(self.rarities)
        if self.rules is not None:
             data["rules"] = _to_json_data(self.rules)
        if self.site_domains is not None:
             data["site_domains"] = _to_json_data(self.site_domains)
        if self.site_themes is not None:
             data["site_themes"] = _to_json_data(self.site_themes)
        if self.truths is not None:
             data["truths"] = _to_json_data(self.truths)
        return data

@dataclass
class RulesPackageRuleset(RulesPackage):
    """
    A standalone Datasworn package that describes its own ruleset.
    """

    assets: 'Dict[str, AssetType]'
    """
    A dictionary object containing asset types, which contain assets.
    """

    datasworn_version: 'SemanticVersion'
    """
    The version of the Datasworn format used by this data.
    """

    id: 'RulesetID'
    moves: 'Dict[str, MoveCategory]'
    """
    A dictionary object containing move categories, which contain moves.
    """

    oracles: 'Dict[str, OracleCollection]'
    """
    A dictionary object containing oracle collections, which may contain oracle
    tables and/or oracle collections.
    """

    rules: 'Rules'
    atlas: 'Optional[Dict[str, Atlas]]'
    """
    A dictionary object containing atlas collections, which contain atlas
    entries.
    """

    delve_sites: 'Optional[Dict[str, DelveSite]]'
    """
    A dictionary object of delve sites, like the premade delve sites presented
    in Ironsworn: Delve
    """

    npcs: 'Optional[Dict[str, NpcCollection]]'
    """
    A dictionary object containing NPC collections, which contain NPCs.
    """

    rarities: 'Optional[Dict[str, Rarity]]'
    """
    A dictionary object containing rarities, like those presented in Ironsworn:
    Delve.
    """

    site_domains: 'Optional[Dict[str, DelveSiteDomain]]'
    """
    A dictionary object containing delve site domains.
    """

    site_themes: 'Optional[Dict[str, DelveSiteTheme]]'
    """
    A dictionary object containing delve site themes.
    """

    truths: 'Optional[Dict[str, Truth]]'
    """
    A dictionary object of truth categories.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesPackageRuleset':
        return cls(
            "ruleset",
            _from_json_data(Dict[str, AssetType], data.get("assets")),
            _from_json_data(SemanticVersion, data.get("datasworn_version")),
            _from_json_data(RulesetID, data.get("id")),
            _from_json_data(Dict[str, MoveCategory], data.get("moves")),
            _from_json_data(Dict[str, OracleCollection], data.get("oracles")),
            _from_json_data(Rules, data.get("rules")),
            _from_json_data(Optional[Dict[str, Atlas]], data.get("atlas")),
            _from_json_data(Optional[Dict[str, DelveSite]], data.get("delve_sites")),
            _from_json_data(Optional[Dict[str, NpcCollection]], data.get("npcs")),
            _from_json_data(Optional[Dict[str, Rarity]], data.get("rarities")),
            _from_json_data(Optional[Dict[str, DelveSiteDomain]], data.get("site_domains")),
            _from_json_data(Optional[Dict[str, DelveSiteTheme]], data.get("site_themes")),
            _from_json_data(Optional[Dict[str, Truth]], data.get("truths")),
        )

    def to_json_data(self) -> Any:
        data = { "package_type": "ruleset" }
        data["assets"] = _to_json_data(self.assets)
        data["datasworn_version"] = _to_json_data(self.datasworn_version)
        data["id"] = _to_json_data(self.id)
        data["moves"] = _to_json_data(self.moves)
        data["oracles"] = _to_json_data(self.oracles)
        data["rules"] = _to_json_data(self.rules)
        if self.atlas is not None:
             data["atlas"] = _to_json_data(self.atlas)
        if self.delve_sites is not None:
             data["delve_sites"] = _to_json_data(self.delve_sites)
        if self.npcs is not None:
             data["npcs"] = _to_json_data(self.npcs)
        if self.rarities is not None:
             data["rarities"] = _to_json_data(self.rarities)
        if self.site_domains is not None:
             data["site_domains"] = _to_json_data(self.site_domains)
        if self.site_themes is not None:
             data["site_themes"] = _to_json_data(self.site_themes)
        if self.truths is not None:
             data["truths"] = _to_json_data(self.truths)
        return data

class ActionRollMethod(Enum):
    ALL = "all"
    """
    Use _every_ roll option at once.
    """

    HIGHEST = "highest"
    """
    Use the roll option with the best/highest value.
    """

    LOWEST = "lowest"
    """
    Use the roll option with the worst/lowest value.
    """

    MISS = "miss"
    """
    An automatic miss.
    """

    PLAYER_CHOICE = "player_choice"
    """
    The player chooses which roll option to use.
    """

    STRONG_HIT = "strong_hit"
    """
    An automatic strong hit.
    """

    WEAK_HIT = "weak_hit"
    """
    An automatic weak hit.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'ActionRollMethod':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Asset:
    abilities: 'List[AssetAbility]'
    asset_type: 'Label'
    """
    A localized category label for this asset. This is the surtitle above the
    asset's name on the card.
    """

    count_as_impact: 'bool'
    """
    If `true`, this asset counts as an impact (Starforged) or a debility
    (classic Ironsworn).
    """

    id: 'AssetID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    shared: 'bool'
    """
    Most assets only benefit to their owner, but certain assets (like
    Starforged's module and command vehicle assets) are shared amongst the
    player's allies, too.
    """

    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    attachments: 'Optional[AssetAttachment]'
    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this asset.
    """

    controls: 'Optional[Dict[str, AssetControlField]]'
    """
    Controls are condition meters, clocks, counters, and other asset input
    fields whose values are expected to change throughout the life of the asset.
    """

    icon: 'Optional[SvgImageURL]'
    """
    This asset's icon.
    """

    options: 'Optional[Dict[str, AssetOptionField]]'
    """
    Options are input fields set when the player purchases the asset. They're
    likely to remain the same through the life of the asset. Typically, they are
    rendered at the top of the asset card.
    """

    requirement: 'Optional[MarkdownString]'
    """
    Describes prerequisites for purchasing or using this asset.
    """

    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Asset':
        return cls(
            _from_json_data(List[AssetAbility], data.get("abilities")),
            _from_json_data(Label, data.get("asset_type")),
            _from_json_data(bool, data.get("count_as_impact")),
            _from_json_data(AssetID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(bool, data.get("shared")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(Optional[AssetAttachment], data.get("attachments")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, AssetControlField]], data.get("controls")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[Dict[str, AssetOptionField]], data.get("options")),
            _from_json_data(Optional[MarkdownString], data.get("requirement")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["abilities"] = _to_json_data(self.abilities)
        data["asset_type"] = _to_json_data(self.asset_type)
        data["count_as_impact"] = _to_json_data(self.count_as_impact)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["shared"] = _to_json_data(self.shared)
        data["source"] = _to_json_data(self.source)
        if self.attachments is not None:
             data["attachments"] = _to_json_data(self.attachments)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.options is not None:
             data["options"] = _to_json_data(self.options)
        if self.requirement is not None:
             data["requirement"] = _to_json_data(self.requirement)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class AssetAbility:
    """
    An asset ability: one of the purchasable features of an asset. Most assets
    have three.
    """

    enabled: 'bool'
    """
    Is this asset ability enabled?
    """

    id: 'AssetAbilityID'
    """
    The unique Datasworn ID for this item.
    """

    text: 'MarkdownString'
    """
    The complete rules text of this asset ability.
    """

    controls: 'Optional[Dict[str, AssetAbilityControlField]]'
    """
    Fields whose values are expected to change over the life of the asset.
    """

    enhance_asset: 'Optional[AssetEnhancement]'
    """
    Changes made to the asset, when this ability is enabled.
    """

    enhance_moves: 'Optional[List[MoveEnhancement]]'
    """
    Describes changes made to various moves by this asset ability. Usually these
    require specific trigger conditions.
    """

    moves: 'Optional[Dict[str, Move]]'
    """
    Unique moves added by this asset ability.
    """

    name: 'Optional[Label]'
    """
    A handful of asset abilities have a label/name, for instance classic
    Ironsworn companion assets. Most canonical assets omit this property.
    """

    options: 'Optional[Dict[str, AssetAbilityOptionField]]'
    """
    Fields that are expected to be set once and remain the same through the life
    of the asset.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbility':
        return cls(
            _from_json_data(bool, data.get("enabled")),
            _from_json_data(AssetAbilityID, data.get("id")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Optional[Dict[str, AssetAbilityControlField]], data.get("controls")),
            _from_json_data(Optional[AssetEnhancement], data.get("enhance_asset")),
            _from_json_data(Optional[List[MoveEnhancement]], data.get("enhance_moves")),
            _from_json_data(Optional[Dict[str, Move]], data.get("moves")),
            _from_json_data(Optional[Label], data.get("name")),
            _from_json_data(Optional[Dict[str, AssetAbilityOptionField]], data.get("options")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["enabled"] = _to_json_data(self.enabled)
        data["id"] = _to_json_data(self.id)
        data["text"] = _to_json_data(self.text)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        if self.enhance_asset is not None:
             data["enhance_asset"] = _to_json_data(self.enhance_asset)
        if self.enhance_moves is not None:
             data["enhance_moves"] = _to_json_data(self.enhance_moves)
        if self.moves is not None:
             data["moves"] = _to_json_data(self.moves)
        if self.name is not None:
             data["name"] = _to_json_data(self.name)
        if self.options is not None:
             data["options"] = _to_json_data(self.options)
        return data

@dataclass
class AssetAbilityControlField:
    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlField':
        variants: Dict[str, Type[AssetAbilityControlField]] = {
            "checkbox": AssetAbilityControlFieldCheckbox,
            "clock": AssetAbilityControlFieldClock,
            "counter": AssetAbilityControlFieldCounter,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetAbilityControlFieldCheckbox(AssetAbilityControlField):
    """
    Represents a checkbox.
    """

    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    id: 'AssetAbilityControlFieldID'
    """
    The unique Datasworn ID for this item.
    """

    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'InputLabel'
    value: 'bool'
    """
    Is the box checked?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldCheckbox':
        return cls(
            "checkbox",
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(AssetAbilityControlFieldID, data.get("id")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "checkbox" }
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["id"] = _to_json_data(self.id)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetAbilityControlFieldClock(AssetAbilityControlField):
    """
    A clock with 4 or more segments.
    """

    id: 'AssetAbilityControlFieldID'
    """
    The unique Datasworn ID for this item.
    """

    label: 'InputLabel'
    max: 'int'
    """
    The size of the clock -- in other words, the maximum number of filled clock
    segments. Standard clocks have 4, 6, 8, or 10 segments.
    """

    min: 'int'
    """
    The minimum number of filled clock segments. This is always 0.
    """

    value: 'int'
    """
    The current number of filled clock segments.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldClock':
        return cls(
            "clock",
            _from_json_data(AssetAbilityControlFieldID, data.get("id")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(int, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "clock" }
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetAbilityControlFieldCounter(AssetAbilityControlField):
    """
    A basic counter representing a non-rollable integer value. They usually
    start at 0, and may or may not have a maximum.
    """

    id: 'AssetAbilityControlFieldID'
    """
    The unique Datasworn ID for this item.
    """

    label: 'InputLabel'
    max: 'int'
    min: 'int'
    """
    The (inclusive) minimum value.
    """

    value: 'int'
    """
    The current value of this input.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldCounter':
        return cls(
            "counter",
            _from_json_data(AssetAbilityControlFieldID, data.get("id")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(int, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "counter" }
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetAbilityControlFieldID:
    """
    A unique ID for an AssetAbilityControlField.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetAbilityID:
    """
    A unique ID for an AssetAbility.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetAbilityOptionField:
    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityOptionField':
        variants: Dict[str, Type[AssetAbilityOptionField]] = {
            "text": AssetAbilityOptionFieldText,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetAbilityOptionFieldText(AssetAbilityOptionField):
    """
    Represents an input that accepts plain text.
    """

    id: 'AssetAbilityOptionFieldID'
    """
    The unique Datasworn ID for this item.
    """

    label: 'InputLabel'
    value: 'str'
    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityOptionFieldText':
        return cls(
            "text",
            _from_json_data(AssetAbilityOptionFieldID, data.get("id")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(str, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "text" }
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetAbilityOptionFieldID:
    """
    A unique ID for an AssetAbilityOptionField.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityOptionFieldID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetAttachment:
    """
    Describes which assets can be attached to this asset. Example: Starforged's
    Module assets, which can be equipped by Command Vehicle assets. See p. 55 of
    Starforged for more info.
    """

    assets: 'List[AssetIDWildcard]'
    """
    Asset IDs (which may be wildcards) that may be attached to this asset
    """

    max: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAttachment':
        return cls(
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(int, data.get("max")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["assets"] = _to_json_data(self.assets)
        data["max"] = _to_json_data(self.max)
        return data

@dataclass
class AssetConditionMeterControlField:
    """
    A checkbox control field, rendered as part of an asset condition meter.
    """

    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetConditionMeterControlField':
        variants: Dict[str, Type[AssetConditionMeterControlField]] = {
            "card_flip": AssetConditionMeterControlFieldCardFlip,
            "checkbox": AssetConditionMeterControlFieldCheckbox,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetConditionMeterControlFieldCardFlip(AssetConditionMeterControlField):
    """
    When its value is set to `true` it means that the card is flipped over.
    Some assets use this to represent a 'broken' state (e.g. Starforged Module
    assets).
    """

    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    id: 'AssetConditionMeterControlFieldID'
    """
    The unique Datasworn ID for this item.
    """

    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'InputLabel'
    value: 'bool'
    """
    Is the card flipped over?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetConditionMeterControlFieldCardFlip':
        return cls(
            "card_flip",
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(AssetConditionMeterControlFieldID, data.get("id")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "card_flip" }
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["id"] = _to_json_data(self.id)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetConditionMeterControlFieldCheckbox(AssetConditionMeterControlField):
    """
    Represents a checkbox.
    """

    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    id: 'AssetConditionMeterControlFieldID'
    """
    The unique Datasworn ID for this item.
    """

    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'InputLabel'
    value: 'bool'
    """
    Is the box checked?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetConditionMeterControlFieldCheckbox':
        return cls(
            "checkbox",
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(AssetConditionMeterControlFieldID, data.get("id")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "checkbox" }
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["id"] = _to_json_data(self.id)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetConditionMeterControlFieldID:
    """
    A unique ID for an AssetConditionMeterControlField.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetConditionMeterControlFieldID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetControlField:
    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlField':
        variants: Dict[str, Type[AssetControlField]] = {
            "card_flip": AssetControlFieldCardFlip,
            "checkbox": AssetControlFieldCheckbox,
            "condition_meter": AssetControlFieldConditionMeter,
            "select_enhancement": AssetControlFieldSelectEnhancement,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetControlFieldCardFlip(AssetControlField):
    """
    When its value is set to `true` it means that the card is flipped over.
    Some assets use this to represent a 'broken' state (e.g. Starforged Module
    assets).
    """

    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    id: 'AssetControlFieldID'
    """
    The unique Datasworn ID for this item.
    """

    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'InputLabel'
    value: 'bool'
    """
    Is the card flipped over?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldCardFlip':
        return cls(
            "card_flip",
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(AssetControlFieldID, data.get("id")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "card_flip" }
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["id"] = _to_json_data(self.id)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetControlFieldCheckbox(AssetControlField):
    """
    Represents a checkbox.
    """

    disables_asset: 'bool'
    """
    Does this field disable the asset when its value is set to `true`?
    """

    id: 'AssetControlFieldID'
    """
    The unique Datasworn ID for this item.
    """

    is_impact: 'bool'
    """
    Does this field count as an impact (Starforged) or debility (Ironsworn
    classic) when its value is set to `true`?
    """

    label: 'InputLabel'
    value: 'bool'
    """
    Is the box checked?
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldCheckbox':
        return cls(
            "checkbox",
            _from_json_data(bool, data.get("disables_asset")),
            _from_json_data(AssetControlFieldID, data.get("id")),
            _from_json_data(bool, data.get("is_impact")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(bool, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "checkbox" }
        data["disables_asset"] = _to_json_data(self.disables_asset)
        data["id"] = _to_json_data(self.id)
        data["is_impact"] = _to_json_data(self.is_impact)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetControlFieldConditionMeterMoves:
    """
    Provides hints for moves that interact with this condition meter, such as
    suffer and recovery moves.
    """

    recover: 'Optional[List[MoveIDWildcard]]'
    """
    The ID(s) of recovery moves associated with this meter.
    """

    suffer: 'Optional[List[MoveIDWildcard]]'
    """
    The ID(s) of suffer moves associated with the condition meter. If the
    suffer move makes an action roll, this condition meter value should be made
    available as a roll option.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldConditionMeterMoves':
        return cls(
            _from_json_data(Optional[List[MoveIDWildcard]], data.get("recover")),
            _from_json_data(Optional[List[MoveIDWildcard]], data.get("suffer")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.recover is not None:
             data["recover"] = _to_json_data(self.recover)
        if self.suffer is not None:
             data["suffer"] = _to_json_data(self.suffer)
        return data

@dataclass
class AssetControlFieldConditionMeter(AssetControlField):
    """
    Some assets provide a special condition meter of their own. The most common
    example is the health meters on companion assets. Asset condition meters
    may also include their own controls, such as the checkboxes that Starforged
    companion assets use to indicate they are "out of action".
    """

    id: 'AssetControlFieldID'
    """
    The unique Datasworn ID for this item.
    """

    label: 'InputLabel'
    max: 'int'
    """
    The maximum value of this meter.
    """

    min: 'int'
    """
    The minimum value of this meter.
    """

    value: 'int'
    """
    The current value of this meter.
    """

    controls: 'Optional[Dict[str, AssetConditionMeterControlField]]'
    """
    Checkbox controls rendered as part of the condition meter.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """

    moves: 'Optional[AssetControlFieldConditionMeterMoves]'
    """
    Provides hints for moves that interact with this condition meter, such as
    suffer and recovery moves.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldConditionMeter':
        return cls(
            "condition_meter",
            _from_json_data(AssetControlFieldID, data.get("id")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(int, data.get("value")),
            _from_json_data(Optional[Dict[str, AssetConditionMeterControlField]], data.get("controls")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[AssetControlFieldConditionMeterMoves], data.get("moves")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "condition_meter" }
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["value"] = _to_json_data(self.value)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.moves is not None:
             data["moves"] = _to_json_data(self.moves)
        return data

@dataclass
class AssetControlFieldSelectEnhancementChoice:
    choice_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldSelectEnhancementChoice':
        variants: Dict[str, Type[AssetControlFieldSelectEnhancementChoice]] = {
            "choice": AssetControlFieldSelectEnhancementChoiceChoice,
            "choice_group": AssetControlFieldSelectEnhancementChoiceChoiceGroup,
        }

        return variants[data["choice_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetControlFieldSelectEnhancementChoiceChoice(AssetControlFieldSelectEnhancementChoice):
    """
    Represents an option in a list of choices.
    """

    label: 'InputLabel'
    enhance_asset: 'Optional[AssetEnhancement]'
    enhance_moves: 'Optional[List[MoveEnhancement]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldSelectEnhancementChoiceChoice':
        return cls(
            "choice",
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(Optional[AssetEnhancement], data.get("enhance_asset")),
            _from_json_data(Optional[List[MoveEnhancement]], data.get("enhance_moves")),
        )

    def to_json_data(self) -> Any:
        data = { "choice_type": "choice" }
        data["label"] = _to_json_data(self.label)
        if self.enhance_asset is not None:
             data["enhance_asset"] = _to_json_data(self.enhance_asset)
        if self.enhance_moves is not None:
             data["enhance_moves"] = _to_json_data(self.enhance_moves)
        return data

@dataclass
class AssetControlFieldSelectEnhancementChoiceChoiceGroup(AssetControlFieldSelectEnhancementChoice):
    """
    Represents a grouping of options in a list of choices.
    """

    choices: 'Dict[str, SelectEnhancementFieldChoice]'
    name: 'InputLabel'
    """
    A label for this option group.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldSelectEnhancementChoiceChoiceGroup':
        return cls(
            "choice_group",
            _from_json_data(Dict[str, SelectEnhancementFieldChoice], data.get("choices")),
            _from_json_data(InputLabel, data.get("name")),
        )

    def to_json_data(self) -> Any:
        data = { "choice_type": "choice_group" }
        data["choices"] = _to_json_data(self.choices)
        data["name"] = _to_json_data(self.name)
        return data

@dataclass
class AssetControlFieldSelectEnhancement(AssetControlField):
    """
    Select from player and/or asset enhancements. Use it to describe modal
    abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
    (Sundered Isles).
    """

    choices: 'Dict[str, AssetControlFieldSelectEnhancementChoice]'
    id: 'AssetControlFieldID'
    """
    The unique Datasworn ID for this item.
    """

    label: 'InputLabel'
    value: 'DictKey'
    """
    The key of the currently selected choice from the `choices` property, or
    `null` if none is selected.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldSelectEnhancement':
        return cls(
            "select_enhancement",
            _from_json_data(Dict[str, AssetControlFieldSelectEnhancementChoice], data.get("choices")),
            _from_json_data(AssetControlFieldID, data.get("id")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(DictKey, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "select_enhancement" }
        data["choices"] = _to_json_data(self.choices)
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetControlFieldEnhancement:
    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldEnhancement':
        variants: Dict[str, Type[AssetControlFieldEnhancement]] = {
            "condition_meter": AssetControlFieldEnhancementConditionMeter,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetControlFieldEnhancementConditionMeter(AssetControlFieldEnhancement):
    """
    Some assets provide a special condition meter of their own. The most common
    example is the health meters on companion assets. Asset condition meters
    may also include their own controls, such as the checkboxes that Starforged
    companion assets use to indicate they are "out of action".
    """

    max: 'int'
    """
    The maximum value of this meter.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldEnhancementConditionMeter':
        return cls(
            "condition_meter",
            _from_json_data(int, data.get("max")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "condition_meter" }
        data["max"] = _to_json_data(self.max)
        return data

@dataclass
class AssetControlFieldID:
    """
    A unique ID for an AssetControlField.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetControlFieldIDWildcard:
    """
    A wildcarded ID that can be used to match multiple AssetControlFields.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetEnhancement:
    """
    Describes enhancements made to this asset in a partial asset object. The
    changes should be applied recursively; only the values that are specified
    should be changed.
    """

    attachments: 'Optional[AssetAttachment]'
    controls: 'Optional[Dict[str, AssetControlFieldEnhancement]]'
    """
    Controls are condition meters, clocks, counters, and other asset input
    fields whose values are expected to change throughout the life of the asset.
    """

    count_as_impact: 'Optional[bool]'
    """
    If `true`, this asset counts as an impact (Starforged) or a debility
    (classic Ironsworn).
    """

    shared: 'Optional[bool]'
    """
    Most assets only benefit to their owner, but certain assets (like
    Starforged's module and command vehicle assets) are shared amongst the
    player's allies, too.
    """

    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetEnhancement':
        return cls(
            _from_json_data(Optional[AssetAttachment], data.get("attachments")),
            _from_json_data(Optional[Dict[str, AssetControlFieldEnhancement]], data.get("controls")),
            _from_json_data(Optional[bool], data.get("count_as_impact")),
            _from_json_data(Optional[bool], data.get("shared")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.attachments is not None:
             data["attachments"] = _to_json_data(self.attachments)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        if self.count_as_impact is not None:
             data["count_as_impact"] = _to_json_data(self.count_as_impact)
        if self.shared is not None:
             data["shared"] = _to_json_data(self.shared)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class AssetID:
    """
    A unique ID for an Asset.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetIDWildcard:
    """
    A wildcarded ID that can be used to match multiple Assets.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetOptionField:
    """
    Options are asset input fields which are set once, usually when the
    character takes the asset. The most common example is the "name" field on
    companion assets. A more complex example is the choice of a god's stat for
    the Devotant asset.
    """

    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionField':
        variants: Dict[str, Type[AssetOptionField]] = {
            "select_enhancement": AssetOptionFieldSelectEnhancement,
            "select_value": AssetOptionFieldSelectValue,
            "text": AssetOptionFieldText,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetOptionFieldSelectEnhancementChoice:
    choice_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectEnhancementChoice':
        variants: Dict[str, Type[AssetOptionFieldSelectEnhancementChoice]] = {
            "choice": AssetOptionFieldSelectEnhancementChoiceChoice,
            "choice_group": AssetOptionFieldSelectEnhancementChoiceChoiceGroup,
        }

        return variants[data["choice_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetOptionFieldSelectEnhancementChoiceChoice(AssetOptionFieldSelectEnhancementChoice):
    """
    Represents an option in a list of choices.
    """

    label: 'InputLabel'
    enhance_asset: 'Optional[AssetEnhancement]'
    enhance_moves: 'Optional[List[MoveEnhancement]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectEnhancementChoiceChoice':
        return cls(
            "choice",
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(Optional[AssetEnhancement], data.get("enhance_asset")),
            _from_json_data(Optional[List[MoveEnhancement]], data.get("enhance_moves")),
        )

    def to_json_data(self) -> Any:
        data = { "choice_type": "choice" }
        data["label"] = _to_json_data(self.label)
        if self.enhance_asset is not None:
             data["enhance_asset"] = _to_json_data(self.enhance_asset)
        if self.enhance_moves is not None:
             data["enhance_moves"] = _to_json_data(self.enhance_moves)
        return data

@dataclass
class AssetOptionFieldSelectEnhancementChoiceChoiceGroup(AssetOptionFieldSelectEnhancementChoice):
    """
    Represents a grouping of options in a list of choices.
    """

    choices: 'Dict[str, SelectEnhancementFieldChoice]'
    name: 'InputLabel'
    """
    A label for this option group.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectEnhancementChoiceChoiceGroup':
        return cls(
            "choice_group",
            _from_json_data(Dict[str, SelectEnhancementFieldChoice], data.get("choices")),
            _from_json_data(InputLabel, data.get("name")),
        )

    def to_json_data(self) -> Any:
        data = { "choice_type": "choice_group" }
        data["choices"] = _to_json_data(self.choices)
        data["name"] = _to_json_data(self.name)
        return data

@dataclass
class AssetOptionFieldSelectEnhancement(AssetOptionField):
    """
    Select from player and/or asset enhancements. Use it to describe modal
    abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
    (Sundered Isles).
    """

    choices: 'Dict[str, AssetOptionFieldSelectEnhancementChoice]'
    id: 'AssetOptionFieldID'
    """
    The unique Datasworn ID for this item.
    """

    label: 'InputLabel'
    value: 'DictKey'
    """
    The key of the currently selected choice from the `choices` property, or
    `null` if none is selected.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectEnhancement':
        return cls(
            "select_enhancement",
            _from_json_data(Dict[str, AssetOptionFieldSelectEnhancementChoice], data.get("choices")),
            _from_json_data(AssetOptionFieldID, data.get("id")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(DictKey, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "select_enhancement" }
        data["choices"] = _to_json_data(self.choices)
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetOptionFieldSelectValue(AssetOptionField):
    """
    Represents a list of mutually exclusive choices.
    """

    choices: 'Dict[str, SelectValueFieldChoice]'
    id: 'AssetOptionFieldID'
    """
    The unique Datasworn ID for this item.
    """

    label: 'InputLabel'
    value: 'DictKey'
    """
    The key of the currently selected choice from the `choices` property, or
    `null` if none is selected.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectValue':
        return cls(
            "select_value",
            _from_json_data(Dict[str, SelectValueFieldChoice], data.get("choices")),
            _from_json_data(AssetOptionFieldID, data.get("id")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(DictKey, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "select_value" }
        data["choices"] = _to_json_data(self.choices)
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetOptionFieldText(AssetOptionField):
    """
    Represents an input that accepts plain text.
    """

    id: 'AssetOptionFieldID'
    """
    The unique Datasworn ID for this item.
    """

    label: 'InputLabel'
    value: 'str'
    icon: 'Optional[SvgImageURL]'
    """
    An icon associated with this input.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldText':
        return cls(
            "text",
            _from_json_data(AssetOptionFieldID, data.get("id")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(str, data.get("value")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "text" }
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        return data

@dataclass
class AssetOptionFieldID:
    """
    A unique ID for an AssetOptionField.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetOptionFieldIDWildcard:
    """
    A wildcarded ID that can be used to match multiple AssetOptionFields.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetType:
    id: 'AssetTypeID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this collection.
    """

    contents: 'Optional[Dict[str, Asset]]'
    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[AssetTypeID]'
    """
    This collection's content enhances the identified collection, rather than
    being a standalone collection of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[AssetTypeID]'
    """
    This collection replaces the identified collection. References to the
    replaced collection can be considered equivalent to this collection.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetType':
        return cls(
            _from_json_data(AssetTypeID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, Asset]], data.get("contents")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[AssetTypeID], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[AssetTypeID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.contents is not None:
             data["contents"] = _to_json_data(self.contents)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        return data

@dataclass
class AssetTypeID:
    """
    A unique ID for an AssetType.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetTypeID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Atlas:
    id: 'AtlasID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    collections: 'Optional[Dict[str, Atlas]]'
    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this collection.
    """

    contents: 'Optional[Dict[str, AtlasEntry]]'
    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[AtlasID]'
    """
    This collection's content enhances the identified collection, rather than
    being a standalone collection of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[AtlasID]'
    """
    This collection replaces the identified collection. References to the
    replaced collection can be considered equivalent to this collection.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'Atlas':
        return cls(
            _from_json_data(AtlasID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[Dict[str, Atlas]], data.get("collections")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, AtlasEntry]], data.get("contents")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[AtlasID], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[AtlasID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.collections is not None:
             data["collections"] = _to_json_data(self.collections)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.contents is not None:
             data["contents"] = _to_json_data(self.contents)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        return data

@dataclass
class AtlasEntry:
    """
    An atlas entry, like the Ironlands region entries found in classic
    Ironsworn.
    """

    description: 'MarkdownString'
    features: 'List[MarkdownString]'
    id: 'AtlasEntryID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    quest_starter: 'MarkdownString'
    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    your_truth: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasEntry':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(List[MarkdownString], data.get("features")),
            _from_json_data(AtlasEntryID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MarkdownString, data.get("quest_starter")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[MarkdownString], data.get("your_truth")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["features"] = _to_json_data(self.features)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["quest_starter"] = _to_json_data(self.quest_starter)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.your_truth is not None:
             data["your_truth"] = _to_json_data(self.your_truth)
        return data

@dataclass
class AtlasEntryID:
    """
    A unique ID for an AtlasEntry.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasEntryID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AtlasEntryIDWildcard:
    """
    A wildcarded ID that can be used to match multiple AtlasEntrys.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasEntryIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AtlasID:
    """
    A unique ID for an Atlas.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AtlasIDWildcard:
    """
    A wildcarded ID that can be used to match multiple Atlass.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AtlasIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AuthorInfo:
    """
    Information on the original creator of this material.
    """

    name: 'str'
    email: 'Optional[str]'
    """
    An optional email contact for the author
    """

    url: 'Optional[str]'
    """
    An optional URL for the author's website.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AuthorInfo':
        return cls(
            _from_json_data(str, data.get("name")),
            _from_json_data(Optional[str], data.get("email")),
            _from_json_data(Optional[str], data.get("url")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["name"] = _to_json_data(self.name)
        if self.email is not None:
             data["email"] = _to_json_data(self.email)
        if self.url is not None:
             data["url"] = _to_json_data(self.url)
        return data

@dataclass
class ChallengeRank:
    """
    Challenge rank, represented as an integer from 1 (troublesome) to 5 (epic).
    """

    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ChallengeRank':
        return cls(_from_json_data(int, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class ConditionMeterKey:
    """
    A basic, rollable player character resource specified by the ruleset.
    """

    value: 'DictKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionMeterKey':
        return cls(_from_json_data(DictKey, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class ConditionMeterRule:
    """
    Describes a standard player character condition meter.
    """

    description: 'MarkdownString'
    """
    A description of this condition meter.
    """

    label: 'InputLabel'
    max: 'int'
    """
    The maximum value of this meter.
    """

    min: 'int'
    """
    The minimum value of this meter.
    """

    shared: 'bool'
    """
    Is this condition meter shared by all players?
    """

    value: 'int'
    """
    The current value of this meter.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionMeterRule':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(bool, data.get("shared")),
            _from_json_data(int, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["shared"] = _to_json_data(self.shared)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class ConditionMeterRuleID:
    """
    A unique ID for a ConditionMeterRule.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ConditionMeterRuleID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class CSSColor:
    """
    A CSS color value.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'CSSColor':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSite:
    """
    A delve site with a theme, domain, and denizens.
    """

    denizens: 'List[DelveSiteDenizen]'
    description: 'MarkdownString'
    domain: 'DelveSiteDomainID'
    id: 'DelveSiteID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    rank: 'ChallengeRank'
    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    theme: 'DelveSiteThemeID'
    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    extra_card: 'Optional[str]'
    """
    An additional theme or domain card ID, for use with optional rules in
    Ironsworn: Delve.
    """

    icon: 'Optional[SvgImageURL]'
    region: 'Optional[AtlasEntryID]'
    """
    The ID of an atlas entry representing the region in which this delve site
    is located.
    """

    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSite':
        return cls(
            _from_json_data(List[DelveSiteDenizen], data.get("denizens")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(DelveSiteDomainID, data.get("domain")),
            _from_json_data(DelveSiteID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(ChallengeRank, data.get("rank")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(DelveSiteThemeID, data.get("theme")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[str], data.get("extra_card")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[AtlasEntryID], data.get("region")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["denizens"] = _to_json_data(self.denizens)
        data["description"] = _to_json_data(self.description)
        data["domain"] = _to_json_data(self.domain)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["rank"] = _to_json_data(self.rank)
        data["source"] = _to_json_data(self.source)
        data["theme"] = _to_json_data(self.theme)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.extra_card is not None:
             data["extra_card"] = _to_json_data(self.extra_card)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.region is not None:
             data["region"] = _to_json_data(self.region)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class DelveSiteDenizen:
    frequency: 'DelveSiteDenizenFrequency'
    id: 'DelveSiteDenizenID'
    """
    The unique Datasworn ID for this item.
    """

    max: 'int'
    min: 'int'
    name: 'Optional[Label]'
    npc: 'Optional[NpcID]'
    """
    The ID of the relevant NPC entry, if one is specified.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDenizen':
        return cls(
            _from_json_data(DelveSiteDenizenFrequency, data.get("frequency")),
            _from_json_data(DelveSiteDenizenID, data.get("id")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(Optional[Label], data.get("name")),
            _from_json_data(Optional[NpcID], data.get("npc")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["frequency"] = _to_json_data(self.frequency)
        data["id"] = _to_json_data(self.id)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        if self.name is not None:
             data["name"] = _to_json_data(self.name)
        if self.npc is not None:
             data["npc"] = _to_json_data(self.npc)
        return data

class DelveSiteDenizenFrequency(Enum):
    COMMON = "common"
    RARE = "rare"
    UNCOMMON = "uncommon"
    UNFORESEEN = "unforeseen"
    VERY_COMMON = "very_common"
    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDenizenFrequency':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class DelveSiteDenizenID:
    """
    A unique ID for a DelveSiteDenizen.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDenizenID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteDomain:
    """
    A delve site Domain card.
    """

    dangers: 'List[DelveSiteDomainDangerRow]'
    features: 'List[DelveSiteDomainFeatureRow]'
    id: 'DelveSiteDomainID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    summary: 'MarkdownString'
    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    description: 'Optional[MarkdownString]'
    icon: 'Optional[SvgImageURL]'
    name_oracle: 'Optional[OracleTableID]'
    """
    An oracle table ID containing place name elements. For examples, see
    oracle ID `delve/oracles/site_name/place/barrow`, and its siblings in
    oracle collection ID `delve/collections/oracles/site_name/place`. These
    oracles are used by the site name oracle from Ironsworn: Delve (ID:
    delve/oracles/site_name/format) to create random names for delve sites.
    """

    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomain':
        return cls(
            _from_json_data(List[DelveSiteDomainDangerRow], data.get("dangers")),
            _from_json_data(List[DelveSiteDomainFeatureRow], data.get("features")),
            _from_json_data(DelveSiteDomainID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(MarkdownString, data.get("summary")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[OracleTableID], data.get("name_oracle")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["dangers"] = _to_json_data(self.dangers)
        data["features"] = _to_json_data(self.features)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        data["summary"] = _to_json_data(self.summary)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.name_oracle is not None:
             data["name_oracle"] = _to_json_data(self.name_oracle)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class DelveSiteDomainDangerRow:
    """
    Represents a single Danger entry from a delve site Domain card.
    """

    id: 'DomainDangerRowID'
    """
    The unique Datasworn ID for this item.
    """

    max: 'int'
    """
    High end of the dice range for this table row.
    """

    min: 'int'
    """
    Low end of the dice range for this table row.
    """

    result: 'MarkdownString'
    """
    The primary text content of this row.
    """

    description: 'Optional[MarkdownString]'
    """
    Optional tertiary text content for this row. Generally, this is longer than
    both `result` and `summary`.
    """

    embed_table: 'Optional[OracleTableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    i18n: 'Optional[I18nHints]'
    icon: 'Optional[SvgImageURL]'
    rolls: 'Optional[List[OracleTableRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    Optional secondary text content for this row. Generally, this is longer
    than `result`.
    """

    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainDangerRow':
        return cls(
            _from_json_data(DomainDangerRowID, data.get("id")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(MarkdownString, data.get("result")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[OracleTableID], data.get("embed_table")),
            _from_json_data(Optional[I18nHints], data.get("i18n")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleTableRoll]], data.get("rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["result"] = _to_json_data(self.result)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.i18n is not None:
             data["i18n"] = _to_json_data(self.i18n)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.rolls is not None:
             data["rolls"] = _to_json_data(self.rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class DelveSiteDomainFeatureRow:
    """
    Represents a single Feature entry from a delve site Domain card.
    """

    id: 'DomainFeatureRowID'
    """
    The unique Datasworn ID for this item.
    """

    max: 'int'
    """
    High end of the dice range for this table row.
    """

    min: 'int'
    """
    Low end of the dice range for this table row.
    """

    result: 'MarkdownString'
    """
    The primary text content of this row.
    """

    description: 'Optional[MarkdownString]'
    """
    Optional tertiary text content for this row. Generally, this is longer than
    both `result` and `summary`.
    """

    embed_table: 'Optional[OracleTableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    i18n: 'Optional[I18nHints]'
    icon: 'Optional[SvgImageURL]'
    rolls: 'Optional[List[OracleTableRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    Optional secondary text content for this row. Generally, this is longer
    than `result`.
    """

    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainFeatureRow':
        return cls(
            _from_json_data(DomainFeatureRowID, data.get("id")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(MarkdownString, data.get("result")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[OracleTableID], data.get("embed_table")),
            _from_json_data(Optional[I18nHints], data.get("i18n")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleTableRoll]], data.get("rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["result"] = _to_json_data(self.result)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.i18n is not None:
             data["i18n"] = _to_json_data(self.i18n)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.rolls is not None:
             data["rolls"] = _to_json_data(self.rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class DelveSiteDomainID:
    """
    A unique ID for a DelveSiteDomain.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteID:
    """
    A unique ID for a DelveSite.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DelveSiteTheme:
    """
    A delve site theme card.
    """

    dangers: 'List[DelveSiteThemeDangerRow]'
    features: 'List[DelveSiteThemeFeatureRow]'
    id: 'DelveSiteThemeID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    summary: 'MarkdownString'
    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    description: 'Optional[MarkdownString]'
    icon: 'Optional[SvgImageURL]'
    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteTheme':
        return cls(
            _from_json_data(List[DelveSiteThemeDangerRow], data.get("dangers")),
            _from_json_data(List[DelveSiteThemeFeatureRow], data.get("features")),
            _from_json_data(DelveSiteThemeID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(MarkdownString, data.get("summary")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["dangers"] = _to_json_data(self.dangers)
        data["features"] = _to_json_data(self.features)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        data["summary"] = _to_json_data(self.summary)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class DelveSiteThemeDangerRow:
    """
    Represents a single Danger entry from a delve site Theme card.
    """

    id: 'ThemeDangerRowID'
    """
    The unique Datasworn ID for this item.
    """

    max: 'int'
    """
    High end of the dice range for this table row.
    """

    min: 'int'
    """
    Low end of the dice range for this table row.
    """

    result: 'MarkdownString'
    """
    The primary text content of this row.
    """

    description: 'Optional[MarkdownString]'
    """
    Optional tertiary text content for this row. Generally, this is longer than
    both `result` and `summary`.
    """

    embed_table: 'Optional[OracleTableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    i18n: 'Optional[I18nHints]'
    icon: 'Optional[SvgImageURL]'
    rolls: 'Optional[List[OracleTableRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    Optional secondary text content for this row. Generally, this is longer
    than `result`.
    """

    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeDangerRow':
        return cls(
            _from_json_data(ThemeDangerRowID, data.get("id")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(MarkdownString, data.get("result")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[OracleTableID], data.get("embed_table")),
            _from_json_data(Optional[I18nHints], data.get("i18n")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleTableRoll]], data.get("rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["result"] = _to_json_data(self.result)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.i18n is not None:
             data["i18n"] = _to_json_data(self.i18n)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.rolls is not None:
             data["rolls"] = _to_json_data(self.rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class DelveSiteThemeFeatureRow:
    """
    Represents a single Feature entry from a delve site Theme card.
    """

    id: 'ThemeFeatureRowID'
    """
    The unique Datasworn ID for this item.
    """

    max: 'int'
    """
    High end of the dice range for this table row.
    """

    min: 'int'
    """
    Low end of the dice range for this table row.
    """

    result: 'MarkdownString'
    """
    The primary text content of this row.
    """

    description: 'Optional[MarkdownString]'
    """
    Optional tertiary text content for this row. Generally, this is longer than
    both `result` and `summary`.
    """

    embed_table: 'Optional[OracleTableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    i18n: 'Optional[I18nHints]'
    icon: 'Optional[SvgImageURL]'
    rolls: 'Optional[List[OracleTableRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    Optional secondary text content for this row. Generally, this is longer
    than `result`.
    """

    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeFeatureRow':
        return cls(
            _from_json_data(ThemeFeatureRowID, data.get("id")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(MarkdownString, data.get("result")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[OracleTableID], data.get("embed_table")),
            _from_json_data(Optional[I18nHints], data.get("i18n")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleTableRoll]], data.get("rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["result"] = _to_json_data(self.result)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.i18n is not None:
             data["i18n"] = _to_json_data(self.i18n)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.rolls is not None:
             data["rolls"] = _to_json_data(self.rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class DelveSiteThemeID:
    """
    A unique ID for a DelveSiteTheme.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DiceExpression:
    """
    A simple dice roll expression with an optional modifer.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DiceExpression':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DictKey:
    """
    A `snake_case` key used in a Datasworn dictionary object.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DictKey':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DomainDangerRowID:
    """
    A unique ID for a DomainDangerRow.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DomainDangerRowID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class DomainFeatureRowID:
    """
    A unique ID for a DomainFeatureRow.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DomainFeatureRowID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class ExpansionID:
    """
    The ID of a Datasworn package that relies on an external package to provide
    its ruleset.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ExpansionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class I18nHint:
    part_of_speech: 'Optional[PartOfSpeech]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'I18nHint':
        return cls(
            _from_json_data(Optional[PartOfSpeech], data.get("part_of_speech")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.part_of_speech is not None:
             data["part_of_speech"] = _to_json_data(self.part_of_speech)
        return data

@dataclass
class I18nHintsTemplate:
    description: 'Optional[I18nHint]'
    result: 'Optional[I18nHint]'
    summary: 'Optional[I18nHint]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'I18nHintsTemplate':
        return cls(
            _from_json_data(Optional[I18nHint], data.get("description")),
            _from_json_data(Optional[I18nHint], data.get("result")),
            _from_json_data(Optional[I18nHint], data.get("summary")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.result is not None:
             data["result"] = _to_json_data(self.result)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        return data

@dataclass
class I18nHints:
    """
    Internationalization/localization hints for the text content of this object.
    """

    description: 'Optional[I18nHint]'
    result: 'Optional[I18nHint]'
    summary: 'Optional[I18nHint]'
    template: 'Optional[I18nHintsTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'I18nHints':
        return cls(
            _from_json_data(Optional[I18nHint], data.get("description")),
            _from_json_data(Optional[I18nHint], data.get("result")),
            _from_json_data(Optional[I18nHint], data.get("summary")),
            _from_json_data(Optional[I18nHintsTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.result is not None:
             data["result"] = _to_json_data(self.result)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class ImpactCategory:
    """
    Describes a category of standard impacts/debilities.
    """

    contents: 'Dict[str, ImpactRule]'
    """
    A dictionary object of the Impacts in this category.
    """

    description: 'MarkdownString'
    """
    A description of this impact category.
    """

    label: 'InputLabel'
    """
    A label for this impact category.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'ImpactCategory':
        return cls(
            _from_json_data(Dict[str, ImpactRule], data.get("contents")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(InputLabel, data.get("label")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["contents"] = _to_json_data(self.contents)
        data["description"] = _to_json_data(self.description)
        data["label"] = _to_json_data(self.label)
        return data

@dataclass
class ImpactRule:
    """
    Describes a standard impact/debility.
    """

    description: 'MarkdownString'
    """
    A description of this impact.
    """

    label: 'InputLabel'
    """
    The label for this impact.
    """

    permanent: 'bool'
    """
    Is this impact permanent?
    """

    prevents_recovery: 'List[ConditionMeterKey]'
    """
    Any ruleset condition meters that can't recover when this impact is active.
    """

    shared: 'bool'
    """
    Is this impact applied to all players at once?
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'ImpactRule':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(bool, data.get("permanent")),
            _from_json_data(List[ConditionMeterKey], data.get("prevents_recovery")),
            _from_json_data(bool, data.get("shared")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["label"] = _to_json_data(self.label)
        data["permanent"] = _to_json_data(self.permanent)
        data["prevents_recovery"] = _to_json_data(self.prevents_recovery)
        data["shared"] = _to_json_data(self.shared)
        return data

@dataclass
class ImpactRuleCollectionID:
    """
    A unique ID for an ImpactRuleCollection.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ImpactRuleCollectionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class ImpactRuleID:
    """
    A unique ID for an ImpactRule.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ImpactRuleID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class InputLabel:
    """
    A localized label for an input. In some contexts it may be undesirable to
    render this text, but it should always be exposed to assistive technology
    (e.g. with `aria-label` in HTML).
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'InputLabel':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Label:
    """
    A localized plain text name or label.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Label':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MarkdownString:
    """
    Localized text, formatted in Markdown.
    
    It uses some custom syntax; e.g. `{{table:some_oracle_table_id}}` indicates
    that the referenced oracle table is rendered there part of the source
    material.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MarkdownString':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Move:
    roll_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Move':
        variants: Dict[str, Type[Move]] = {
            "action_roll": MoveActionRoll,
            "no_roll": MoveNoRoll,
            "progress_roll": MoveProgressRoll,
            "special_track": MoveSpecialTrack,
        }

        return variants[data["roll_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class MoveActionRoll(Move):
    """
    A move that makes an action roll.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    outcomes: 'MoveOutcomes'
    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerActionRoll'
    """
    Trigger conditions for this move.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    oracles: 'Optional[List[OracleTableID]]'
    """
    Oracles associated with this move. It's not recommended to roll these
    automatically, as almost all moves present them as an option, not a
    requirement.
    """

    replaces: 'Optional[MoveID]'
    """
    Indicates that this move replaces the identified move. References to the
    replaced move can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveActionRoll':
        return cls(
            "action_roll",
            _from_json_data(MoveID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerActionRoll, data.get("trigger")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[List[OracleTableID]], data.get("oracles")),
            _from_json_data(Optional[MoveID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "action_roll" }
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["source"] = _to_json_data(self.source)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class MoveNoRoll(Move):
    """
    A move that makes no progress rolls or action rolls.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerNoRoll'
    """
    Trigger conditions for this move.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    oracles: 'Optional[List[OracleTableID]]'
    """
    Oracles associated with this move. It's not recommended to roll these
    automatically, as almost all moves present them as an option, not a
    requirement.
    """

    replaces: 'Optional[MoveID]'
    """
    Indicates that this move replaces the identified move. References to the
    replaced move can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveNoRoll':
        return cls(
            "no_roll",
            _from_json_data(MoveID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerNoRoll, data.get("trigger")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[List[OracleTableID]], data.get("oracles")),
            _from_json_data(Optional[MoveID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "no_roll" }
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class MoveProgressRoll(Move):
    """
    A progress move that rolls on a standard progress track type (whose features
    are defined by this move object). For progress rolls that use special
    tracks, see MoveSpecialTrack.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    outcomes: 'MoveOutcomes'
    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    tracks: 'ProgressTrackTypeInfo'
    """
    Describes the common features of progress tracks associated with this move.
    """

    trigger: 'TriggerProgressRoll'
    """
    Trigger conditions for this move.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    oracles: 'Optional[List[OracleTableID]]'
    """
    Oracles associated with this move. It's not recommended to roll these
    automatically, as almost all moves present them as an option, not a
    requirement.
    """

    replaces: 'Optional[MoveID]'
    """
    Indicates that this move replaces the identified move. References to the
    replaced move can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveProgressRoll':
        return cls(
            "progress_roll",
            _from_json_data(MoveID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(ProgressTrackTypeInfo, data.get("tracks")),
            _from_json_data(TriggerProgressRoll, data.get("trigger")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[List[OracleTableID]], data.get("oracles")),
            _from_json_data(Optional[MoveID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "progress_roll" }
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["source"] = _to_json_data(self.source)
        data["text"] = _to_json_data(self.text)
        data["tracks"] = _to_json_data(self.tracks)
        data["trigger"] = _to_json_data(self.trigger)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class MoveSpecialTrack(Move):
    """
    A progress move that rolls on a special track, such as Legacies (Starforged)
    or Bonds (classic Ironsworn). For progress moves that use standard progress
    tracks, see MoveProgressRoll instead.
    """

    id: 'MoveID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    outcomes: 'MoveOutcomes'
    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    text: 'MarkdownString'
    """
    The complete rules text of the move.
    """

    trigger: 'TriggerSpecialTrack'
    """
    Trigger conditions for this move.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    oracles: 'Optional[List[OracleTableID]]'
    """
    Oracles associated with this move. It's not recommended to roll these
    automatically, as almost all moves present them as an option, not a
    requirement.
    """

    replaces: 'Optional[MoveID]'
    """
    Indicates that this move replaces the identified move. References to the
    replaced move can be considered equivalent to this move.
    """

    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveSpecialTrack':
        return cls(
            "special_track",
            _from_json_data(MoveID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(TriggerSpecialTrack, data.get("trigger")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[List[OracleTableID]], data.get("oracles")),
            _from_json_data(Optional[MoveID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "special_track" }
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["source"] = _to_json_data(self.source)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class MoveCategory:
    id: 'MoveCategoryID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this collection.
    """

    contents: 'Optional[Dict[str, Move]]'
    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[MoveCategoryID]'
    """
    This collection's content enhances the identified collection, rather than
    being a standalone collection of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[MoveCategoryID]'
    """
    This collection replaces the identified collection. References to the
    replaced collection can be considered equivalent to this collection.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveCategory':
        return cls(
            _from_json_data(MoveCategoryID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, Move]], data.get("contents")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[MoveCategoryID], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[MoveCategoryID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.contents is not None:
             data["contents"] = _to_json_data(self.contents)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        return data

@dataclass
class MoveCategoryID:
    """
    A unique ID for a MoveCategory.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveCategoryID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MoveEnhancement:
    roll_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveEnhancement':
        variants: Dict[str, Type[MoveEnhancement]] = {
            "action_roll": MoveEnhancementActionRoll,
            "no_roll": MoveEnhancementNoRoll,
            "progress_roll": MoveEnhancementProgressRoll,
            "special_track": MoveEnhancementSpecialTrack,
        }

        return variants[data["roll_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class MoveEnhancementActionRoll(MoveEnhancement):
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[MoveIDWildcard]'
    trigger: 'Optional[TriggerActionRollEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveEnhancementActionRoll':
        return cls(
            "action_roll",
            _from_json_data(List[MoveIDWildcard], data.get("enhances")),
            _from_json_data(Optional[TriggerActionRollEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "action_roll" }
        data["enhances"] = _to_json_data(self.enhances)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

@dataclass
class MoveEnhancementNoRoll(MoveEnhancement):
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[MoveIDWildcard]'
    trigger: 'Optional[TriggerNoRollEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveEnhancementNoRoll':
        return cls(
            "no_roll",
            _from_json_data(List[MoveIDWildcard], data.get("enhances")),
            _from_json_data(Optional[TriggerNoRollEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "no_roll" }
        data["enhances"] = _to_json_data(self.enhances)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

@dataclass
class MoveEnhancementProgressRoll(MoveEnhancement):
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[MoveIDWildcard]'
    trigger: 'Optional[TriggerProgressRollEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveEnhancementProgressRoll':
        return cls(
            "progress_roll",
            _from_json_data(List[MoveIDWildcard], data.get("enhances")),
            _from_json_data(Optional[TriggerProgressRollEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "progress_roll" }
        data["enhances"] = _to_json_data(self.enhances)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

@dataclass
class MoveEnhancementSpecialTrack(MoveEnhancement):
    """
    An object that describes changes to a move. These changes should be applied
    recursively, altering only the specified properties; enhanced arrays should
    be concatencated with the original array value.
    """

    enhances: 'List[MoveIDWildcard]'
    trigger: 'Optional[TriggerSpecialTrackEnhancement]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveEnhancementSpecialTrack':
        return cls(
            "special_track",
            _from_json_data(List[MoveIDWildcard], data.get("enhances")),
            _from_json_data(Optional[TriggerSpecialTrackEnhancement], data.get("trigger")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "special_track" }
        data["enhances"] = _to_json_data(self.enhances)
        if self.trigger is not None:
             data["trigger"] = _to_json_data(self.trigger)
        return data

@dataclass
class MoveID:
    """
    A move ID, for a standard move or a unique asset move
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MoveIDWildcard:
    """
    A move ID with wildcards.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MoveOutcome:
    text: 'MarkdownString'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOutcome':
        return cls(
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class MoveOutcomes:
    """
    A standalone localized description for each move outcome (miss, weak hit,
    or strong hit). This is for for e.g. VTT implementations, where it's often
    useful to display only the rules text relevant to a roll result.
    
      This often requires light editorialization to create text that can stand
    alone without reference to the rest of the move. For example, 'as above'
    (in reference to another move outcome) shouldn't be used here; instead, the
    relevant text should be repeated.
    """

    miss: 'MoveOutcome'
    strong_hit: 'MoveOutcome'
    weak_hit: 'MoveOutcome'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOutcomes':
        return cls(
            _from_json_data(MoveOutcome, data.get("miss")),
            _from_json_data(MoveOutcome, data.get("strong_hit")),
            _from_json_data(MoveOutcome, data.get("weak_hit")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["miss"] = _to_json_data(self.miss)
        data["strong_hit"] = _to_json_data(self.strong_hit)
        data["weak_hit"] = _to_json_data(self.weak_hit)
        return data

class MoveRollType(Enum):
    ACTION_ROLL = "action_roll"
    """
    A move that makes an action roll.
    """

    NO_ROLL = "no_roll"
    """
    A move that makes no action rolls or progress rolls.
    """

    PROGRESS_ROLL = "progress_roll"
    """
    A progress move that rolls on a standard progress track type (defined by
    this move).
    """

    SPECIAL_TRACK = "special_track"
    """
    A progress move that rolls on one or more special tracks, like Bonds
    (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveRollType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Npc:
    """
    A non-player character entry, similar to those in Chapter 5 of the Ironsworn
    Rulebook, or Chapter 4 of Starforged.
    """

    description: 'MarkdownString'
    drives: 'List[MarkdownString]'
    features: 'List[MarkdownString]'
    id: 'NpcID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    nature: 'NpcNature'
    quest_starter: 'MarkdownString'
    rank: 'ChallengeRank'
    """
    The suggested challenge rank for this NPC.
    """

    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    tactics: 'List[MarkdownString]'
    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    variants: 'Optional[Dict[str, NpcVariant]]'
    your_truth: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Npc':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(List[MarkdownString], data.get("drives")),
            _from_json_data(List[MarkdownString], data.get("features")),
            _from_json_data(NpcID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(NpcNature, data.get("nature")),
            _from_json_data(MarkdownString, data.get("quest_starter")),
            _from_json_data(ChallengeRank, data.get("rank")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(List[MarkdownString], data.get("tactics")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[Dict[str, NpcVariant]], data.get("variants")),
            _from_json_data(Optional[MarkdownString], data.get("your_truth")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["drives"] = _to_json_data(self.drives)
        data["features"] = _to_json_data(self.features)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["nature"] = _to_json_data(self.nature)
        data["quest_starter"] = _to_json_data(self.quest_starter)
        data["rank"] = _to_json_data(self.rank)
        data["source"] = _to_json_data(self.source)
        data["tactics"] = _to_json_data(self.tactics)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.variants is not None:
             data["variants"] = _to_json_data(self.variants)
        if self.your_truth is not None:
             data["your_truth"] = _to_json_data(self.your_truth)
        return data

@dataclass
class NpcCollection:
    id: 'NpcCollectionID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this collection.
    """

    contents: 'Optional[Dict[str, Npc]]'
    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[NpcCollectionID]'
    """
    This collection's content enhances the identified collection, rather than
    being a standalone collection of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    replaces: 'Optional[NpcCollectionID]'
    """
    This collection replaces the identified collection. References to the
    replaced collection can be considered equivalent to this collection.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcCollection':
        return cls(
            _from_json_data(NpcCollectionID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, Npc]], data.get("contents")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[NpcCollectionID], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[NpcCollectionID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.contents is not None:
             data["contents"] = _to_json_data(self.contents)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        return data

@dataclass
class NpcCollectionID:
    """
    A unique ID for a NpcCollection.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcCollectionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class NpcID:
    """
    A unique ID for a Npc.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class NpcIDWildcard:
    """
    A wildcarded ID that can be used to match multiple Npcs.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class NpcNature:
    """
    A localized category label describing the nature of this NPC.
    
    In Ironsworn classic, this is probably the singular form of the parent
    collection's name.
    
    For Starforged, see the table on p. 258 for examples.
    """

    value: 'Label'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcNature':
        return cls(_from_json_data(Label, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class NpcVariant:
    description: 'MarkdownString'
    id: 'NpcVariantID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    nature: 'NpcNature'
    rank: 'ChallengeRank'
    """
    The suggested challenge rank for this NPC.
    """

    summary: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcVariant':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(NpcVariantID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(NpcNature, data.get("nature")),
            _from_json_data(ChallengeRank, data.get("rank")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["nature"] = _to_json_data(self.nature)
        data["rank"] = _to_json_data(self.rank)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        return data

@dataclass
class NpcVariantID:
    """
    A unique ID for a NpcVariant.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'NpcVariantID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class OracleCollection:
    id: 'OracleCollectionID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    collections: 'Optional[Dict[str, OracleCollection]]'
    color: 'Optional[CSSColor]'
    """
    A thematic color associated with this collection.
    """

    contents: 'Optional[Dict[str, OracleTable]]'
    description: 'Optional[MarkdownString]'
    """
    A longer description of this collection, which might include multiple
    paragraphs. If it's only a couple sentences, use the `summary` key instead.
    """

    enhances: 'Optional[OracleCollectionID]'
    """
    This collection's content enhances the identified collection, rather than
    being a standalone collection of its own.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An SVG icon associated with this collection.
    """

    images: 'Optional[List[WebpImageURL]]'
    rendering: 'Optional[OracleCollectionRendering]'
    replaces: 'Optional[OracleCollectionID]'
    """
    This collection replaces the identified collection. References to the
    replaced collection can be considered equivalent to this collection.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of this collection, no more than a few sentences in length.
    This is intended for use in application tooltips and similar sorts of hints.
    Longer text should use the "description" key instead.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollection':
        return cls(
            _from_json_data(OracleCollectionID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[Dict[str, OracleCollection]], data.get("collections")),
            _from_json_data(Optional[CSSColor], data.get("color")),
            _from_json_data(Optional[Dict[str, OracleTable]], data.get("contents")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[OracleCollectionID], data.get("enhances")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleCollectionRendering], data.get("rendering")),
            _from_json_data(Optional[OracleCollectionID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.collections is not None:
             data["collections"] = _to_json_data(self.collections)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.contents is not None:
             data["contents"] = _to_json_data(self.contents)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.enhances is not None:
             data["enhances"] = _to_json_data(self.enhances)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.rendering is not None:
             data["rendering"] = _to_json_data(self.rendering)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        return data

@dataclass
class OracleCollectionID:
    """
    A unique ID for an OracleCollection.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class OracleCollectionRendering:
    """
    Describes the presentation of this oracle collection, which might represent
    a group of separate tables, or a single table with additional columns.
    """

    style: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionRendering':
        variants: Dict[str, Type[OracleCollectionRendering]] = {
            "multi_table": OracleCollectionRenderingMultiTable,
            "tables": OracleCollectionRenderingTables,
        }

        return variants[data["style"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class OracleCollectionRenderingMultiTable(OracleCollectionRendering):
    columns: 'Dict[str, OracleCollectionTableColumn]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionRenderingMultiTable':
        return cls(
            "multi_table",
            _from_json_data(Dict[str, OracleCollectionTableColumn], data.get("columns")),
        )

    def to_json_data(self) -> Any:
        data = { "style": "multi_table" }
        data["columns"] = _to_json_data(self.columns)
        return data

@dataclass
class OracleCollectionRenderingTables(OracleCollectionRendering):

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionRenderingTables':
        return cls(
            "tables",
        )

    def to_json_data(self) -> Any:
        data = { "style": "tables" }
        return data

@dataclass
class OracleCollectionTableColumn:
    content_type: 'OracleTableColumnContentKey'
    label: 'Label'
    """
    The column's header text.
    """

    table_key: 'DictKey'
    """
    The key of the OracleTable (within this collection), whose data is used to
    render this column.
    """

    color: 'Optional[CSSColor]'
    """
    The thematic color for this column.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionTableColumn':
        return cls(
            _from_json_data(OracleTableColumnContentKey, data.get("content_type")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(DictKey, data.get("table_key")),
            _from_json_data(Optional[CSSColor], data.get("color")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["content_type"] = _to_json_data(self.content_type)
        data["label"] = _to_json_data(self.label)
        data["table_key"] = _to_json_data(self.table_key)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        return data

@dataclass
class OracleRollTemplate:
    """
    Provides string templates that may be used in place of the static
    row text from `OracleTableRow#result`, `OracleTableRow#summary`, and
    `OracleTableRow#description`.
    
      These strings are formatted in Markdown, but use a special syntax
    for their placeholders: `{{result:some_oracle_table_id}}`. The
    placeholder should be replaced with the value of a rolled (or selected)
    `OracleTableRow#result` from the target oracle table ID.
    """

    description: 'Optional[TemplateString]'
    """
    A string template that may be used in place of OracleTableRow#description.
    """

    result: 'Optional[TemplateString]'
    """
    A string template that may be used in place of OracleTableRow#result.
    """

    summary: 'Optional[TemplateString]'
    """
    A string template that may be used in place of OracleTableRow#summary.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollTemplate':
        return cls(
            _from_json_data(Optional[TemplateString], data.get("description")),
            _from_json_data(Optional[TemplateString], data.get("result")),
            _from_json_data(Optional[TemplateString], data.get("summary")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.result is not None:
             data["result"] = _to_json_data(self.result)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        return data

@dataclass
class OracleTable:
    """
    Represents a single oracle table, or a single table column of a table that
    has multiple "Roll" or "Result" columns.
    """

    dice: 'DiceExpression'
    """
    The roll used to select a result on this table.
    """

    id: 'OracleTableID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    table: 'List[OracleTableRow]'
    i18n: 'Optional[I18nHints]'
    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    description: 'Optional[MarkdownString]'
    """
    A longer description of the oracle table's intended usage, which might
    include multiple paragraphs. If it's only a couple sentences, use the
    `summary` key instead.
    """

    icon: 'Optional[SvgImageURL]'
    """
    An icon that represents this table.
    """

    images: 'Optional[List[WebpImageURL]]'
    match: 'Optional[OracleTableMatchBehavior]'
    """
    Most oracle tables are insensitive to matches, but a few define special
    match behavior.
    """

    rendering: 'Optional[OracleTableRendering]'
    """
    Describes how how to render this table, when presenting it as a standalone
    table.
    """

    replaces: 'Optional[OracleTableID]'
    """
    Indicates that this table replaces the identified table. References to the
    replaced table can be considered equivalent to this table.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    A brief summary of the oracle table's intended usage, no more than a few
    sentences in length. This is intended for use in application tooltips
    and similar sorts of hints. Longer text should use the "description" key
    instead.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTable':
        return cls(
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(OracleTableID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(List[OracleTableRow], data.get("table")),
            _from_json_data(Optional[I18nHints], data.get("_i18n")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[WebpImageURL]], data.get("images")),
            _from_json_data(Optional[OracleTableMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleTableRendering], data.get("rendering")),
            _from_json_data(Optional[OracleTableID], data.get("replaces")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["dice"] = _to_json_data(self.dice)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        data["table"] = _to_json_data(self.table)
        if self.i18n is not None:
             data["_i18n"] = _to_json_data(self.i18n)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.images is not None:
             data["images"] = _to_json_data(self.images)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.rendering is not None:
             data["rendering"] = _to_json_data(self.rendering)
        if self.replaces is not None:
             data["replaces"] = _to_json_data(self.replaces)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        return data

@dataclass
class OracleTableColumn:
    content_type: 'OracleTableColumnContentKey'
    label: 'Label'
    """
    The column's header text.
    """

    color: 'Optional[CSSColor]'
    """
    The thematic color for this column.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableColumn':
        return cls(
            _from_json_data(OracleTableColumnContentKey, data.get("content_type")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(Optional[CSSColor], data.get("color")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["content_type"] = _to_json_data(self.content_type)
        data["label"] = _to_json_data(self.label)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        return data

class OracleTableColumnContentKey(Enum):
    """
    The value(s) from each OracleTableRow that is rendered in this column.
    """

    DESCRIPTION = "description"
    """
    Column displays the OracleTableRow's `description` key.
    """

    RESULT = "result"
    """
    Column displays the OracleTableRow's `result` key.
    """

    ROLL = "roll"
    """
    Column displays the roll range (`min` and `max`) of each OracleTableRow.
    """

    SUMMARY = "summary"
    """
    Column displays the OracleTableRow's `summary` key.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableColumnContentKey':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleTableID:
    """
    A unique ID for an OracleTable.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class OracleTableIDWildcard:
    """
    Oracle table wildcards can also use '**' to represent any number of
    collection levels in the oracle tree.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableIDWildcard':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class OracleTableMatchBehavior:
    text: 'MarkdownString'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableMatchBehavior':
        return cls(
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class OracleTableRendering:
    """
    Describes the presentation of this table.
    """

    style: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRendering':
        variants: Dict[str, Type[OracleTableRendering]] = {
            "column": OracleTableRenderingColumn,
            "embed_in_row": OracleTableRenderingEmbedInRow,
            "standalone": OracleTableRenderingStandalone,
        }

        return variants[data["style"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class OracleTableRenderingColumn(OracleTableRendering):

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRenderingColumn':
        return cls(
            "column",
        )

    def to_json_data(self) -> Any:
        data = { "style": "column" }
        return data

@dataclass
class OracleTableRenderingEmbedInRow(OracleTableRendering):

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRenderingEmbedInRow':
        return cls(
            "embed_in_row",
        )

    def to_json_data(self) -> Any:
        data = { "style": "embed_in_row" }
        return data

@dataclass
class OracleTableRenderingStandalone(OracleTableRendering):
    columns: 'Dict[str, OracleTableColumn]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRenderingStandalone':
        return cls(
            "standalone",
            _from_json_data(Dict[str, OracleTableColumn], data.get("columns")),
        )

    def to_json_data(self) -> Any:
        data = { "style": "standalone" }
        data["columns"] = _to_json_data(self.columns)
        return data

@dataclass
class OracleTableRoll:
    auto: 'bool'
    """
    Both Ironsworn and Starforged explicitly recommend *against* rolling
    all details at once. That said, some oracle results only provide useful
    information once a secondary roll occurs, such as "Action + Theme".
    """

    dice: 'DiceExpression'
    method: 'OracleTableRollMethod'
    """
    Special rules on how the oracle table roll is performed.
    """

    oracle: 'OracleTableID'
    times: 'int'
    """
    The number of times to roll.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRoll':
        return cls(
            _from_json_data(bool, data.get("auto")),
            _from_json_data(DiceExpression, data.get("dice")),
            _from_json_data(OracleTableRollMethod, data.get("method")),
            _from_json_data(OracleTableID, data.get("oracle")),
            _from_json_data(int, data.get("times")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["auto"] = _to_json_data(self.auto)
        data["dice"] = _to_json_data(self.dice)
        data["method"] = _to_json_data(self.method)
        data["oracle"] = _to_json_data(self.oracle)
        data["times"] = _to_json_data(self.times)
        return data

class OracleTableRollMethod(Enum):
    """
    Special roll instructions to use when rolling multiple times on a single
    oracle table.
    """

    KEEP_DUPLICATES = "keep_duplicates"
    """
    Duplicates should be kept.
    """

    MAKE_IT_WORSE = "make_it_worse"
    """
    Duplicates should be kept, and they compound to make things worse.
    """

    NO_DUPLICATES = "no_duplicates"
    """
    Duplicates should be re-rolled.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRollMethod':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleTableRow:
    """
    Represents a row in an oracle table.
    """

    id: 'OracleTableRowID'
    """
    The unique Datasworn ID for this item.
    """

    max: 'int'
    """
    High end of the dice range for this table row.
    """

    min: 'int'
    """
    Low end of the dice range for this table row.
    """

    result: 'MarkdownString'
    """
    The primary text content of this row.
    """

    description: 'Optional[MarkdownString]'
    """
    Optional tertiary text content for this row. Generally, this is longer than
    both `result` and `summary`.
    """

    embed_table: 'Optional[OracleTableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    i18n: 'Optional[I18nHints]'
    icon: 'Optional[SvgImageURL]'
    rolls: 'Optional[List[OracleTableRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    Optional secondary text content for this row. Generally, this is longer
    than `result`.
    """

    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRow':
        return cls(
            _from_json_data(OracleTableRowID, data.get("id")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(MarkdownString, data.get("result")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[OracleTableID], data.get("embed_table")),
            _from_json_data(Optional[I18nHints], data.get("i18n")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleTableRoll]], data.get("rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["result"] = _to_json_data(self.result)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.i18n is not None:
             data["i18n"] = _to_json_data(self.i18n)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.rolls is not None:
             data["rolls"] = _to_json_data(self.rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class OracleTableRowID:
    """
    Normally, rows will end with two numbers separated by a dash, indicating
    their dice range.
    
    Rows with a single number represent unrollable rows that are sometimes
    included for rendering purposes; in this case, the number represents the
    row's index.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRowID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class PartOfSpeech(Enum):
    ADJECTIVE = "adjective"
    """
    An adjective.
    """

    ADJUNCT_COMMON_NOUN = "adjunct_common_noun"
    """
    A common noun used as an adjective, to modify another noun.
    """

    ADJUNCT_PROPER_NOUN = "adjunct_proper_noun"
    """
    A proper noun used as an adjective, to modify another noun.
    """

    ATTRIBUTIVE_VERB = "attributive_verb"
    """
    A verb used as an adjective, to modify a noun.
    """

    COMMON_NOUN = "common_noun"
    """
    A common noun.
    """

    GERUND = "gerund"
    """
    Gerund or present participle of a verb, e.g. "going", "seeing", "waving"
    """

    PROPER_NOUN = "proper_noun"
    """
    A proper noun.
    """

    VERB = "verb"
    """
    A verb in present tense
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'PartOfSpeech':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class ProgressRollMethod(Enum):
    MISS = "miss"
    """
    An automatic miss.
    """

    PROGRESS_ROLL = "progress_roll"
    """
    Make a progress roll on a progress track associated with this move.
    """

    STRONG_HIT = "strong_hit"
    """
    An automatic strong hit.
    """

    WEAK_HIT = "weak_hit"
    """
    An automatic weak hit.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'ProgressRollMethod':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class ProgressRollOptionUsing(Enum):
    PROGRESS_TRACK = "progress_track"
    @classmethod
    def from_json_data(cls, data: Any) -> 'ProgressRollOptionUsing':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class ProgressRollOption:
    using: 'ProgressRollOptionUsing'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ProgressRollOption':
        return cls(
            _from_json_data(ProgressRollOptionUsing, data.get("using")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["using"] = _to_json_data(self.using)
        return data

@dataclass
class ProgressTrackTypeInfo:
    """
    Describes the features of a type of progress track.
    """

    category: 'Label'
    """
    A category label for progress tracks of this type.
    """

    controls: 'Optional[Dict[str, Any]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ProgressTrackTypeInfo':
        return cls(
            _from_json_data(Label, data.get("category")),
            _from_json_data(Optional[Dict[str, Any]], data.get("controls")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["category"] = _to_json_data(self.category)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        return data

@dataclass
class Rarity:
    """
    A rarity, as described in Ironsworn: Delve.
    """

    asset: 'AssetID'
    """
    The asset augmented by this rarity.
    """

    description: 'MarkdownString'
    id: 'RarityID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    xp_cost: 'int'
    """
    From Ironsworn: Delve, p. 174:
    
          Some assets will bring a rarity into play more often than others, so
    the experience point cost for a rarity will vary by the linked asset. These
    costs are shown in the tables on page 175.
    
          If you are playing solo, and aren’t concerned with the relative
    balance of rarity abilities, you can ignore these variable costs. If so,
    spend 3 experience points to purchase a rarity.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    icon: 'Optional[SvgImageURL]'
    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Rarity':
        return cls(
            _from_json_data(AssetID, data.get("asset")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(RarityID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(int, data.get("xp_cost")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["asset"] = _to_json_data(self.asset)
        data["description"] = _to_json_data(self.description)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        data["xp_cost"] = _to_json_data(self.xp_cost)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class RarityID:
    """
    A unique ID for a Rarity.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RarityID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class RollableValue:
    using: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValue':
        variants: Dict[str, Type[RollableValue]] = {
            "asset_control": RollableValueAssetControl,
            "asset_option": RollableValueAssetOption,
            "attached_asset_control": RollableValueAttachedAssetControl,
            "attached_asset_option": RollableValueAttachedAssetOption,
            "condition_meter": RollableValueConditionMeter,
            "custom": RollableValueCustom,
            "stat": RollableValueStat,
        }

        return variants[data["using"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class RollableValueAssetControl(RollableValue):
    """
    A reference to the value of an asset control.
    """

    assets: 'List[AssetIDWildcard]'
    control: 'DictKey'
    """
    The dictionary key of the asset control field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueAssetControl':
        return cls(
            "asset_control",
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(DictKey, data.get("control")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "asset_control" }
        data["assets"] = _to_json_data(self.assets)
        data["control"] = _to_json_data(self.control)
        return data

@dataclass
class RollableValueAssetOption(RollableValue):
    """
    A reference to the value of an asset option.
    """

    assets: 'List[AssetIDWildcard]'
    option: 'DictKey'
    """
    The dictionary key of the asset option field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueAssetOption':
        return cls(
            "asset_option",
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(DictKey, data.get("option")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "asset_option" }
        data["assets"] = _to_json_data(self.assets)
        data["option"] = _to_json_data(self.option)
        return data

@dataclass
class RollableValueAttachedAssetControl(RollableValue):
    """
    A reference to the value of an attached asset control. For example, a Module
    asset could use this to roll using the `integrity` control of an attached
    Vehicle.
    """

    control: 'DictKey'
    """
    The dictionary key of the asset control field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueAttachedAssetControl':
        return cls(
            "attached_asset_control",
            _from_json_data(DictKey, data.get("control")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "attached_asset_control" }
        data["control"] = _to_json_data(self.control)
        return data

@dataclass
class RollableValueAttachedAssetOption(RollableValue):
    """
    A reference to the value of an attached asset option.
    """

    option: 'DictKey'
    """
    The dictionary key of the asset option field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueAttachedAssetOption':
        return cls(
            "attached_asset_option",
            _from_json_data(DictKey, data.get("option")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "attached_asset_option" }
        data["option"] = _to_json_data(self.option)
        return data

@dataclass
class RollableValueConditionMeter(RollableValue):
    """
    A reference to the value of a standard player condition meter.
    """

    condition_meter: 'ConditionMeterKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueConditionMeter':
        return cls(
            "condition_meter",
            _from_json_data(ConditionMeterKey, data.get("condition_meter")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "condition_meter" }
        data["condition_meter"] = _to_json_data(self.condition_meter)
        return data

@dataclass
class RollableValueCustom(RollableValue):
    """
    An arbitrary static integer value with a label.
    """

    label: 'InputLabel'
    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueCustom':
        return cls(
            "custom",
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(int, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "custom" }
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class RollableValueStat(RollableValue):
    """
    A reference to the value of a standard player character stat.
    """

    stat: 'StatKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RollableValueStat':
        return cls(
            "stat",
            _from_json_data(StatKey, data.get("stat")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "stat" }
        data["stat"] = _to_json_data(self.stat)
        return data

@dataclass
class Rules:
    """
    Describes rules for player characters in this ruleset, such as stats and
    condition meters.
    """

    condition_meters: 'Dict[str, ConditionMeterRule]'
    """
    Describes the standard condition meters used by player characters in this
    ruleset.
    """

    impacts: 'Dict[str, ImpactCategory]'
    """
    Describes the standard impacts/debilities used by player characters in this
    ruleset.
    """

    special_tracks: 'Dict[str, SpecialTrackRule]'
    """
    Describes the special tracks used by player characters in this ruleset, like
    Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    """

    stats: 'Dict[str, StatRule]'
    """
    Describes the standard stats used by player characters in this ruleset.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'Rules':
        return cls(
            _from_json_data(Dict[str, ConditionMeterRule], data.get("condition_meters")),
            _from_json_data(Dict[str, ImpactCategory], data.get("impacts")),
            _from_json_data(Dict[str, SpecialTrackRule], data.get("special_tracks")),
            _from_json_data(Dict[str, StatRule], data.get("stats")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["condition_meters"] = _to_json_data(self.condition_meters)
        data["impacts"] = _to_json_data(self.impacts)
        data["special_tracks"] = _to_json_data(self.special_tracks)
        data["stats"] = _to_json_data(self.stats)
        return data

@dataclass
class RulesExpansion:
    """
    Describes rules for player characters in this ruleset, such as stats and
    condition meters.
    """

    condition_meters: 'Optional[Dict[str, ConditionMeterRule]]'
    """
    Describes the standard condition meters used by player characters in this
    ruleset.
    """

    impacts: 'Optional[Dict[str, ImpactCategory]]'
    """
    Describes the standard impacts/debilities used by player characters in this
    ruleset.
    """

    special_tracks: 'Optional[Dict[str, SpecialTrackRule]]'
    """
    Describes the special tracks used by player characters in this ruleset, like
    Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    """

    stats: 'Optional[Dict[str, StatRule]]'
    """
    Describes the standard stats used by player characters in this ruleset.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesExpansion':
        return cls(
            _from_json_data(Optional[Dict[str, ConditionMeterRule]], data.get("condition_meters")),
            _from_json_data(Optional[Dict[str, ImpactCategory]], data.get("impacts")),
            _from_json_data(Optional[Dict[str, SpecialTrackRule]], data.get("special_tracks")),
            _from_json_data(Optional[Dict[str, StatRule]], data.get("stats")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.condition_meters is not None:
             data["condition_meters"] = _to_json_data(self.condition_meters)
        if self.impacts is not None:
             data["impacts"] = _to_json_data(self.impacts)
        if self.special_tracks is not None:
             data["special_tracks"] = _to_json_data(self.special_tracks)
        if self.stats is not None:
             data["stats"] = _to_json_data(self.stats)
        return data

@dataclass
class RulesetID:
    """
    The ID of standalone Datasworn package that describes its own ruleset.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RulesetID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class SelectEnhancementFieldChoiceChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectEnhancementFieldChoiceChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectEnhancementFieldChoice:
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectEnhancementFieldChoiceChoiceType'
    label: 'InputLabel'
    enhance_asset: 'Optional[AssetEnhancement]'
    enhance_moves: 'Optional[List[MoveEnhancement]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectEnhancementFieldChoice':
        return cls(
            _from_json_data(SelectEnhancementFieldChoiceChoiceType, data.get("choice_type")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(Optional[AssetEnhancement], data.get("enhance_asset")),
            _from_json_data(Optional[List[MoveEnhancement]], data.get("enhance_moves")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["choice_type"] = _to_json_data(self.choice_type)
        data["label"] = _to_json_data(self.label)
        if self.enhance_asset is not None:
             data["enhance_asset"] = _to_json_data(self.enhance_asset)
        if self.enhance_moves is not None:
             data["enhance_moves"] = _to_json_data(self.enhance_moves)
        return data

@dataclass
class SelectValueFieldChoice:
    using: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoice':
        variants: Dict[str, Type[SelectValueFieldChoice]] = {
            "asset_control": SelectValueFieldChoiceAssetControl,
            "asset_option": SelectValueFieldChoiceAssetOption,
            "attached_asset_control": SelectValueFieldChoiceAttachedAssetControl,
            "attached_asset_option": SelectValueFieldChoiceAttachedAssetOption,
            "condition_meter": SelectValueFieldChoiceConditionMeter,
            "custom": SelectValueFieldChoiceCustom,
            "stat": SelectValueFieldChoiceStat,
        }

        return variants[data["using"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

class SelectValueFieldChoiceAssetControlChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAssetControlChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceAssetControl(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    assets: 'List[AssetIDWildcard]'
    choice_type: 'SelectValueFieldChoiceAssetControlChoiceType'
    control: 'DictKey'
    """
    The dictionary key of the asset control field.
    """

    label: 'InputLabel'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAssetControl':
        return cls(
            "asset_control",
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(SelectValueFieldChoiceAssetControlChoiceType, data.get("choice_type")),
            _from_json_data(DictKey, data.get("control")),
            _from_json_data(InputLabel, data.get("label")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "asset_control" }
        data["assets"] = _to_json_data(self.assets)
        data["choice_type"] = _to_json_data(self.choice_type)
        data["control"] = _to_json_data(self.control)
        data["label"] = _to_json_data(self.label)
        return data

class SelectValueFieldChoiceAssetOptionChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAssetOptionChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceAssetOption(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    assets: 'List[AssetIDWildcard]'
    choice_type: 'SelectValueFieldChoiceAssetOptionChoiceType'
    label: 'InputLabel'
    option: 'DictKey'
    """
    The dictionary key of the asset option field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAssetOption':
        return cls(
            "asset_option",
            _from_json_data(List[AssetIDWildcard], data.get("assets")),
            _from_json_data(SelectValueFieldChoiceAssetOptionChoiceType, data.get("choice_type")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(DictKey, data.get("option")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "asset_option" }
        data["assets"] = _to_json_data(self.assets)
        data["choice_type"] = _to_json_data(self.choice_type)
        data["label"] = _to_json_data(self.label)
        data["option"] = _to_json_data(self.option)
        return data

class SelectValueFieldChoiceAttachedAssetControlChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAttachedAssetControlChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceAttachedAssetControl(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectValueFieldChoiceAttachedAssetControlChoiceType'
    control: 'DictKey'
    """
    The dictionary key of the asset control field.
    """

    label: 'InputLabel'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAttachedAssetControl':
        return cls(
            "attached_asset_control",
            _from_json_data(SelectValueFieldChoiceAttachedAssetControlChoiceType, data.get("choice_type")),
            _from_json_data(DictKey, data.get("control")),
            _from_json_data(InputLabel, data.get("label")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "attached_asset_control" }
        data["choice_type"] = _to_json_data(self.choice_type)
        data["control"] = _to_json_data(self.control)
        data["label"] = _to_json_data(self.label)
        return data

class SelectValueFieldChoiceAttachedAssetOptionChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAttachedAssetOptionChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceAttachedAssetOption(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectValueFieldChoiceAttachedAssetOptionChoiceType'
    label: 'InputLabel'
    option: 'DictKey'
    """
    The dictionary key of the asset option field.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceAttachedAssetOption':
        return cls(
            "attached_asset_option",
            _from_json_data(SelectValueFieldChoiceAttachedAssetOptionChoiceType, data.get("choice_type")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(DictKey, data.get("option")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "attached_asset_option" }
        data["choice_type"] = _to_json_data(self.choice_type)
        data["label"] = _to_json_data(self.label)
        data["option"] = _to_json_data(self.option)
        return data

class SelectValueFieldChoiceConditionMeterChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceConditionMeterChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceConditionMeter(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectValueFieldChoiceConditionMeterChoiceType'
    condition_meter: 'ConditionMeterKey'
    label: 'InputLabel'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceConditionMeter':
        return cls(
            "condition_meter",
            _from_json_data(SelectValueFieldChoiceConditionMeterChoiceType, data.get("choice_type")),
            _from_json_data(ConditionMeterKey, data.get("condition_meter")),
            _from_json_data(InputLabel, data.get("label")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "condition_meter" }
        data["choice_type"] = _to_json_data(self.choice_type)
        data["condition_meter"] = _to_json_data(self.condition_meter)
        data["label"] = _to_json_data(self.label)
        return data

class SelectValueFieldChoiceCustomChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceCustomChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceCustom(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectValueFieldChoiceCustomChoiceType'
    label: 'InputLabel'
    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceCustom':
        return cls(
            "custom",
            _from_json_data(SelectValueFieldChoiceCustomChoiceType, data.get("choice_type")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(int, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "custom" }
        data["choice_type"] = _to_json_data(self.choice_type)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        return data

class SelectValueFieldChoiceStatChoiceType(Enum):
    CHOICE = "choice"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceStatChoiceType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SelectValueFieldChoiceStat(SelectValueFieldChoice):
    """
    Represents an option in a list of choices.
    """

    choice_type: 'SelectValueFieldChoiceStatChoiceType'
    label: 'InputLabel'
    stat: 'StatKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SelectValueFieldChoiceStat':
        return cls(
            "stat",
            _from_json_data(SelectValueFieldChoiceStatChoiceType, data.get("choice_type")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(StatKey, data.get("stat")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "stat" }
        data["choice_type"] = _to_json_data(self.choice_type)
        data["label"] = _to_json_data(self.label)
        data["stat"] = _to_json_data(self.stat)
        return data

@dataclass
class SemanticVersion:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SemanticVersion':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Source:
    """
    Metadata describing the original source of this item
    """

    authors: 'List[AuthorInfo]'
    date: 'str'
    """
    The date of the source documents's last update, formatted YYYY-MM-DD.
    Required because it's used to determine whether the data needs updating.
    """

    license: 'str'
    title: 'str'
    """
    The title of the source document.
    """

    url: 'str'
    """
    An absolute URL where the source document is available.
    """

    page: 'Optional[int]'
    """
    The page number where this item is described in full.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'Source':
        return cls(
            _from_json_data(List[AuthorInfo], data.get("authors")),
            _from_json_data(str, data.get("date")),
            _from_json_data(str, data.get("license")),
            _from_json_data(str, data.get("title")),
            _from_json_data(str, data.get("url")),
            _from_json_data(Optional[int], data.get("page")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["authors"] = _to_json_data(self.authors)
        data["date"] = _to_json_data(self.date)
        data["license"] = _to_json_data(self.license)
        data["title"] = _to_json_data(self.title)
        data["url"] = _to_json_data(self.url)
        if self.page is not None:
             data["page"] = _to_json_data(self.page)
        return data

class SpecialTrackRollMethod(Enum):
    ALL = "all"
    """
    Use _every_ roll option at once.
    """

    HIGHEST = "highest"
    """
    Use the roll option with the best/highest value.
    """

    LOWEST = "lowest"
    """
    Use the roll option with the worst/lowest value.
    """

    MISS = "miss"
    """
    An automatic miss.
    """

    PLAYER_CHOICE = "player_choice"
    """
    The player chooses which roll option to use.
    """

    STRONG_HIT = "strong_hit"
    """
    An automatic strong hit.
    """

    WEAK_HIT = "weak_hit"
    """
    An automatic weak hit.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'SpecialTrackRollMethod':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class SpecialTrackRule:
    """
    Describes a special track like Bonds (classic Ironsworn), Failure (Delve),
    or Legacies (Starforged).
    """

    description: 'MarkdownString'
    """
    A description of this special track.
    """

    label: 'InputLabel'
    """
    A label for this special track.
    """

    optional: 'bool'
    """
    Is this track an optional rule?
    """

    shared: 'bool'
    """
    Is this track shared by all players?
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'SpecialTrackRule':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(InputLabel, data.get("label")),
            _from_json_data(bool, data.get("optional")),
            _from_json_data(bool, data.get("shared")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["label"] = _to_json_data(self.label)
        data["optional"] = _to_json_data(self.optional)
        data["shared"] = _to_json_data(self.shared)
        return data

@dataclass
class SpecialTrackRuleID:
    """
    A unique ID for a SpecialTrackRule.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SpecialTrackRuleID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class SpecialTrackType:
    """
    Special, ruleset-specific progress tracks. Usually, one exists per player
    character, and they persist through the life of the player character.
    'Canonical' examples:
      * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged
    legacy track, use `bonds_legacy` instead.
      * `failure_track`, described in Ironsworn: Delve
      * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described
    Ironsworn: Starforged
    
    """

    value: 'DictKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SpecialTrackType':
        return cls(_from_json_data(DictKey, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class StatKey:
    """
    A basic player character stat.
    """

    value: 'DictKey'

    @classmethod
    def from_json_data(cls, data: Any) -> 'StatKey':
        return cls(_from_json_data(DictKey, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class StatRule:
    """
    Describes a standard player character stat.
    """

    description: 'MarkdownString'
    """
    A description of this stat.
    """

    label: 'InputLabel'
    """
    A label for this stat.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'StatRule':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(InputLabel, data.get("label")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["label"] = _to_json_data(self.label)
        return data

@dataclass
class StatRuleID:
    """
    A unique ID for a StatRule.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'StatRuleID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Suggestions:
    assets: 'Optional[List[AssetID]]'
    atlas: 'Optional[List[AtlasEntryID]]'
    moves: 'Optional[List[MoveID]]'
    npcs: 'Optional[List[NpcID]]'
    oracles: 'Optional[List[OracleTableID]]'
    rarities: 'Optional[List[RarityID]]'
    site_domains: 'Optional[List[DelveSiteDomainID]]'
    site_themes: 'Optional[List[DelveSiteThemeID]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Suggestions':
        return cls(
            _from_json_data(Optional[List[AssetID]], data.get("assets")),
            _from_json_data(Optional[List[AtlasEntryID]], data.get("atlas")),
            _from_json_data(Optional[List[MoveID]], data.get("moves")),
            _from_json_data(Optional[List[NpcID]], data.get("npcs")),
            _from_json_data(Optional[List[OracleTableID]], data.get("oracles")),
            _from_json_data(Optional[List[RarityID]], data.get("rarities")),
            _from_json_data(Optional[List[DelveSiteDomainID]], data.get("site_domains")),
            _from_json_data(Optional[List[DelveSiteThemeID]], data.get("site_themes")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.assets is not None:
             data["assets"] = _to_json_data(self.assets)
        if self.atlas is not None:
             data["atlas"] = _to_json_data(self.atlas)
        if self.moves is not None:
             data["moves"] = _to_json_data(self.moves)
        if self.npcs is not None:
             data["npcs"] = _to_json_data(self.npcs)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        if self.rarities is not None:
             data["rarities"] = _to_json_data(self.rarities)
        if self.site_domains is not None:
             data["site_domains"] = _to_json_data(self.site_domains)
        if self.site_themes is not None:
             data["site_themes"] = _to_json_data(self.site_themes)
        return data

@dataclass
class SvgImageURL:
    """
    A relative URL pointing to a vector image in the SVG format.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SvgImageURL':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TemplateString:
    """
    A rich text string in Markdown with replaced values from oracle roll
    results.
    
    The custom syntax `{{some_row_key:some_oracle_table_id}}` should be replaced
    by the `some_row_key` string of a rolled oracle table. This is usually the
    `result` key, for example `{{result:starforged/oracles/core/action}}`
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TemplateString':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class ThemeDangerRowID:
    """
    A unique ID for a ThemeDangerRow.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ThemeDangerRowID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class ThemeFeatureRowID:
    """
    A unique ID for a ThemeFeatureRow.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ThemeFeatureRowID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TriggerActionRoll:
    """
    Describes trigger conditions for a move that makes an action roll.
    """

    conditions: 'List[TriggerActionRollCondition]'
    """
    Specific conditions that qualify for this trigger.
    """

    text: 'MarkdownString'
    """
    A markdown string containing the primary trigger text for this move.
    
    Secondary trigger text (for specific stats or uses of an asset ability) may
    be described in individual trigger conditions.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerActionRoll':
        return cls(
            _from_json_data(List[TriggerActionRollCondition], data.get("conditions")),
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerActionRollCondition:
    method: 'ActionRollMethod'
    roll_options: 'List[RollableValue]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerActionRollCondition':
        return cls(
            _from_json_data(ActionRollMethod, data.get("method")),
            _from_json_data(List[RollableValue], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerActionRollConditionEnhancement:
    method: 'ActionRollMethod'
    roll_options: 'List[RollableValue]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerActionRollConditionEnhancement':
        return cls(
            _from_json_data(ActionRollMethod, data.get("method")),
            _from_json_data(List[RollableValue], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerActionRollEnhancement:
    """
    Describes changes/additions made to the enhanced move's trigger conditions.
    """

    conditions: 'List[TriggerActionRollConditionEnhancement]'
    """
    Trigger conditions added to the enhanced move.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerActionRollEnhancement':
        return cls(
            _from_json_data(List[TriggerActionRollConditionEnhancement], data.get("conditions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        return data

@dataclass
class TriggerBy:
    """
    Information on who can trigger this trigger condition. Usually this is just
    the player, but some asset abilities can trigger from an ally's move.
    """

    ally: 'bool'
    """
    Can this trigger be activated by one of the player's allies?
    """

    player: 'bool'
    """
    Can this trigger be activated by the player who owns this?
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerBy':
        return cls(
            _from_json_data(bool, data.get("ally")),
            _from_json_data(bool, data.get("player")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["ally"] = _to_json_data(self.ally)
        data["player"] = _to_json_data(self.player)
        return data

@dataclass
class TriggerNoRoll:
    """
    Describes trigger conditions for a move that makes no rolls.
    """

    conditions: 'List[TriggerNoRollCondition]'
    text: 'MarkdownString'
    """
    A markdown string containing the primary trigger text for this move.
    
    Secondary trigger text (for specific stats or uses of an asset ability) may
    be described in individual trigger conditions.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerNoRoll':
        return cls(
            _from_json_data(List[TriggerNoRollCondition], data.get("conditions")),
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerNoRollCondition:
    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerNoRollCondition':
        return cls(
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerNoRollEnhancement:
    """
    Describes changes/additions made to the enhanced move's trigger conditions.
    """

    conditions: 'List[TriggerNoRollCondition]'
    """
    Trigger conditions added to the enhanced move.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerNoRollEnhancement':
        return cls(
            _from_json_data(List[TriggerNoRollCondition], data.get("conditions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        return data

@dataclass
class TriggerProgressRoll:
    conditions: 'List[TriggerProgressRollCondition]'
    """
    Specific conditions that qualify for this trigger.
    """

    text: 'MarkdownString'
    """
    A markdown string containing the primary trigger text for this move.
    
    Secondary trigger text (for specific stats or uses of an asset ability) may
    be described in individual trigger conditions.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerProgressRoll':
        return cls(
            _from_json_data(List[TriggerProgressRollCondition], data.get("conditions")),
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerProgressRollCondition:
    method: 'ProgressRollMethod'
    roll_options: 'List[ProgressRollOption]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerProgressRollCondition':
        return cls(
            _from_json_data(ProgressRollMethod, data.get("method")),
            _from_json_data(List[ProgressRollOption], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerProgressRollConditionEnhancement:
    method: 'ProgressRollMethod'
    roll_options: 'List[ProgressRollOption]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerProgressRollConditionEnhancement':
        return cls(
            _from_json_data(ProgressRollMethod, data.get("method")),
            _from_json_data(List[ProgressRollOption], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerProgressRollEnhancement:
    """
    Describes changes/additions made to the enhanced move's trigger conditions.
    """

    conditions: 'List[TriggerProgressRollConditionEnhancement]'
    """
    Trigger conditions added to the enhanced move.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerProgressRollEnhancement':
        return cls(
            _from_json_data(List[TriggerProgressRollConditionEnhancement], data.get("conditions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        return data

@dataclass
class TriggerSpecialTrack:
    conditions: 'List[TriggerSpecialTrackCondition]'
    """
    Specific conditions that qualify for this trigger.
    """

    text: 'MarkdownString'
    """
    A markdown string containing the primary trigger text for this move.
    
    Secondary trigger text (for specific stats or uses of an asset ability) may
    be described in individual trigger conditions.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerSpecialTrack':
        return cls(
            _from_json_data(List[TriggerSpecialTrackCondition], data.get("conditions")),
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerSpecialTrackCondition:
    method: 'SpecialTrackRollMethod'
    roll_options: 'List[TriggerSpecialTrackConditionOption]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerSpecialTrackCondition':
        return cls(
            _from_json_data(SpecialTrackRollMethod, data.get("method")),
            _from_json_data(List[TriggerSpecialTrackConditionOption], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerSpecialTrackConditionEnhancement:
    """
    A progress move that rolls on one or more special tracks, like Bonds
    (classic Ironsworn), Failure (Delve), or Legacy (Starforged).
    """

    method: 'SpecialTrackRollMethod'
    roll_options: 'List[TriggerSpecialTrackConditionOption]'
    """
    The options available when rolling with this trigger condition.
    """

    by: 'Optional[TriggerBy]'
    text: 'Optional[MarkdownString]'
    """
    A markdown string of any trigger text specific to this trigger condition.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerSpecialTrackConditionEnhancement':
        return cls(
            _from_json_data(SpecialTrackRollMethod, data.get("method")),
            _from_json_data(List[TriggerSpecialTrackConditionOption], data.get("roll_options")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        data["roll_options"] = _to_json_data(self.roll_options)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerSpecialTrackConditionOption:
    using: 'SpecialTrackType'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerSpecialTrackConditionOption':
        return cls(
            _from_json_data(SpecialTrackType, data.get("using")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["using"] = _to_json_data(self.using)
        return data

@dataclass
class TriggerSpecialTrackEnhancement:
    """
    Describes changes/additions made to the enhanced move's trigger conditions.
    """

    conditions: 'List[TriggerSpecialTrackConditionEnhancement]'
    """
    Trigger conditions added to the enhanced move.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerSpecialTrackEnhancement':
        return cls(
            _from_json_data(List[TriggerSpecialTrackConditionEnhancement], data.get("conditions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conditions"] = _to_json_data(self.conditions)
        return data

@dataclass
class Truth:
    """
    A setting truth category.
    """

    id: 'TruthID'
    """
    The unique Datasworn ID for this item.
    """

    name: 'Label'
    """
    The primary name/label for this item.
    """

    options: 'List[TruthOption]'
    source: 'Source'
    """
    Attribution for the original source (such as a book or website) of this
    item, including the author and licensing information.
    """

    canonical_name: 'Optional[Label]'
    """
    The name of this item as it appears on the page in the book, if it's
    different from `name`.
    """

    icon: 'Optional[SvgImageURL]'
    suggestions: 'Optional[Suggestions]'
    your_character: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Truth':
        return cls(
            _from_json_data(TruthID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[TruthOption], data.get("options")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("your_character")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["options"] = _to_json_data(self.options)
        data["source"] = _to_json_data(self.source)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.your_character is not None:
             data["your_character"] = _to_json_data(self.your_character)
        return data

@dataclass
class TruthID:
    """
    A unique ID for a Truth.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TruthOption:
    description: 'MarkdownString'
    id: 'TruthOptionID'
    """
    The unique Datasworn ID for this item.
    """

    quest_starter: 'MarkdownString'
    max: 'Optional[int]'
    min: 'Optional[int]'
    summary: 'Optional[MarkdownString]'
    table: 'Optional[List[TruthOptionTableRow]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthOption':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(TruthOptionID, data.get("id")),
            _from_json_data(MarkdownString, data.get("quest_starter")),
            _from_json_data(Optional[int], data.get("max")),
            _from_json_data(Optional[int], data.get("min")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[List[TruthOptionTableRow]], data.get("table")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["id"] = _to_json_data(self.id)
        data["quest_starter"] = _to_json_data(self.quest_starter)
        if self.max is not None:
             data["max"] = _to_json_data(self.max)
        if self.min is not None:
             data["min"] = _to_json_data(self.min)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.table is not None:
             data["table"] = _to_json_data(self.table)
        return data

@dataclass
class TruthOptionID:
    """
    A unique ID for a TruthOption.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthOptionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TruthOptionTableRow:
    """
    Represents a row in an oracle table.
    """

    max: 'int'
    """
    High end of the dice range for this table row.
    """

    min: 'int'
    """
    Low end of the dice range for this table row.
    """

    result: 'MarkdownString'
    """
    The primary text content of this row.
    """

    description: 'Optional[MarkdownString]'
    """
    Optional tertiary text content for this row. Generally, this is longer than
    both `result` and `summary`.
    """

    embed_table: 'Optional[OracleTableID]'
    """
    Hints that the identified table should be rendered inside this table row.
    """

    i18n: 'Optional[I18nHints]'
    icon: 'Optional[SvgImageURL]'
    rolls: 'Optional[List[OracleTableRoll]]'
    """
    Further oracle rolls prompted by this table row.
    """

    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    """
    Optional secondary text content for this row. Generally, this is longer
    than `result`.
    """

    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TruthOptionTableRow':
        return cls(
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(MarkdownString, data.get("result")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[OracleTableID], data.get("embed_table")),
            _from_json_data(Optional[I18nHints], data.get("i18n")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleTableRoll]], data.get("rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["result"] = _to_json_data(self.result)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.i18n is not None:
             data["i18n"] = _to_json_data(self.i18n)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.rolls is not None:
             data["rolls"] = _to_json_data(self.rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class WebpImageURL:
    """
    A relative URL pointing to a raster image in the WEBP format.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WebpImageURL':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

def _from_json_data(cls: Any, data: Any) -> Any:
    if data is None or cls in [bool, int, float, str, object] or cls is Any:
        return data
    if cls is datetime:
        return _parse_rfc3339(data)
    if get_origin(cls) is Union:
        return _from_json_data(get_args(cls)[0], data)
    if get_origin(cls) is list:
        return [_from_json_data(get_args(cls)[0], d) for d in data]
    if get_origin(cls) is dict:
        return { k: _from_json_data(get_args(cls)[1], v) for k, v in data.items() }
    return cls.from_json_data(data)

def _to_json_data(data: Any) -> Any:
    if data is None or type(data) in [bool, int, float, str, object]:
        return data
    if type(data) is datetime:
        return data.isoformat()
    if type(data) is list:
        return [_to_json_data(d) for d in data]
    if type(data) is dict:
        return { k: _to_json_data(v) for k, v in data.items() }
    return data.to_json_data()

def _parse_rfc3339(s: str) -> datetime:
    datetime_re = '^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(\.\d+)?([zZ]|((\+|-)(\d{2}):(\d{2})))$'
    match = re.match(datetime_re, s)
    if not match:
        raise ValueError('Invalid RFC3339 date/time', s)

    (year, month, day, hour, minute, second, frac_seconds, offset,
     *tz) = match.groups()

    frac_seconds_parsed = None
    if frac_seconds:
        frac_seconds_parsed = int(float(frac_seconds) * 1_000_000)
    else:
        frac_seconds_parsed = 0

    tzinfo = None
    if offset == 'Z':
        tzinfo = timezone.utc
    else:
        hours = int(tz[2])
        minutes = int(tz[3])
        sign = 1 if tz[1] == '+' else -1

        if minutes not in range(60):
            raise ValueError('minute offset must be in 0..59')

        tzinfo = timezone(timedelta(minutes=sign * (60 * hours + minutes)))

    second_parsed = int(second)
    if second_parsed == 60:
        second_parsed = 59

    return datetime(int(year), int(month), int(day), int(hour), int(minute),
                    second_parsed, frac_seconds_parsed, tzinfo)            
