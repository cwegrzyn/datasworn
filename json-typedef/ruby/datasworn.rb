# Code generated by jtd-codegen for Ruby v0.1.1

require 'json'
require 'time'

module Datasworn

  # Describes game rules compatible with the Ironsworn tabletop role-playing
  # game by Shawn Tomkin.
  class RulesPackage
    attr_accessor :package_type

    def self.from_json_data(data)
      {
        "expansion" => RulesPackageExpansion,
        "ruleset" => RulesPackageRuleset,
      }[data["package_type"]].from_json_data(data)
    end
  end

  # A Datasworn package that relies on an external package to provide its
  # ruleset.
  class RulesPackageExpansion < RulesPackage
    attr_accessor :datasworn_version
    attr_accessor :id
    attr_accessor :ruleset
    attr_accessor :assets
    attr_accessor :atlas
    attr_accessor :delve_sites
    attr_accessor :moves
    attr_accessor :npcs
    attr_accessor :oracles
    attr_accessor :rarities
    attr_accessor :rules
    attr_accessor :site_domains
    attr_accessor :site_themes
    attr_accessor :truths

    def self.from_json_data(data)
      out = RulesPackageExpansion.new
      out.package_type = "expansion"
      out.datasworn_version = Datasworn::from_json_data(SemanticVersion, data["datasworn_version"])
      out.id = Datasworn::from_json_data(ExpansionID, data["id"])
      out.ruleset = Datasworn::from_json_data(RulesetID, data["ruleset"])
      out.assets = Datasworn::from_json_data(Hash[String, AssetType], data["assets"])
      out.atlas = Datasworn::from_json_data(Hash[String, Atlas], data["atlas"])
      out.delve_sites = Datasworn::from_json_data(Hash[String, DelveSite], data["delve_sites"])
      out.moves = Datasworn::from_json_data(Hash[String, MoveCategory], data["moves"])
      out.npcs = Datasworn::from_json_data(Hash[String, NpcCollection], data["npcs"])
      out.oracles = Datasworn::from_json_data(Hash[String, OracleCollection], data["oracles"])
      out.rarities = Datasworn::from_json_data(Hash[String, Rarity], data["rarities"])
      out.rules = Datasworn::from_json_data(RulesExpansion, data["rules"])
      out.site_domains = Datasworn::from_json_data(Hash[String, DelveSiteDomain], data["site_domains"])
      out.site_themes = Datasworn::from_json_data(Hash[String, DelveSiteTheme], data["site_themes"])
      out.truths = Datasworn::from_json_data(Hash[String, Truth], data["truths"])
      out
    end

    def to_json_data
      data = { "package_type" => "expansion" }
      data["datasworn_version"] = Datasworn::to_json_data(datasworn_version)
      data["id"] = Datasworn::to_json_data(id)
      data["ruleset"] = Datasworn::to_json_data(ruleset)
      data["assets"] = Datasworn::to_json_data(assets) unless assets.nil?
      data["atlas"] = Datasworn::to_json_data(atlas) unless atlas.nil?
      data["delve_sites"] = Datasworn::to_json_data(delve_sites) unless delve_sites.nil?
      data["moves"] = Datasworn::to_json_data(moves) unless moves.nil?
      data["npcs"] = Datasworn::to_json_data(npcs) unless npcs.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["rarities"] = Datasworn::to_json_data(rarities) unless rarities.nil?
      data["rules"] = Datasworn::to_json_data(rules) unless rules.nil?
      data["site_domains"] = Datasworn::to_json_data(site_domains) unless site_domains.nil?
      data["site_themes"] = Datasworn::to_json_data(site_themes) unless site_themes.nil?
      data["truths"] = Datasworn::to_json_data(truths) unless truths.nil?
      data
    end
  end

  # A standalone Datasworn package that describes its own ruleset.
  class RulesPackageRuleset < RulesPackage
    attr_accessor :assets
    attr_accessor :datasworn_version
    attr_accessor :id
    attr_accessor :moves
    attr_accessor :oracles
    attr_accessor :rules
    attr_accessor :atlas
    attr_accessor :delve_sites
    attr_accessor :npcs
    attr_accessor :rarities
    attr_accessor :site_domains
    attr_accessor :site_themes
    attr_accessor :truths

    def self.from_json_data(data)
      out = RulesPackageRuleset.new
      out.package_type = "ruleset"
      out.assets = Datasworn::from_json_data(Hash[String, AssetType], data["assets"])
      out.datasworn_version = Datasworn::from_json_data(SemanticVersion, data["datasworn_version"])
      out.id = Datasworn::from_json_data(RulesetID, data["id"])
      out.moves = Datasworn::from_json_data(Hash[String, MoveCategory], data["moves"])
      out.oracles = Datasworn::from_json_data(Hash[String, OracleCollection], data["oracles"])
      out.rules = Datasworn::from_json_data(Rules, data["rules"])
      out.atlas = Datasworn::from_json_data(Hash[String, Atlas], data["atlas"])
      out.delve_sites = Datasworn::from_json_data(Hash[String, DelveSite], data["delve_sites"])
      out.npcs = Datasworn::from_json_data(Hash[String, NpcCollection], data["npcs"])
      out.rarities = Datasworn::from_json_data(Hash[String, Rarity], data["rarities"])
      out.site_domains = Datasworn::from_json_data(Hash[String, DelveSiteDomain], data["site_domains"])
      out.site_themes = Datasworn::from_json_data(Hash[String, DelveSiteTheme], data["site_themes"])
      out.truths = Datasworn::from_json_data(Hash[String, Truth], data["truths"])
      out
    end

    def to_json_data
      data = { "package_type" => "ruleset" }
      data["assets"] = Datasworn::to_json_data(assets)
      data["datasworn_version"] = Datasworn::to_json_data(datasworn_version)
      data["id"] = Datasworn::to_json_data(id)
      data["moves"] = Datasworn::to_json_data(moves)
      data["oracles"] = Datasworn::to_json_data(oracles)
      data["rules"] = Datasworn::to_json_data(rules)
      data["atlas"] = Datasworn::to_json_data(atlas) unless atlas.nil?
      data["delve_sites"] = Datasworn::to_json_data(delve_sites) unless delve_sites.nil?
      data["npcs"] = Datasworn::to_json_data(npcs) unless npcs.nil?
      data["rarities"] = Datasworn::to_json_data(rarities) unless rarities.nil?
      data["site_domains"] = Datasworn::to_json_data(site_domains) unless site_domains.nil?
      data["site_themes"] = Datasworn::to_json_data(site_themes) unless site_themes.nil?
      data["truths"] = Datasworn::to_json_data(truths) unless truths.nil?
      data
    end
  end

  class ActionRollMethod
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # Use **every** roll option at once.
    ALL = new("all")

    # Use the roll option with the best/highest value.
    HIGHEST = new("highest")

    # Use the roll option with the worst/lowest value.
    LOWEST = new("lowest")

    # An automatic miss.
    MISS = new("miss")

    # The player chooses which roll option to use.
    PLAYER_CHOICE = new("player_choice")

    # An automatic strong hit.
    STRONG_HIT = new("strong_hit")

    # An automatic weak hit.
    WEAK_HIT = new("weak_hit")

    def self.from_json_data(data)
      {
        "all" => ALL,
        "highest" => HIGHEST,
        "lowest" => LOWEST,
        "miss" => MISS,
        "player_choice" => PLAYER_CHOICE,
        "strong_hit" => STRONG_HIT,
        "weak_hit" => WEAK_HIT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class Asset
    attr_accessor :abilities

    # A localized category label for this asset. This is the surtitle above the
    # asset's name on the card.
    attr_accessor :asset_type

    # If `true`, this asset counts as an impact (Starforged) or a debility
    # (classic Ironsworn).
    attr_accessor :count_as_impact

    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The primary name/label for this item.
    attr_accessor :name

    # Most assets only benefit to their owner, but certain assets (like
    # Starforged's module and command vehicle assets) are shared amongst the
    # player's allies, too.
    attr_accessor :shared

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source
    attr_accessor :attachments

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this asset.
    attr_accessor :color

    # Controls are condition meters, clocks, counters, and other asset input
    # fields whose values are expected to change throughout the life of the
    # asset.
    attr_accessor :controls

    # This asset's icon.
    attr_accessor :icon

    # Options are input fields set when the player purchases the asset. They're
    # likely to remain the same through the life of the asset. Typically, they
    # are rendered at the top of the asset card.
    attr_accessor :options

    # Describes prerequisites for purchasing or using this asset.
    attr_accessor :requirement
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = Asset.new
      out.abilities = Datasworn::from_json_data(Array[AssetAbility], data["abilities"])
      out.asset_type = Datasworn::from_json_data(Label, data["asset_type"])
      out.count_as_impact = Datasworn::from_json_data(TrueClass, data["count_as_impact"])
      out.id = Datasworn::from_json_data(AssetID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.shared = Datasworn::from_json_data(TrueClass, data["shared"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.attachments = Datasworn::from_json_data(AssetAttachment, data["attachments"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.controls = Datasworn::from_json_data(Hash[String, AssetControlField], data["controls"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.options = Datasworn::from_json_data(Hash[String, AssetOptionField], data["options"])
      out.requirement = Datasworn::from_json_data(MarkdownString, data["requirement"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["abilities"] = Datasworn::to_json_data(abilities)
      data["asset_type"] = Datasworn::to_json_data(asset_type)
      data["count_as_impact"] = Datasworn::to_json_data(count_as_impact)
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["shared"] = Datasworn::to_json_data(shared)
      data["source"] = Datasworn::to_json_data(source)
      data["attachments"] = Datasworn::to_json_data(attachments) unless attachments.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["controls"] = Datasworn::to_json_data(controls) unless controls.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["options"] = Datasworn::to_json_data(options) unless options.nil?
      data["requirement"] = Datasworn::to_json_data(requirement) unless requirement.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  # An asset ability: one of the purchasable features of an asset. Most assets
  # have three.
  class AssetAbility
    # Is this asset ability enabled?
    attr_accessor :enabled

    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The complete rules text of this asset ability.
    attr_accessor :text

    # Fields whose values are expected to change over the life of the asset.
    attr_accessor :controls

    # Changes made to the asset, when this ability is enabled.
    attr_accessor :enhance_asset

    # Describes changes made to various moves by this asset ability. Usually
    # these require specific trigger conditions.
    attr_accessor :enhance_moves

    # Unique moves added by this asset ability.
    attr_accessor :moves

    # A handful of asset abilities have a label/name, for instance classic
    # Ironsworn companion assets. Most canonical assets omit this property.
    attr_accessor :name

    # Fields that are expected to be set once and remain the same through the
    # life of the asset.
    attr_accessor :options

    def self.from_json_data(data)
      out = AssetAbility.new
      out.enabled = Datasworn::from_json_data(TrueClass, data["enabled"])
      out.id = Datasworn::from_json_data(AssetAbilityID, data["id"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.controls = Datasworn::from_json_data(Hash[String, AssetAbilityControlField], data["controls"])
      out.enhance_asset = Datasworn::from_json_data(AssetEnhancement, data["enhance_asset"])
      out.enhance_moves = Datasworn::from_json_data(Array[MoveEnhancement], data["enhance_moves"])
      out.moves = Datasworn::from_json_data(Hash[String, Move], data["moves"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.options = Datasworn::from_json_data(Hash[String, AssetAbilityOptionField], data["options"])
      out
    end

    def to_json_data
      data = {}
      data["enabled"] = Datasworn::to_json_data(enabled)
      data["id"] = Datasworn::to_json_data(id)
      data["text"] = Datasworn::to_json_data(text)
      data["controls"] = Datasworn::to_json_data(controls) unless controls.nil?
      data["enhance_asset"] = Datasworn::to_json_data(enhance_asset) unless enhance_asset.nil?
      data["enhance_moves"] = Datasworn::to_json_data(enhance_moves) unless enhance_moves.nil?
      data["moves"] = Datasworn::to_json_data(moves) unless moves.nil?
      data["name"] = Datasworn::to_json_data(name) unless name.nil?
      data["options"] = Datasworn::to_json_data(options) unless options.nil?
      data
    end
  end

  class AssetAbilityControlField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "checkbox" => AssetAbilityControlFieldCheckbox,
        "clock" => AssetAbilityControlFieldClock,
        "counter" => AssetAbilityControlFieldCounter,
      }[data["field_type"]].from_json_data(data)
    end
  end

  # Represents a checkbox.
  class AssetAbilityControlFieldCheckbox < AssetAbilityControlField
    attr_accessor :disables_asset
    attr_accessor :id
    attr_accessor :is_impact
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetAbilityControlFieldCheckbox.new
      out.field_type = "checkbox"
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.id = Datasworn::from_json_data(AssetAbilityControlFieldID, data["id"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "checkbox" }
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["id"] = Datasworn::to_json_data(id)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A clock with 4 or more segments.
  class AssetAbilityControlFieldClock < AssetAbilityControlField
    attr_accessor :id
    attr_accessor :label
    attr_accessor :max
    attr_accessor :min
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetAbilityControlFieldClock.new
      out.field_type = "clock"
      out.id = Datasworn::from_json_data(AssetAbilityControlFieldID, data["id"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "clock" }
      data["id"] = Datasworn::to_json_data(id)
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A basic counter representing a non-rollable integer value. They usually
  # start at 0, and may or may not have a maximum.
  class AssetAbilityControlFieldCounter < AssetAbilityControlField
    attr_accessor :id
    attr_accessor :label
    attr_accessor :max
    attr_accessor :min
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetAbilityControlFieldCounter.new
      out.field_type = "counter"
      out.id = Datasworn::from_json_data(AssetAbilityControlFieldID, data["id"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "counter" }
      data["id"] = Datasworn::to_json_data(id)
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A unique ID for an AssetAbilityControlField.
  class AssetAbilityControlFieldID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityControlFieldID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID for an AssetAbility.
  class AssetAbilityID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class AssetAbilityOptionField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "text" => AssetAbilityOptionFieldText,
      }[data["field_type"]].from_json_data(data)
    end
  end

  # Represents an input that accepts plain text.
  class AssetAbilityOptionFieldText < AssetAbilityOptionField
    attr_accessor :id
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetAbilityOptionFieldText.new
      out.field_type = "text"
      out.id = Datasworn::from_json_data(AssetAbilityOptionFieldID, data["id"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(String, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "text" }
      data["id"] = Datasworn::to_json_data(id)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A unique ID for an AssetAbilityOptionField.
  class AssetAbilityOptionFieldID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityOptionFieldID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Describes which assets can be attached to this asset. Example: Starforged's
  # Module assets, which can be equipped by Command Vehicle assets. See p. 55 of
  # Starforged for more info.
  class AssetAttachment
    # Asset IDs (which may be wildcards) that may be attached to this asset
    attr_accessor :assets
    attr_accessor :max

    def self.from_json_data(data)
      out = AssetAttachment.new
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out
    end

    def to_json_data
      data = {}
      data["assets"] = Datasworn::to_json_data(assets)
      data["max"] = Datasworn::to_json_data(max)
      data
    end
  end

  # A checkbox control field, rendered as part of an asset condition meter.
  class AssetConditionMeterControlField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "card_flip" => AssetConditionMeterControlFieldCardFlip,
        "checkbox" => AssetConditionMeterControlFieldCheckbox,
      }[data["field_type"]].from_json_data(data)
    end
  end

  # When its value is set to `true` it means that the card is flipped over.
  # Some assets use this to represent a 'broken' state (e.g. Starforged Module
  # assets).
  class AssetConditionMeterControlFieldCardFlip < AssetConditionMeterControlField
    attr_accessor :disables_asset
    attr_accessor :id
    attr_accessor :is_impact
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetConditionMeterControlFieldCardFlip.new
      out.field_type = "card_flip"
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.id = Datasworn::from_json_data(AssetConditionMeterControlFieldID, data["id"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "card_flip" }
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["id"] = Datasworn::to_json_data(id)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # Represents a checkbox.
  class AssetConditionMeterControlFieldCheckbox < AssetConditionMeterControlField
    attr_accessor :disables_asset
    attr_accessor :id
    attr_accessor :is_impact
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetConditionMeterControlFieldCheckbox.new
      out.field_type = "checkbox"
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.id = Datasworn::from_json_data(AssetConditionMeterControlFieldID, data["id"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "checkbox" }
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["id"] = Datasworn::to_json_data(id)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A unique ID for an AssetConditionMeterControlField.
  class AssetConditionMeterControlFieldID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetConditionMeterControlFieldID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class AssetControlField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "card_flip" => AssetControlFieldCardFlip,
        "checkbox" => AssetControlFieldCheckbox,
        "condition_meter" => AssetControlFieldConditionMeter,
        "select_enhancement" => AssetControlFieldSelectEnhancement,
      }[data["field_type"]].from_json_data(data)
    end
  end

  # When its value is set to `true` it means that the card is flipped over.
  # Some assets use this to represent a 'broken' state (e.g. Starforged Module
  # assets).
  class AssetControlFieldCardFlip < AssetControlField
    attr_accessor :disables_asset
    attr_accessor :id
    attr_accessor :is_impact
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetControlFieldCardFlip.new
      out.field_type = "card_flip"
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.id = Datasworn::from_json_data(AssetControlFieldID, data["id"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "card_flip" }
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["id"] = Datasworn::to_json_data(id)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # Represents a checkbox.
  class AssetControlFieldCheckbox < AssetControlField
    attr_accessor :disables_asset
    attr_accessor :id
    attr_accessor :is_impact
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetControlFieldCheckbox.new
      out.field_type = "checkbox"
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.id = Datasworn::from_json_data(AssetControlFieldID, data["id"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "checkbox" }
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["id"] = Datasworn::to_json_data(id)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # Provides hints for moves that interact with this condition meter, such as
  # suffer and recovery moves.
  class AssetControlFieldConditionMeterMoves
    # The ID(s) of recovery moves associated with this meter.
    attr_accessor :recover

    # The ID(s) of suffer moves associated with the condition meter. If the
    # suffer move makes an action roll, this condition meter value should be
    # made available as a roll option.
    attr_accessor :suffer

    def self.from_json_data(data)
      out = AssetControlFieldConditionMeterMoves.new
      out.recover = Datasworn::from_json_data(Array[MoveIDWildcard], data["recover"])
      out.suffer = Datasworn::from_json_data(Array[MoveIDWildcard], data["suffer"])
      out
    end

    def to_json_data
      data = {}
      data["recover"] = Datasworn::to_json_data(recover) unless recover.nil?
      data["suffer"] = Datasworn::to_json_data(suffer) unless suffer.nil?
      data
    end
  end

  # Some assets provide a special condition meter of their own. The most common
  # example is the health meters on companion assets. Asset condition meters
  # may also include their own controls, such as the checkboxes that Starforged
  # companion assets use to indicate they are "out of action".
  class AssetControlFieldConditionMeter < AssetControlField
    attr_accessor :id
    attr_accessor :label
    attr_accessor :max
    attr_accessor :min
    attr_accessor :value
    attr_accessor :controls
    attr_accessor :icon
    attr_accessor :moves

    def self.from_json_data(data)
      out = AssetControlFieldConditionMeter.new
      out.field_type = "condition_meter"
      out.id = Datasworn::from_json_data(AssetControlFieldID, data["id"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out.controls = Datasworn::from_json_data(Hash[String, AssetConditionMeterControlField], data["controls"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.moves = Datasworn::from_json_data(AssetControlFieldConditionMeterMoves, data["moves"])
      out
    end

    def to_json_data
      data = { "field_type" => "condition_meter" }
      data["id"] = Datasworn::to_json_data(id)
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["value"] = Datasworn::to_json_data(value)
      data["controls"] = Datasworn::to_json_data(controls) unless controls.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["moves"] = Datasworn::to_json_data(moves) unless moves.nil?
      data
    end
  end

  class AssetControlFieldSelectEnhancementChoice
    attr_accessor :option_type

    def self.from_json_data(data)
      {
        "option" => AssetControlFieldSelectEnhancementChoiceOption,
        "option_group" => AssetControlFieldSelectEnhancementChoiceOptionGroup,
      }[data["option_type"]].from_json_data(data)
    end
  end

  # Represents an option in a list of choices.
  class AssetControlFieldSelectEnhancementChoiceOption < AssetControlFieldSelectEnhancementChoice
    attr_accessor :label
    attr_accessor :enhance_asset
    attr_accessor :enhance_moves

    def self.from_json_data(data)
      out = AssetControlFieldSelectEnhancementChoiceOption.new
      out.option_type = "option"
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.enhance_asset = Datasworn::from_json_data(AssetEnhancement, data["enhance_asset"])
      out.enhance_moves = Datasworn::from_json_data(Array[MoveEnhancement], data["enhance_moves"])
      out
    end

    def to_json_data
      data = { "option_type" => "option" }
      data["label"] = Datasworn::to_json_data(label)
      data["enhance_asset"] = Datasworn::to_json_data(enhance_asset) unless enhance_asset.nil?
      data["enhance_moves"] = Datasworn::to_json_data(enhance_moves) unless enhance_moves.nil?
      data
    end
  end

  class AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    OPTION = new("option")

    def self.from_json_data(data)
      {
        "option" => OPTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class AssetControlFieldSelectEnhancementChoiceOptionGroupChoice
    attr_accessor :label
    attr_accessor :option_type
    attr_accessor :enhance_asset
    attr_accessor :enhance_moves

    def self.from_json_data(data)
      out = AssetControlFieldSelectEnhancementChoiceOptionGroupChoice.new
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.option_type = Datasworn::from_json_data(AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionType, data["option_type"])
      out.enhance_asset = Datasworn::from_json_data(AssetEnhancement, data["enhance_asset"])
      out.enhance_moves = Datasworn::from_json_data(Array[MoveEnhancement], data["enhance_moves"])
      out
    end

    def to_json_data
      data = {}
      data["label"] = Datasworn::to_json_data(label)
      data["option_type"] = Datasworn::to_json_data(option_type)
      data["enhance_asset"] = Datasworn::to_json_data(enhance_asset) unless enhance_asset.nil?
      data["enhance_moves"] = Datasworn::to_json_data(enhance_moves) unless enhance_moves.nil?
      data
    end
  end

  # Represents a grouping of options in a list of choices.
  class AssetControlFieldSelectEnhancementChoiceOptionGroup < AssetControlFieldSelectEnhancementChoice
    attr_accessor :choices
    attr_accessor :name

    def self.from_json_data(data)
      out = AssetControlFieldSelectEnhancementChoiceOptionGroup.new
      out.option_type = "option_group"
      out.choices = Datasworn::from_json_data(Hash[String, AssetControlFieldSelectEnhancementChoiceOptionGroupChoice], data["choices"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out
    end

    def to_json_data
      data = { "option_type" => "option_group" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["name"] = Datasworn::to_json_data(name)
      data
    end
  end

  # Select from player and/or asset enhancements. Use it to describe modal
  # abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
  # (Sundered Isles).
  class AssetControlFieldSelectEnhancement < AssetControlField
    attr_accessor :choices
    attr_accessor :id
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetControlFieldSelectEnhancement.new
      out.field_type = "select_enhancement"
      out.choices = Datasworn::from_json_data(Hash[String, AssetControlFieldSelectEnhancementChoice], data["choices"])
      out.id = Datasworn::from_json_data(AssetControlFieldID, data["id"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(DictKey, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "select_enhancement" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["id"] = Datasworn::to_json_data(id)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class AssetControlFieldEnhancement
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "condition_meter" => AssetControlFieldEnhancementConditionMeter,
      }[data["field_type"]].from_json_data(data)
    end
  end

  # Some assets provide a special condition meter of their own. The most common
  # example is the health meters on companion assets. Asset condition meters
  # may also include their own controls, such as the checkboxes that Starforged
  # companion assets use to indicate they are "out of action".
  class AssetControlFieldEnhancementConditionMeter < AssetControlFieldEnhancement
    attr_accessor :max

    def self.from_json_data(data)
      out = AssetControlFieldEnhancementConditionMeter.new
      out.field_type = "condition_meter"
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out
    end

    def to_json_data
      data = { "field_type" => "condition_meter" }
      data["max"] = Datasworn::to_json_data(max)
      data
    end
  end

  # A unique ID for an AssetControlField.
  class AssetControlFieldID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetControlFieldID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded ID that can be used to match multiple AssetControlFields.
  class AssetControlFieldIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetControlFieldIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Describes enhancements made to this asset in a partial asset object. The
  # changes should be applied recursively; only the values that are specified
  # should be changed.
  class AssetEnhancement
    attr_accessor :attachments

    # Controls are condition meters, clocks, counters, and other asset input
    # fields whose values are expected to change throughout the life of the
    # asset.
    attr_accessor :controls

    # If `true`, this asset counts as an impact (Starforged) or a debility
    # (classic Ironsworn).
    attr_accessor :count_as_impact

    # Most assets only benefit to their owner, but certain assets (like
    # Starforged's module and command vehicle assets) are shared amongst the
    # player's allies, too.
    attr_accessor :shared
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = AssetEnhancement.new
      out.attachments = Datasworn::from_json_data(AssetAttachment, data["attachments"])
      out.controls = Datasworn::from_json_data(Hash[String, AssetControlFieldEnhancement], data["controls"])
      out.count_as_impact = Datasworn::from_json_data(TrueClass, data["count_as_impact"])
      out.shared = Datasworn::from_json_data(TrueClass, data["shared"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["attachments"] = Datasworn::to_json_data(attachments) unless attachments.nil?
      data["controls"] = Datasworn::to_json_data(controls) unless controls.nil?
      data["count_as_impact"] = Datasworn::to_json_data(count_as_impact) unless count_as_impact.nil?
      data["shared"] = Datasworn::to_json_data(shared) unless shared.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  # A unique ID for an Asset.
  class AssetID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded ID that can be used to match multiple Assets.
  class AssetIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Options are asset input fields which are set once, usually when the
  # character takes the asset. The most common example is the "name" field on
  # companion assets. A more complex example is the choice of a god's stat for
  # the Devotant asset.
  class AssetOptionField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "select_enhancement" => AssetOptionFieldSelectEnhancement,
        "select_value" => AssetOptionFieldSelectValue,
        "text" => AssetOptionFieldText,
      }[data["field_type"]].from_json_data(data)
    end
  end

  class AssetOptionFieldSelectEnhancementChoice
    attr_accessor :option_type

    def self.from_json_data(data)
      {
        "option" => AssetOptionFieldSelectEnhancementChoiceOption,
        "option_group" => AssetOptionFieldSelectEnhancementChoiceOptionGroup,
      }[data["option_type"]].from_json_data(data)
    end
  end

  # Represents an option in a list of choices.
  class AssetOptionFieldSelectEnhancementChoiceOption < AssetOptionFieldSelectEnhancementChoice
    attr_accessor :label
    attr_accessor :enhance_asset
    attr_accessor :enhance_moves

    def self.from_json_data(data)
      out = AssetOptionFieldSelectEnhancementChoiceOption.new
      out.option_type = "option"
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.enhance_asset = Datasworn::from_json_data(AssetEnhancement, data["enhance_asset"])
      out.enhance_moves = Datasworn::from_json_data(Array[MoveEnhancement], data["enhance_moves"])
      out
    end

    def to_json_data
      data = { "option_type" => "option" }
      data["label"] = Datasworn::to_json_data(label)
      data["enhance_asset"] = Datasworn::to_json_data(enhance_asset) unless enhance_asset.nil?
      data["enhance_moves"] = Datasworn::to_json_data(enhance_moves) unless enhance_moves.nil?
      data
    end
  end

  class AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    OPTION = new("option")

    def self.from_json_data(data)
      {
        "option" => OPTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class AssetOptionFieldSelectEnhancementChoiceOptionGroupChoice
    attr_accessor :label
    attr_accessor :option_type
    attr_accessor :enhance_asset
    attr_accessor :enhance_moves

    def self.from_json_data(data)
      out = AssetOptionFieldSelectEnhancementChoiceOptionGroupChoice.new
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.option_type = Datasworn::from_json_data(AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionType, data["option_type"])
      out.enhance_asset = Datasworn::from_json_data(AssetEnhancement, data["enhance_asset"])
      out.enhance_moves = Datasworn::from_json_data(Array[MoveEnhancement], data["enhance_moves"])
      out
    end

    def to_json_data
      data = {}
      data["label"] = Datasworn::to_json_data(label)
      data["option_type"] = Datasworn::to_json_data(option_type)
      data["enhance_asset"] = Datasworn::to_json_data(enhance_asset) unless enhance_asset.nil?
      data["enhance_moves"] = Datasworn::to_json_data(enhance_moves) unless enhance_moves.nil?
      data
    end
  end

  # Represents a grouping of options in a list of choices.
  class AssetOptionFieldSelectEnhancementChoiceOptionGroup < AssetOptionFieldSelectEnhancementChoice
    attr_accessor :choices
    attr_accessor :name

    def self.from_json_data(data)
      out = AssetOptionFieldSelectEnhancementChoiceOptionGroup.new
      out.option_type = "option_group"
      out.choices = Datasworn::from_json_data(Hash[String, AssetOptionFieldSelectEnhancementChoiceOptionGroupChoice], data["choices"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out
    end

    def to_json_data
      data = { "option_type" => "option_group" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["name"] = Datasworn::to_json_data(name)
      data
    end
  end

  # Select from player and/or asset enhancements. Use it to describe modal
  # abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
  # (Sundered Isles).
  class AssetOptionFieldSelectEnhancement < AssetOptionField
    attr_accessor :choices
    attr_accessor :id
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetOptionFieldSelectEnhancement.new
      out.field_type = "select_enhancement"
      out.choices = Datasworn::from_json_data(Hash[String, AssetOptionFieldSelectEnhancementChoice], data["choices"])
      out.id = Datasworn::from_json_data(AssetOptionFieldID, data["id"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(DictKey, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "select_enhancement" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["id"] = Datasworn::to_json_data(id)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class AssetOptionFieldSelectValueChoice
    attr_accessor :using

    def self.from_json_data(data)
      {
        "asset_control" => AssetOptionFieldSelectValueChoiceAssetControl,
        "asset_option" => AssetOptionFieldSelectValueChoiceAssetOption,
        "attached_asset_control" => AssetOptionFieldSelectValueChoiceAttachedAssetControl,
        "attached_asset_option" => AssetOptionFieldSelectValueChoiceAttachedAssetOption,
        "condition_meter" => AssetOptionFieldSelectValueChoiceConditionMeter,
        "custom" => AssetOptionFieldSelectValueChoiceCustom,
        "stat" => AssetOptionFieldSelectValueChoiceStat,
      }[data["using"]].from_json_data(data)
    end
  end

  class AssetOptionFieldSelectValueChoiceAssetControlOptionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    OPTION = new("option")

    def self.from_json_data(data)
      {
        "option" => OPTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class AssetOptionFieldSelectValueChoiceAssetControl < AssetOptionFieldSelectValueChoice
    attr_accessor :assets
    attr_accessor :control
    attr_accessor :label
    attr_accessor :option_type

    def self.from_json_data(data)
      out = AssetOptionFieldSelectValueChoiceAssetControl.new
      out.using = "asset_control"
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.control = Datasworn::from_json_data(DictKey, data["control"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.option_type = Datasworn::from_json_data(AssetOptionFieldSelectValueChoiceAssetControlOptionType, data["option_type"])
      out
    end

    def to_json_data
      data = { "using" => "asset_control" }
      data["assets"] = Datasworn::to_json_data(assets)
      data["control"] = Datasworn::to_json_data(control)
      data["label"] = Datasworn::to_json_data(label)
      data["option_type"] = Datasworn::to_json_data(option_type)
      data
    end
  end

  class AssetOptionFieldSelectValueChoiceAssetOptionOptionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    OPTION = new("option")

    def self.from_json_data(data)
      {
        "option" => OPTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class AssetOptionFieldSelectValueChoiceAssetOption < AssetOptionFieldSelectValueChoice
    attr_accessor :assets
    attr_accessor :label
    attr_accessor :option
    attr_accessor :option_type

    def self.from_json_data(data)
      out = AssetOptionFieldSelectValueChoiceAssetOption.new
      out.using = "asset_option"
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.option = Datasworn::from_json_data(DictKey, data["option"])
      out.option_type = Datasworn::from_json_data(AssetOptionFieldSelectValueChoiceAssetOptionOptionType, data["option_type"])
      out
    end

    def to_json_data
      data = { "using" => "asset_option" }
      data["assets"] = Datasworn::to_json_data(assets)
      data["label"] = Datasworn::to_json_data(label)
      data["option"] = Datasworn::to_json_data(option)
      data["option_type"] = Datasworn::to_json_data(option_type)
      data
    end
  end

  class AssetOptionFieldSelectValueChoiceAttachedAssetControlOptionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    OPTION = new("option")

    def self.from_json_data(data)
      {
        "option" => OPTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class AssetOptionFieldSelectValueChoiceAttachedAssetControl < AssetOptionFieldSelectValueChoice
    attr_accessor :control
    attr_accessor :label
    attr_accessor :option_type

    def self.from_json_data(data)
      out = AssetOptionFieldSelectValueChoiceAttachedAssetControl.new
      out.using = "attached_asset_control"
      out.control = Datasworn::from_json_data(DictKey, data["control"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.option_type = Datasworn::from_json_data(AssetOptionFieldSelectValueChoiceAttachedAssetControlOptionType, data["option_type"])
      out
    end

    def to_json_data
      data = { "using" => "attached_asset_control" }
      data["control"] = Datasworn::to_json_data(control)
      data["label"] = Datasworn::to_json_data(label)
      data["option_type"] = Datasworn::to_json_data(option_type)
      data
    end
  end

  class AssetOptionFieldSelectValueChoiceAttachedAssetOptionOptionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    OPTION = new("option")

    def self.from_json_data(data)
      {
        "option" => OPTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class AssetOptionFieldSelectValueChoiceAttachedAssetOption < AssetOptionFieldSelectValueChoice
    attr_accessor :label
    attr_accessor :option
    attr_accessor :option_type

    def self.from_json_data(data)
      out = AssetOptionFieldSelectValueChoiceAttachedAssetOption.new
      out.using = "attached_asset_option"
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.option = Datasworn::from_json_data(DictKey, data["option"])
      out.option_type = Datasworn::from_json_data(AssetOptionFieldSelectValueChoiceAttachedAssetOptionOptionType, data["option_type"])
      out
    end

    def to_json_data
      data = { "using" => "attached_asset_option" }
      data["label"] = Datasworn::to_json_data(label)
      data["option"] = Datasworn::to_json_data(option)
      data["option_type"] = Datasworn::to_json_data(option_type)
      data
    end
  end

  class AssetOptionFieldSelectValueChoiceConditionMeterOptionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    OPTION = new("option")

    def self.from_json_data(data)
      {
        "option" => OPTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class AssetOptionFieldSelectValueChoiceConditionMeter < AssetOptionFieldSelectValueChoice
    attr_accessor :condition_meter
    attr_accessor :label
    attr_accessor :option_type

    def self.from_json_data(data)
      out = AssetOptionFieldSelectValueChoiceConditionMeter.new
      out.using = "condition_meter"
      out.condition_meter = Datasworn::from_json_data(ConditionMeterKey, data["condition_meter"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.option_type = Datasworn::from_json_data(AssetOptionFieldSelectValueChoiceConditionMeterOptionType, data["option_type"])
      out
    end

    def to_json_data
      data = { "using" => "condition_meter" }
      data["condition_meter"] = Datasworn::to_json_data(condition_meter)
      data["label"] = Datasworn::to_json_data(label)
      data["option_type"] = Datasworn::to_json_data(option_type)
      data
    end
  end

  class AssetOptionFieldSelectValueChoiceCustomOptionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    OPTION = new("option")

    def self.from_json_data(data)
      {
        "option" => OPTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class AssetOptionFieldSelectValueChoiceCustom < AssetOptionFieldSelectValueChoice
    attr_accessor :label
    attr_accessor :option_type
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetOptionFieldSelectValueChoiceCustom.new
      out.using = "custom"
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.option_type = Datasworn::from_json_data(AssetOptionFieldSelectValueChoiceCustomOptionType, data["option_type"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out
    end

    def to_json_data
      data = { "using" => "custom" }
      data["label"] = Datasworn::to_json_data(label)
      data["option_type"] = Datasworn::to_json_data(option_type)
      data["value"] = Datasworn::to_json_data(value)
      data
    end
  end

  class AssetOptionFieldSelectValueChoiceStatOptionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    OPTION = new("option")

    def self.from_json_data(data)
      {
        "option" => OPTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class AssetOptionFieldSelectValueChoiceStat < AssetOptionFieldSelectValueChoice
    attr_accessor :label
    attr_accessor :option_type
    attr_accessor :stat

    def self.from_json_data(data)
      out = AssetOptionFieldSelectValueChoiceStat.new
      out.using = "stat"
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.option_type = Datasworn::from_json_data(AssetOptionFieldSelectValueChoiceStatOptionType, data["option_type"])
      out.stat = Datasworn::from_json_data(StatKey, data["stat"])
      out
    end

    def to_json_data
      data = { "using" => "stat" }
      data["label"] = Datasworn::to_json_data(label)
      data["option_type"] = Datasworn::to_json_data(option_type)
      data["stat"] = Datasworn::to_json_data(stat)
      data
    end
  end

  # Represents a list of mutually exclusive choices.
  class AssetOptionFieldSelectValue < AssetOptionField
    attr_accessor :choices
    attr_accessor :id
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetOptionFieldSelectValue.new
      out.field_type = "select_value"
      out.choices = Datasworn::from_json_data(Hash[String, AssetOptionFieldSelectValueChoice], data["choices"])
      out.id = Datasworn::from_json_data(AssetOptionFieldID, data["id"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(DictKey, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "select_value" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["id"] = Datasworn::to_json_data(id)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # Represents an input that accepts plain text.
  class AssetOptionFieldText < AssetOptionField
    attr_accessor :id
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetOptionFieldText.new
      out.field_type = "text"
      out.id = Datasworn::from_json_data(AssetOptionFieldID, data["id"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(String, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "text" }
      data["id"] = Datasworn::to_json_data(id)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A unique ID for an AssetOptionField.
  class AssetOptionFieldID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetOptionFieldID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded ID that can be used to match multiple AssetOptionFields.
  class AssetOptionFieldIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetOptionFieldIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class AssetType
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The primary name/label for this item.
    attr_accessor :name

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this collection.
    attr_accessor :color
    attr_accessor :contents

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This collection's content enhances the identified collection, rather than
    # being a standalone collection of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This collection replaces the identified collection. References to the
    # replaced collection can be considered equivalent to this collection.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary

    def self.from_json_data(data)
      out = AssetType.new
      out.id = Datasworn::from_json_data(AssetTypeID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.contents = Datasworn::from_json_data(Hash[String, Asset], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(AssetTypeID, data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(AssetTypeID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out
    end

    def to_json_data
      data = {}
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["source"] = Datasworn::to_json_data(source)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["contents"] = Datasworn::to_json_data(contents) unless contents.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data
    end
  end

  # A unique ID for an AssetType.
  class AssetTypeID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetTypeID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class Atlas
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The primary name/label for this item.
    attr_accessor :name

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :collections

    # A thematic color associated with this collection.
    attr_accessor :color
    attr_accessor :contents

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This collection's content enhances the identified collection, rather than
    # being a standalone collection of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This collection replaces the identified collection. References to the
    # replaced collection can be considered equivalent to this collection.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary

    def self.from_json_data(data)
      out = Atlas.new
      out.id = Datasworn::from_json_data(AtlasID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.collections = Datasworn::from_json_data(Hash[String, Atlas], data["collections"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.contents = Datasworn::from_json_data(Hash[String, AtlasEntry], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(AtlasID, data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(AtlasID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out
    end

    def to_json_data
      data = {}
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["source"] = Datasworn::to_json_data(source)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["collections"] = Datasworn::to_json_data(collections) unless collections.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["contents"] = Datasworn::to_json_data(contents) unless contents.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data
    end
  end

  # An atlas entry, like the Ironlands region entries found in classic
  # Ironsworn.
  class AtlasEntry
    attr_accessor :description
    attr_accessor :features

    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The primary name/label for this item.
    attr_accessor :name
    attr_accessor :quest_starter

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :your_truth

    def self.from_json_data(data)
      out = AtlasEntry.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.features = Datasworn::from_json_data(Array[MarkdownString], data["features"])
      out.id = Datasworn::from_json_data(AtlasEntryID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.quest_starter = Datasworn::from_json_data(MarkdownString, data["quest_starter"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.your_truth = Datasworn::from_json_data(MarkdownString, data["your_truth"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["features"] = Datasworn::to_json_data(features)
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["quest_starter"] = Datasworn::to_json_data(quest_starter)
      data["source"] = Datasworn::to_json_data(source)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["your_truth"] = Datasworn::to_json_data(your_truth) unless your_truth.nil?
      data
    end
  end

  # A unique ID for an AtlasEntry.
  class AtlasEntryID
    attr_accessor :value

    def self.from_json_data(data)
      out = AtlasEntryID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded ID that can be used to match multiple AtlasEntrys.
  class AtlasEntryIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AtlasEntryIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID for an Atlas.
  class AtlasID
    attr_accessor :value

    def self.from_json_data(data)
      out = AtlasID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded ID that can be used to match multiple Atlass.
  class AtlasIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AtlasIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Challenge rank, represented as an integer from 1 (troublesome) to 5 (epic).
  class ChallengeRank
    attr_accessor :value

    def self.from_json_data(data)
      out = ChallengeRank.new
      out.value = Datasworn.from_json_data(Integer, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A basic, rollable player character resource specified by the ruleset.
  class ConditionMeterKey
    attr_accessor :value

    def self.from_json_data(data)
      out = ConditionMeterKey.new
      out.value = Datasworn.from_json_data(DictKey, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Describes a standard player character condition meter.
  class ConditionMeterRule
    # A description of this condition meter.
    attr_accessor :description
    attr_accessor :label

    # The maximum value of this meter.
    attr_accessor :max

    # The minimum value of this meter.
    attr_accessor :min

    # Is this condition meter shared by all players?
    attr_accessor :shared

    # The current value of this meter.
    attr_accessor :value

    def self.from_json_data(data)
      out = ConditionMeterRule.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.shared = Datasworn::from_json_data(TrueClass, data["shared"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["shared"] = Datasworn::to_json_data(shared)
      data["value"] = Datasworn::to_json_data(value)
      data
    end
  end

  # A unique ID for a ConditionMeterRule.
  class ConditionMeterRuleID
    attr_accessor :value

    def self.from_json_data(data)
      out = ConditionMeterRuleID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A CSS color value. See: https://developer.mozilla.org/en-
  # US/docs/Web/CSS/color_value
  class CSSColor
    attr_accessor :value

    def self.from_json_data(data)
      out = CSSColor.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A delve site with a theme, domain, and denizens.
  class DelveSite
    attr_accessor :denizens
    attr_accessor :description
    attr_accessor :domain

    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The primary name/label for this item.
    attr_accessor :name
    attr_accessor :rank

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source
    attr_accessor :theme

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # An additional theme or domain card ID, for use with optional rules in
    # Ironsworn: Delve.
    attr_accessor :extra_card
    attr_accessor :icon

    # The ID of an atlas entry representing the region in which this delve site
    # is located.
    attr_accessor :region
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = DelveSite.new
      out.denizens = Datasworn::from_json_data(Array[DelveSiteDenizen], data["denizens"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.domain = Datasworn::from_json_data(DelveSiteDomainID, data["domain"])
      out.id = Datasworn::from_json_data(DelveSiteID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rank = Datasworn::from_json_data(ChallengeRank, data["rank"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.theme = Datasworn::from_json_data(DelveSiteThemeID, data["theme"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.extra_card = Datasworn::from_json_data(String, data["extra_card"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.region = Datasworn::from_json_data(AtlasEntryID, data["region"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["denizens"] = Datasworn::to_json_data(denizens)
      data["description"] = Datasworn::to_json_data(description)
      data["domain"] = Datasworn::to_json_data(domain)
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["rank"] = Datasworn::to_json_data(rank)
      data["source"] = Datasworn::to_json_data(source)
      data["theme"] = Datasworn::to_json_data(theme)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["extra_card"] = Datasworn::to_json_data(extra_card) unless extra_card.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["region"] = Datasworn::to_json_data(region) unless region.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  class DelveSiteDenizen
    attr_accessor :frequency

    # The unique Datasworn ID for this item.
    attr_accessor :id
    attr_accessor :max
    attr_accessor :min
    attr_accessor :name

    # The ID of the relevant NPC entry, if one is specified.
    attr_accessor :npc

    def self.from_json_data(data)
      out = DelveSiteDenizen.new
      out.frequency = Datasworn::from_json_data(DelveSiteDenizenFrequency, data["frequency"])
      out.id = Datasworn::from_json_data(DelveSiteDenizenID, data["id"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.npc = Datasworn::from_json_data(NpcID, data["npc"])
      out
    end

    def to_json_data
      data = {}
      data["frequency"] = Datasworn::to_json_data(frequency)
      data["id"] = Datasworn::to_json_data(id)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["name"] = Datasworn::to_json_data(name) unless name.nil?
      data["npc"] = Datasworn::to_json_data(npc) unless npc.nil?
      data
    end
  end

  class DelveSiteDenizenFrequency
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    COMMON = new("common")
    RARE = new("rare")
    UNCOMMON = new("uncommon")
    UNFORESEEN = new("unforeseen")
    VERY_COMMON = new("very_common")

    def self.from_json_data(data)
      {
        "common" => COMMON,
        "rare" => RARE,
        "uncommon" => UNCOMMON,
        "unforeseen" => UNFORESEEN,
        "very_common" => VERY_COMMON,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A unique ID for a DelveSiteDenizen.
  class DelveSiteDenizenID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteDenizenID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A delve site Domain card.
  class DelveSiteDomain
    attr_accessor :dangers
    attr_accessor :features

    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The primary name/label for this item.
    attr_accessor :name

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source
    attr_accessor :summary

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :description
    attr_accessor :icon

    # An oracle table ID containing place name elements. For examples, see
    # oracle ID `delve/oracles/site_name/place/barrow`, and its siblings in
    # oracle collection ID `delve/collections/oracles/site_name/place`. These
    # oracles are used by the site name oracle from Ironsworn: Delve (ID:
    # delve/oracles/site_name/format) to create random names for delve sites.
    attr_accessor :name_oracle
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = DelveSiteDomain.new
      out.dangers = Datasworn::from_json_data(Array[DelveSiteDomainDangerRow], data["dangers"])
      out.features = Datasworn::from_json_data(Array[DelveSiteDomainFeatureRow], data["features"])
      out.id = Datasworn::from_json_data(DelveSiteDomainID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.name_oracle = Datasworn::from_json_data(OracleTableID, data["name_oracle"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["dangers"] = Datasworn::to_json_data(dangers)
      data["features"] = Datasworn::to_json_data(features)
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["source"] = Datasworn::to_json_data(source)
      data["summary"] = Datasworn::to_json_data(summary)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["name_oracle"] = Datasworn::to_json_data(name_oracle) unless name_oracle.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  # Represents a single Danger entry from a delve site Domain card.
  class DelveSiteDomainDangerRow
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # High end of the dice range for this table row.
    attr_accessor :max

    # Low end of the dice range for this table row.
    attr_accessor :min

    # The primary text content of this row.
    attr_accessor :result

    # Optional tertiary text content for this row. Generally, this is longer
    # than both `result` and `summary`.
    attr_accessor :description

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :i18n
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :rolls
    attr_accessor :suggestions

    # Optional secondary text content for this row. Generally, this is longer
    # than `result`.
    attr_accessor :summary
    attr_accessor :template

    def self.from_json_data(data)
      out = DelveSiteDomainDangerRow.new
      out.id = Datasworn::from_json_data(DomainDangerRowID, data["id"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.result = Datasworn::from_json_data(MarkdownString, data["result"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.embed_table = Datasworn::from_json_data(OracleTableID, data["embed_table"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["i18n"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.rolls = Datasworn::from_json_data(Array[OracleTableRoll], data["rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["id"] = Datasworn::to_json_data(id)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["result"] = Datasworn::to_json_data(result)
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["rolls"] = Datasworn::to_json_data(rolls) unless rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # Represents a single Feature entry from a delve site Domain card.
  class DelveSiteDomainFeatureRow
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # High end of the dice range for this table row.
    attr_accessor :max

    # Low end of the dice range for this table row.
    attr_accessor :min

    # The primary text content of this row.
    attr_accessor :result

    # Optional tertiary text content for this row. Generally, this is longer
    # than both `result` and `summary`.
    attr_accessor :description

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :i18n
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :rolls
    attr_accessor :suggestions

    # Optional secondary text content for this row. Generally, this is longer
    # than `result`.
    attr_accessor :summary
    attr_accessor :template

    def self.from_json_data(data)
      out = DelveSiteDomainFeatureRow.new
      out.id = Datasworn::from_json_data(DomainFeatureRowID, data["id"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.result = Datasworn::from_json_data(MarkdownString, data["result"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.embed_table = Datasworn::from_json_data(OracleTableID, data["embed_table"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["i18n"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.rolls = Datasworn::from_json_data(Array[OracleTableRoll], data["rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["id"] = Datasworn::to_json_data(id)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["result"] = Datasworn::to_json_data(result)
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["rolls"] = Datasworn::to_json_data(rolls) unless rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # A unique ID for a DelveSiteDomain.
  class DelveSiteDomainID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteDomainID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID for a DelveSite.
  class DelveSiteID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A delve site theme card.
  class DelveSiteTheme
    attr_accessor :dangers
    attr_accessor :features

    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The primary name/label for this item.
    attr_accessor :name

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source
    attr_accessor :summary

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :description
    attr_accessor :icon
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = DelveSiteTheme.new
      out.dangers = Datasworn::from_json_data(Array[DelveSiteThemeDangerRow], data["dangers"])
      out.features = Datasworn::from_json_data(Array[DelveSiteThemeFeatureRow], data["features"])
      out.id = Datasworn::from_json_data(DelveSiteThemeID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["dangers"] = Datasworn::to_json_data(dangers)
      data["features"] = Datasworn::to_json_data(features)
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["source"] = Datasworn::to_json_data(source)
      data["summary"] = Datasworn::to_json_data(summary)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  # Represents a single Danger entry from a delve site Theme card.
  class DelveSiteThemeDangerRow
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # High end of the dice range for this table row.
    attr_accessor :max

    # Low end of the dice range for this table row.
    attr_accessor :min

    # The primary text content of this row.
    attr_accessor :result

    # Optional tertiary text content for this row. Generally, this is longer
    # than both `result` and `summary`.
    attr_accessor :description

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :i18n
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :rolls
    attr_accessor :suggestions

    # Optional secondary text content for this row. Generally, this is longer
    # than `result`.
    attr_accessor :summary
    attr_accessor :template

    def self.from_json_data(data)
      out = DelveSiteThemeDangerRow.new
      out.id = Datasworn::from_json_data(ThemeDangerRowID, data["id"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.result = Datasworn::from_json_data(MarkdownString, data["result"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.embed_table = Datasworn::from_json_data(OracleTableID, data["embed_table"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["i18n"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.rolls = Datasworn::from_json_data(Array[OracleTableRoll], data["rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["id"] = Datasworn::to_json_data(id)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["result"] = Datasworn::to_json_data(result)
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["rolls"] = Datasworn::to_json_data(rolls) unless rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # Represents a single Feature entry from a delve site Theme card.
  class DelveSiteThemeFeatureRow
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # High end of the dice range for this table row.
    attr_accessor :max

    # Low end of the dice range for this table row.
    attr_accessor :min

    # The primary text content of this row.
    attr_accessor :result

    # Optional tertiary text content for this row. Generally, this is longer
    # than both `result` and `summary`.
    attr_accessor :description

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :i18n
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :rolls
    attr_accessor :suggestions

    # Optional secondary text content for this row. Generally, this is longer
    # than `result`.
    attr_accessor :summary
    attr_accessor :template

    def self.from_json_data(data)
      out = DelveSiteThemeFeatureRow.new
      out.id = Datasworn::from_json_data(ThemeFeatureRowID, data["id"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.result = Datasworn::from_json_data(MarkdownString, data["result"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.embed_table = Datasworn::from_json_data(OracleTableID, data["embed_table"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["i18n"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.rolls = Datasworn::from_json_data(Array[OracleTableRoll], data["rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["id"] = Datasworn::to_json_data(id)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["result"] = Datasworn::to_json_data(result)
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["rolls"] = Datasworn::to_json_data(rolls) unless rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # A unique ID for a DelveSiteTheme.
  class DelveSiteThemeID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteThemeID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A simple dice roll expression with an optional modifer.
  class DiceExpression
    attr_accessor :value

    def self.from_json_data(data)
      out = DiceExpression.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A key used in a Datasworn dictionary object.
  class DictKey
    attr_accessor :value

    def self.from_json_data(data)
      out = DictKey.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID for a DomainDangerRow.
  class DomainDangerRowID
    attr_accessor :value

    def self.from_json_data(data)
      out = DomainDangerRowID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID for a DomainFeatureRow.
  class DomainFeatureRowID
    attr_accessor :value

    def self.from_json_data(data)
      out = DomainFeatureRowID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # The ID of a Datasworn package that relies on an external package to provide
  # its ruleset.
  class ExpansionID
    attr_accessor :value

    def self.from_json_data(data)
      out = ExpansionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class I18nHint
    attr_accessor :part_of_speech

    def self.from_json_data(data)
      out = I18nHint.new
      out.part_of_speech = Datasworn::from_json_data(PartOfSpeech, data["part_of_speech"])
      out
    end

    def to_json_data
      data = {}
      data["part_of_speech"] = Datasworn::to_json_data(part_of_speech) unless part_of_speech.nil?
      data
    end
  end

  class I18nHintsTemplate
    attr_accessor :description
    attr_accessor :result
    attr_accessor :summary

    def self.from_json_data(data)
      out = I18nHintsTemplate.new
      out.description = Datasworn::from_json_data(I18nHint, data["description"])
      out.result = Datasworn::from_json_data(I18nHint, data["result"])
      out.summary = Datasworn::from_json_data(I18nHint, data["summary"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["result"] = Datasworn::to_json_data(result) unless result.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data
    end
  end

  # Internationalization/localization hints for the text content of this object.
  class I18nHints
    attr_accessor :description
    attr_accessor :result
    attr_accessor :summary
    attr_accessor :template

    def self.from_json_data(data)
      out = I18nHints.new
      out.description = Datasworn::from_json_data(I18nHint, data["description"])
      out.result = Datasworn::from_json_data(I18nHint, data["result"])
      out.summary = Datasworn::from_json_data(I18nHint, data["summary"])
      out.template = Datasworn::from_json_data(I18nHintsTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["result"] = Datasworn::to_json_data(result) unless result.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # Describes a category of standard impacts/debilities.
  class ImpactCategory
    # A dictionary object of the Impacts in this category.
    attr_accessor :contents

    # A description of this impact category.
    attr_accessor :description

    # A label for this impact category.
    attr_accessor :label

    def self.from_json_data(data)
      out = ImpactCategory.new
      out.contents = Datasworn::from_json_data(Hash[String, ImpactRule], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out
    end

    def to_json_data
      data = {}
      data["contents"] = Datasworn::to_json_data(contents)
      data["description"] = Datasworn::to_json_data(description)
      data["label"] = Datasworn::to_json_data(label)
      data
    end
  end

  # Describes a standard impact/debility.
  class ImpactRule
    # A description of this impact.
    attr_accessor :description

    # The label for this impact.
    attr_accessor :label

    # Is this impact permanent?
    attr_accessor :permanent

    # Any ruleset condition meters that can't recover when this impact is
    # active.
    attr_accessor :prevents_recovery

    # Is this impact applied to all players at once?
    attr_accessor :shared

    def self.from_json_data(data)
      out = ImpactRule.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.permanent = Datasworn::from_json_data(TrueClass, data["permanent"])
      out.prevents_recovery = Datasworn::from_json_data(Array[ConditionMeterKey], data["prevents_recovery"])
      out.shared = Datasworn::from_json_data(TrueClass, data["shared"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["label"] = Datasworn::to_json_data(label)
      data["permanent"] = Datasworn::to_json_data(permanent)
      data["prevents_recovery"] = Datasworn::to_json_data(prevents_recovery)
      data["shared"] = Datasworn::to_json_data(shared)
      data
    end
  end

  # A unique ID for an ImpactRuleCollection.
  class ImpactRuleCollectionID
    attr_accessor :value

    def self.from_json_data(data)
      out = ImpactRuleCollectionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID for an ImpactRule.
  class ImpactRuleID
    attr_accessor :value

    def self.from_json_data(data)
      out = ImpactRuleID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A localized label for an input. In some contexts it may be undesirable to
  # render this text, but it should always be exposed to assistive technology
  # (e.g. with `aria-label` in HTML).
  class InputLabel
    attr_accessor :value

    def self.from_json_data(data)
      out = InputLabel.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A localized plain text name or label.
  class Label
    attr_accessor :value

    def self.from_json_data(data)
      out = Label.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Localized text, formatted in Markdown.
  # 
  # It uses some custom syntax; e.g. `{{table:some_oracle_table_id}}` indicates
  # that the referenced oracle table is rendered there part of the source
  # material.
  class MarkdownString
    attr_accessor :value

    def self.from_json_data(data)
      out = MarkdownString.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class Move
    attr_accessor :roll_type

    def self.from_json_data(data)
      {
        "action_roll" => MoveActionRoll,
        "no_roll" => MoveNoRoll,
        "progress_roll" => MoveProgressRoll,
        "special_track" => MoveSpecialTrack,
      }[data["roll_type"]].from_json_data(data)
    end
  end

  # A move that makes an action roll.
  class MoveActionRoll < Move
    attr_accessor :id
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :source
    attr_accessor :text
    attr_accessor :trigger
    attr_accessor :canonical_name
    attr_accessor :oracles
    attr_accessor :replaces
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = MoveActionRoll.new
      out.roll_type = "action_roll"
      out.id = Datasworn::from_json_data(MoveID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerActionRoll, data["trigger"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.oracles = Datasworn::from_json_data(Array[OracleTableID], data["oracles"])
      out.replaces = Datasworn::from_json_data(MoveID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = { "roll_type" => "action_roll" }
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["source"] = Datasworn::to_json_data(source)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  # A move that makes no progress rolls or action rolls.
  class MoveNoRoll < Move
    attr_accessor :id
    attr_accessor :name
    attr_accessor :source
    attr_accessor :text
    attr_accessor :trigger
    attr_accessor :canonical_name
    attr_accessor :oracles
    attr_accessor :replaces
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = MoveNoRoll.new
      out.roll_type = "no_roll"
      out.id = Datasworn::from_json_data(MoveID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerNoRoll, data["trigger"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.oracles = Datasworn::from_json_data(Array[OracleTableID], data["oracles"])
      out.replaces = Datasworn::from_json_data(MoveID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = { "roll_type" => "no_roll" }
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["source"] = Datasworn::to_json_data(source)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  # A progress move that rolls on a standard progress track type (whose features
  # are defined by this move object). For progress rolls that use special
  # tracks, see MoveSpecialTrack.
  class MoveProgressRoll < Move
    attr_accessor :id
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :source
    attr_accessor :text
    attr_accessor :tracks
    attr_accessor :trigger
    attr_accessor :canonical_name
    attr_accessor :oracles
    attr_accessor :replaces
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = MoveProgressRoll.new
      out.roll_type = "progress_roll"
      out.id = Datasworn::from_json_data(MoveID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.tracks = Datasworn::from_json_data(ProgressTrackTypeInfo, data["tracks"])
      out.trigger = Datasworn::from_json_data(TriggerProgressRoll, data["trigger"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.oracles = Datasworn::from_json_data(Array[OracleTableID], data["oracles"])
      out.replaces = Datasworn::from_json_data(MoveID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = { "roll_type" => "progress_roll" }
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["source"] = Datasworn::to_json_data(source)
      data["text"] = Datasworn::to_json_data(text)
      data["tracks"] = Datasworn::to_json_data(tracks)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  # A progress move that rolls on a special track, such as Legacies (Starforged)
  # or Bonds (classic Ironsworn). For progress moves that use standard progress
  # tracks, see MoveProgressRoll instead.
  class MoveSpecialTrack < Move
    attr_accessor :id
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :source
    attr_accessor :text
    attr_accessor :trigger
    attr_accessor :canonical_name
    attr_accessor :oracles
    attr_accessor :replaces
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = MoveSpecialTrack.new
      out.roll_type = "special_track"
      out.id = Datasworn::from_json_data(MoveID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerSpecialTrack, data["trigger"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.oracles = Datasworn::from_json_data(Array[OracleTableID], data["oracles"])
      out.replaces = Datasworn::from_json_data(MoveID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = { "roll_type" => "special_track" }
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["source"] = Datasworn::to_json_data(source)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  class MoveCategory
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The primary name/label for this item.
    attr_accessor :name

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this collection.
    attr_accessor :color
    attr_accessor :contents

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This collection's content enhances the identified collection, rather than
    # being a standalone collection of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This collection replaces the identified collection. References to the
    # replaced collection can be considered equivalent to this collection.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary

    def self.from_json_data(data)
      out = MoveCategory.new
      out.id = Datasworn::from_json_data(MoveCategoryID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.contents = Datasworn::from_json_data(Hash[String, Move], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(MoveCategoryID, data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(MoveCategoryID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out
    end

    def to_json_data
      data = {}
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["source"] = Datasworn::to_json_data(source)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["contents"] = Datasworn::to_json_data(contents) unless contents.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data
    end
  end

  # A unique ID for a MoveCategory.
  class MoveCategoryID
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveCategoryID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class MoveEnhancement
    attr_accessor :roll_type

    def self.from_json_data(data)
      {
        "action_roll" => MoveEnhancementActionRoll,
        "no_roll" => MoveEnhancementNoRoll,
        "progress_roll" => MoveEnhancementProgressRoll,
        "special_track" => MoveEnhancementSpecialTrack,
      }[data["roll_type"]].from_json_data(data)
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveEnhancementActionRoll < MoveEnhancement
    attr_accessor :enhances
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveEnhancementActionRoll.new
      out.roll_type = "action_roll"
      out.enhances = Datasworn::from_json_data(Array[MoveIDWildcard], data["enhances"])
      out.trigger = Datasworn::from_json_data(TriggerActionRollEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = { "roll_type" => "action_roll" }
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveEnhancementNoRoll < MoveEnhancement
    attr_accessor :enhances
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveEnhancementNoRoll.new
      out.roll_type = "no_roll"
      out.enhances = Datasworn::from_json_data(Array[MoveIDWildcard], data["enhances"])
      out.trigger = Datasworn::from_json_data(TriggerNoRollEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = { "roll_type" => "no_roll" }
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveEnhancementProgressRoll < MoveEnhancement
    attr_accessor :enhances
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveEnhancementProgressRoll.new
      out.roll_type = "progress_roll"
      out.enhances = Datasworn::from_json_data(Array[MoveIDWildcard], data["enhances"])
      out.trigger = Datasworn::from_json_data(TriggerProgressRollEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = { "roll_type" => "progress_roll" }
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveEnhancementSpecialTrack < MoveEnhancement
    attr_accessor :enhances
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveEnhancementSpecialTrack.new
      out.roll_type = "special_track"
      out.enhances = Datasworn::from_json_data(Array[MoveIDWildcard], data["enhances"])
      out.trigger = Datasworn::from_json_data(TriggerSpecialTrackEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = { "roll_type" => "special_track" }
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  # A move ID, for a standard move or a unique asset move
  class MoveID
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A move ID with wildcards.
  class MoveIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class MoveOutcome
    attr_accessor :text

    def self.from_json_data(data)
      out = MoveOutcome.new
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class MoveOutcomeType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # The score doesn't beat either challenge die.
    MISS = new("miss")

    # The score is greater than both challenge dice.
    STRONG_HIT = new("strong_hit")

    # The score is greater than one challenge die.
    WEAK_HIT = new("weak_hit")

    def self.from_json_data(data)
      {
        "miss" => MISS,
        "strong_hit" => STRONG_HIT,
        "weak_hit" => WEAK_HIT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A standalone localized description for each move outcome (miss, weak hit,
  # or strong hit). This is for for e.g. VTT implementations, where it's often
  # useful to display only the rules text relevant to a roll result.
  # 
  #   This often requires light editorialization to create text that can stand
  # alone without reference to the rest of the move. For example, 'as above'
  # (in reference to another move outcome) shouldn't be used here; instead, the
  # relevant text should be repeated.
  class MoveOutcomes
    attr_accessor :miss
    attr_accessor :strong_hit
    attr_accessor :weak_hit

    def self.from_json_data(data)
      out = MoveOutcomes.new
      out.miss = Datasworn::from_json_data(MoveOutcome, data["miss"])
      out.strong_hit = Datasworn::from_json_data(MoveOutcome, data["strong_hit"])
      out.weak_hit = Datasworn::from_json_data(MoveOutcome, data["weak_hit"])
      out
    end

    def to_json_data
      data = {}
      data["miss"] = Datasworn::to_json_data(miss)
      data["strong_hit"] = Datasworn::to_json_data(strong_hit)
      data["weak_hit"] = Datasworn::to_json_data(weak_hit)
      data
    end
  end

  class MoveRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # A move that makes an action roll.
    ACTION_ROLL = new("action_roll")

    # A move that makes no action rolls or progress rolls.
    NO_ROLL = new("no_roll")

    # A progress move that rolls on a standard progress track type (defined by
    # this move).
    PROGRESS_ROLL = new("progress_roll")

    # A progress move that rolls on one or more special tracks, like Bonds
    # (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    SPECIAL_TRACK = new("special_track")

    def self.from_json_data(data)
      {
        "action_roll" => ACTION_ROLL,
        "no_roll" => NO_ROLL,
        "progress_roll" => PROGRESS_ROLL,
        "special_track" => SPECIAL_TRACK,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A non-player character entry, similar to those in Chapter 5 of the Ironsworn
  # Rulebook, or Chapter 4 of Starforged.
  class Npc
    attr_accessor :description
    attr_accessor :drives
    attr_accessor :features

    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The primary name/label for this item.
    attr_accessor :name
    attr_accessor :nature
    attr_accessor :quest_starter

    # The suggested challenge rank for this NPC.
    attr_accessor :rank

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source
    attr_accessor :tactics

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :variants
    attr_accessor :your_truth

    def self.from_json_data(data)
      out = Npc.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.drives = Datasworn::from_json_data(Array[MarkdownString], data["drives"])
      out.features = Datasworn::from_json_data(Array[MarkdownString], data["features"])
      out.id = Datasworn::from_json_data(NpcID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.nature = Datasworn::from_json_data(NpcNature, data["nature"])
      out.quest_starter = Datasworn::from_json_data(MarkdownString, data["quest_starter"])
      out.rank = Datasworn::from_json_data(ChallengeRank, data["rank"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.tactics = Datasworn::from_json_data(Array[MarkdownString], data["tactics"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.variants = Datasworn::from_json_data(Hash[String, NpcVariant], data["variants"])
      out.your_truth = Datasworn::from_json_data(MarkdownString, data["your_truth"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["drives"] = Datasworn::to_json_data(drives)
      data["features"] = Datasworn::to_json_data(features)
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["nature"] = Datasworn::to_json_data(nature)
      data["quest_starter"] = Datasworn::to_json_data(quest_starter)
      data["rank"] = Datasworn::to_json_data(rank)
      data["source"] = Datasworn::to_json_data(source)
      data["tactics"] = Datasworn::to_json_data(tactics)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["variants"] = Datasworn::to_json_data(variants) unless variants.nil?
      data["your_truth"] = Datasworn::to_json_data(your_truth) unless your_truth.nil?
      data
    end
  end

  class NpcCollection
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The primary name/label for this item.
    attr_accessor :name

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this collection.
    attr_accessor :color
    attr_accessor :contents

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This collection's content enhances the identified collection, rather than
    # being a standalone collection of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This collection replaces the identified collection. References to the
    # replaced collection can be considered equivalent to this collection.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary

    def self.from_json_data(data)
      out = NpcCollection.new
      out.id = Datasworn::from_json_data(NpcCollectionID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.contents = Datasworn::from_json_data(Hash[String, Npc], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(NpcCollectionID, data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(NpcCollectionID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out
    end

    def to_json_data
      data = {}
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["source"] = Datasworn::to_json_data(source)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["contents"] = Datasworn::to_json_data(contents) unless contents.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data
    end
  end

  # A unique ID for a NpcCollection.
  class NpcCollectionID
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcCollectionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID for a Npc.
  class NpcID
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded ID that can be used to match multiple Npcs.
  class NpcIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A localized category label describing the nature of this NPC.
  # 
  # In Ironsworn classic, this is probably the singular form of the parent
  # collection's name.
  # 
  # For Starforged, see the table on p. 258 for examples.
  class NpcNature
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcNature.new
      out.value = Datasworn.from_json_data(Label, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class NpcVariant
    attr_accessor :description

    # The unique Datasworn ID for this item.
    attr_accessor :id
    attr_accessor :name
    attr_accessor :nature

    # The suggested challenge rank for this NPC.
    attr_accessor :rank
    attr_accessor :summary

    def self.from_json_data(data)
      out = NpcVariant.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.id = Datasworn::from_json_data(NpcVariantID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.nature = Datasworn::from_json_data(NpcNature, data["nature"])
      out.rank = Datasworn::from_json_data(ChallengeRank, data["rank"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["nature"] = Datasworn::to_json_data(nature)
      data["rank"] = Datasworn::to_json_data(rank)
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data
    end
  end

  # A unique ID for a NpcVariant.
  class NpcVariantID
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcVariantID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class OracleCollection
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The primary name/label for this item.
    attr_accessor :name

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :collections

    # A thematic color associated with this collection.
    attr_accessor :color
    attr_accessor :contents

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This collection's content enhances the identified collection, rather than
    # being a standalone collection of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :rendering

    # This collection replaces the identified collection. References to the
    # replaced collection can be considered equivalent to this collection.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary

    def self.from_json_data(data)
      out = OracleCollection.new
      out.id = Datasworn::from_json_data(OracleCollectionID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.collections = Datasworn::from_json_data(Hash[String, OracleCollection], data["collections"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleTable], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(OracleCollectionID, data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.rendering = Datasworn::from_json_data(OracleCollectionRendering, data["rendering"])
      out.replaces = Datasworn::from_json_data(OracleCollectionID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out
    end

    def to_json_data
      data = {}
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["source"] = Datasworn::to_json_data(source)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["collections"] = Datasworn::to_json_data(collections) unless collections.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["contents"] = Datasworn::to_json_data(contents) unless contents.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["rendering"] = Datasworn::to_json_data(rendering) unless rendering.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data
    end
  end

  # A unique ID for an OracleCollection.
  class OracleCollectionID
    attr_accessor :value

    def self.from_json_data(data)
      out = OracleCollectionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Describes the presentation of this oracle collection, which might represent
  # a group of separate tables, or a single table with additional columns.
  class OracleCollectionRendering
    attr_accessor :style

    def self.from_json_data(data)
      {
        "multi_table" => OracleCollectionRenderingMultiTable,
        "tables" => OracleCollectionRenderingTables,
      }[data["style"]].from_json_data(data)
    end
  end

  class OracleCollectionRenderingMultiTable < OracleCollectionRendering
    attr_accessor :columns

    def self.from_json_data(data)
      out = OracleCollectionRenderingMultiTable.new
      out.style = "multi_table"
      out.columns = Datasworn::from_json_data(Hash[String, OracleCollectionTableColumn], data["columns"])
      out
    end

    def to_json_data
      data = { "style" => "multi_table" }
      data["columns"] = Datasworn::to_json_data(columns)
      data
    end
  end

  class OracleCollectionRenderingTables < OracleCollectionRendering

    def self.from_json_data(data)
      out = OracleCollectionRenderingTables.new
      out.style = "tables"
      out
    end

    def to_json_data
      data = { "style" => "tables" }
      data
    end
  end

  class OracleCollectionStyle
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # Presented as a single table, with its OracleTable children rendered as
    # columns.
    MULTI_TABLE = new("multi_table")

    # Presented as a collection of separate tables.
    TABLES = new("tables")

    def self.from_json_data(data)
      {
        "multi_table" => MULTI_TABLE,
        "tables" => TABLES,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleCollectionTableColumn
    attr_accessor :content_type

    # The column's header text.
    attr_accessor :label

    # The key of the OracleTable (within this collection), whose data is used to
    # render this column.
    attr_accessor :table_key

    # The thematic color for this column.
    attr_accessor :color

    def self.from_json_data(data)
      out = OracleCollectionTableColumn.new
      out.content_type = Datasworn::from_json_data(OracleTableColumnContentKey, data["content_type"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.table_key = Datasworn::from_json_data(DictKey, data["table_key"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out
    end

    def to_json_data
      data = {}
      data["content_type"] = Datasworn::to_json_data(content_type)
      data["label"] = Datasworn::to_json_data(label)
      data["table_key"] = Datasworn::to_json_data(table_key)
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data
    end
  end

  # Provides string templates that may be used in place of the static
  # row text from `OracleTableRow#result`, `OracleTableRow#summary`, and
  # `OracleTableRow#description`.
  # 
  #   These strings are formatted in Markdown, but use a special syntax
  # for their placeholders: `{{result:some_oracle_table_id}}`. The
  # placeholder should be replaced with the value of a rolled (or selected)
  # `OracleTableRow#result` from the target oracle table ID.
  class OracleRollTemplate
    # A string template that may be used in place of OracleTableRow#description.
    attr_accessor :description

    # A string template that may be used in place of OracleTableRow#result.
    attr_accessor :result

    # A string template that may be used in place of OracleTableRow#summary.
    attr_accessor :summary

    def self.from_json_data(data)
      out = OracleRollTemplate.new
      out.description = Datasworn::from_json_data(TemplateString, data["description"])
      out.result = Datasworn::from_json_data(TemplateString, data["result"])
      out.summary = Datasworn::from_json_data(TemplateString, data["summary"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["result"] = Datasworn::to_json_data(result) unless result.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data
    end
  end

  # Represents a single oracle table, or a single table column of a table that
  # has multiple "Roll" or "Result" columns.
  class OracleTable
    # The roll used to select a result on this table.
    attr_accessor :dice

    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The primary name/label for this item.
    attr_accessor :name

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source
    attr_accessor :table
    attr_accessor :i18n

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A longer description of the oracle table's intended usage, which might
    # include multiple paragraphs. If it's only a couple sentences, use the
    # `summary` key instead.
    attr_accessor :description

    # An icon that represents this table.
    attr_accessor :icon
    attr_accessor :images

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match

    # Describes how how to render this table, when presenting it as a standalone
    # table.
    attr_accessor :rendering

    # Indicates that this table replaces the identified table. References to the
    # replaced table can be considered equivalent to this table.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of the oracle table's intended usage, no more than a few
    # sentences in length. This is intended for use in application tooltips
    # and similar sorts of hints. Longer text should use the "description" key
    # instead.
    attr_accessor :summary

    def self.from_json_data(data)
      out = OracleTable.new
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.id = Datasworn::from_json_data(OracleTableID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.table = Datasworn::from_json_data(Array[OracleTableRow], data["table"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["_i18n"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.match = Datasworn::from_json_data(OracleTableMatchBehavior, data["match"])
      out.rendering = Datasworn::from_json_data(OracleTableRendering, data["rendering"])
      out.replaces = Datasworn::from_json_data(OracleTableID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out
    end

    def to_json_data
      data = {}
      data["dice"] = Datasworn::to_json_data(dice)
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["source"] = Datasworn::to_json_data(source)
      data["table"] = Datasworn::to_json_data(table)
      data["_i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["rendering"] = Datasworn::to_json_data(rendering) unless rendering.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data
    end
  end

  class OracleTableColumn
    attr_accessor :content_type

    # The column's header text.
    attr_accessor :label

    # The thematic color for this column.
    attr_accessor :color

    def self.from_json_data(data)
      out = OracleTableColumn.new
      out.content_type = Datasworn::from_json_data(OracleTableColumnContentKey, data["content_type"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out
    end

    def to_json_data
      data = {}
      data["content_type"] = Datasworn::to_json_data(content_type)
      data["label"] = Datasworn::to_json_data(label)
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data
    end
  end

  # The value(s) from each OracleTableRow that is rendered in this column.
  class OracleTableColumnContentKey
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # Column displays the OracleTableRow's `description` key.
    DESCRIPTION = new("description")

    # Column displays the OracleTableRow's `result` key.
    RESULT = new("result")

    # Column displays the roll range (`min` and `max`) of each OracleTableRow.
    ROLL = new("roll")

    # Column displays the OracleTableRow's `summary` key.
    SUMMARY = new("summary")

    def self.from_json_data(data)
      {
        "description" => DESCRIPTION,
        "result" => RESULT,
        "roll" => ROLL,
        "summary" => SUMMARY,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A unique ID for an OracleTable.
  class OracleTableID
    attr_accessor :value

    def self.from_json_data(data)
      out = OracleTableID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Oracle table wildcards can also use '**' to represent any number of
  # collection levels in the oracle tree.
  class OracleTableIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = OracleTableIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class OracleTableMatchBehavior
    attr_accessor :text

    def self.from_json_data(data)
      out = OracleTableMatchBehavior.new
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  # Describes the presentation of this table.
  class OracleTableRendering
    attr_accessor :style

    def self.from_json_data(data)
      {
        "column" => OracleTableRenderingColumn,
        "embed_in_row" => OracleTableRenderingEmbedInRow,
        "standalone" => OracleTableRenderingStandalone,
      }[data["style"]].from_json_data(data)
    end
  end

  class OracleTableRenderingColumn < OracleTableRendering

    def self.from_json_data(data)
      out = OracleTableRenderingColumn.new
      out.style = "column"
      out
    end

    def to_json_data
      data = { "style" => "column" }
      data
    end
  end

  class OracleTableRenderingEmbedInRow < OracleTableRendering

    def self.from_json_data(data)
      out = OracleTableRenderingEmbedInRow.new
      out.style = "embed_in_row"
      out
    end

    def to_json_data
      data = { "style" => "embed_in_row" }
      data
    end
  end

  class OracleTableRenderingStandalone < OracleTableRendering
    attr_accessor :columns

    def self.from_json_data(data)
      out = OracleTableRenderingStandalone.new
      out.style = "standalone"
      out.columns = Datasworn::from_json_data(Hash[String, OracleTableColumn], data["columns"])
      out
    end

    def to_json_data
      data = { "style" => "standalone" }
      data["columns"] = Datasworn::to_json_data(columns)
      data
    end
  end

  class OracleTableRoll
    # Both Ironsworn and Starforged explicitly recommend *against* rolling
    # all details at once. That said, some oracle results only provide useful
    # information once a secondary roll occurs, such as "Action + Theme".
    attr_accessor :auto
    attr_accessor :dice

    # Special rules on how the oracle table roll is performed.
    attr_accessor :method
    attr_accessor :oracle

    # The number of times to roll.
    attr_accessor :times

    def self.from_json_data(data)
      out = OracleTableRoll.new
      out.auto = Datasworn::from_json_data(TrueClass, data["auto"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.method = Datasworn::from_json_data(OracleTableRollMethod, data["method"])
      out.oracle = Datasworn::from_json_data(OracleTableID, data["oracle"])
      out.times = Datasworn::from_json_data(Integer, data["times"])
      out
    end

    def to_json_data
      data = {}
      data["auto"] = Datasworn::to_json_data(auto)
      data["dice"] = Datasworn::to_json_data(dice)
      data["method"] = Datasworn::to_json_data(method)
      data["oracle"] = Datasworn::to_json_data(oracle)
      data["times"] = Datasworn::to_json_data(times)
      data
    end
  end

  # Special roll instructions to use when rolling multiple times on a single
  # oracle table.
  class OracleTableRollMethod
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # Duplicates should be kept.
    KEEP_DUPLICATES = new("keep_duplicates")

    # Duplicates should be kept, and they compound to make things worse.
    MAKE_IT_WORSE = new("make_it_worse")

    # Duplicates should be re-rolled.
    NO_DUPLICATES = new("no_duplicates")

    def self.from_json_data(data)
      {
        "keep_duplicates" => KEEP_DUPLICATES,
        "make_it_worse" => MAKE_IT_WORSE,
        "no_duplicates" => NO_DUPLICATES,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents a row in an oracle table.
  class OracleTableRow
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # High end of the dice range for this table row.
    attr_accessor :max

    # Low end of the dice range for this table row.
    attr_accessor :min

    # The primary text content of this row.
    attr_accessor :result

    # Optional tertiary text content for this row. Generally, this is longer
    # than both `result` and `summary`.
    attr_accessor :description

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :i18n
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :rolls
    attr_accessor :suggestions

    # Optional secondary text content for this row. Generally, this is longer
    # than `result`.
    attr_accessor :summary
    attr_accessor :template

    def self.from_json_data(data)
      out = OracleTableRow.new
      out.id = Datasworn::from_json_data(OracleTableRowID, data["id"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.result = Datasworn::from_json_data(MarkdownString, data["result"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.embed_table = Datasworn::from_json_data(OracleTableID, data["embed_table"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["i18n"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.rolls = Datasworn::from_json_data(Array[OracleTableRoll], data["rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["id"] = Datasworn::to_json_data(id)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["result"] = Datasworn::to_json_data(result)
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["rolls"] = Datasworn::to_json_data(rolls) unless rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # Normally, rows will end with two numbers separated by a dash, indicating
  # their dice range.
  # 
  # Rows with a single number represent unrollable rows that are sometimes
  # included for rendering purposes; in this case, the number represents the
  # row's index.
  class OracleTableRowID
    attr_accessor :value

    def self.from_json_data(data)
      out = OracleTableRowID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class OracleTableStyle
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # Render as a single column of a table.
    COLUMN = new("column")

    # Render as a table, within a row in another table.
    EMBED_IN_ROW = new("embed_in_row")

    # Render as a standalone table.
    STANDALONE = new("standalone")

    def self.from_json_data(data)
      {
        "column" => COLUMN,
        "embed_in_row" => EMBED_IN_ROW,
        "standalone" => STANDALONE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class PartOfSpeech
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # An adjective.
    ADJECTIVE = new("adjective")

    # A common noun used as an adjective, to modify another noun.
    ADJUNCT_COMMON_NOUN = new("adjunct_common_noun")

    # A proper noun used as an adjective, to modify another noun.
    ADJUNCT_PROPER_NOUN = new("adjunct_proper_noun")

    # A verb used as an adjective, to modify a noun.
    ATTRIBUTIVE_VERB = new("attributive_verb")

    # A common noun.
    COMMON_NOUN = new("common_noun")

    # Gerund or present participle of a verb, e.g. "going", "seeing", "waving"
    GERUND = new("gerund")

    # A proper noun.
    PROPER_NOUN = new("proper_noun")

    # A verb in present tense
    VERB = new("verb")

    def self.from_json_data(data)
      {
        "adjective" => ADJECTIVE,
        "adjunct_common_noun" => ADJUNCT_COMMON_NOUN,
        "adjunct_proper_noun" => ADJUNCT_PROPER_NOUN,
        "attributive_verb" => ATTRIBUTIVE_VERB,
        "common_noun" => COMMON_NOUN,
        "gerund" => GERUND,
        "proper_noun" => PROPER_NOUN,
        "verb" => VERB,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class ProgressRollMethod
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # An automatic miss.
    MISS = new("miss")

    # Make a progress roll on a progress track associated with this move.
    PROGRESS_ROLL = new("progress_roll")

    # An automatic strong hit.
    STRONG_HIT = new("strong_hit")

    # An automatic weak hit.
    WEAK_HIT = new("weak_hit")

    def self.from_json_data(data)
      {
        "miss" => MISS,
        "progress_roll" => PROGRESS_ROLL,
        "strong_hit" => STRONG_HIT,
        "weak_hit" => WEAK_HIT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class ProgressRollOptionUsing
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    PROGRESS_TRACK = new("progress_track")

    def self.from_json_data(data)
      {
        "progress_track" => PROGRESS_TRACK,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class ProgressRollOption
    attr_accessor :using

    def self.from_json_data(data)
      out = ProgressRollOption.new
      out.using = Datasworn::from_json_data(ProgressRollOptionUsing, data["using"])
      out
    end

    def to_json_data
      data = {}
      data["using"] = Datasworn::to_json_data(using)
      data
    end
  end

  # Describes the features of a type of progress track.
  class ProgressTrackTypeInfo
    # A category label for progress tracks of this type.
    attr_accessor :category
    attr_accessor :controls

    def self.from_json_data(data)
      out = ProgressTrackTypeInfo.new
      out.category = Datasworn::from_json_data(Label, data["category"])
      out.controls = Datasworn::from_json_data(Hash[String, Object], data["controls"])
      out
    end

    def to_json_data
      data = {}
      data["category"] = Datasworn::to_json_data(category)
      data["controls"] = Datasworn::to_json_data(controls) unless controls.nil?
      data
    end
  end

  # A rarity, as described in Ironsworn: Delve.
  class Rarity
    # The asset augmented by this rarity.
    attr_accessor :asset
    attr_accessor :description

    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The primary name/label for this item.
    attr_accessor :name

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source

    # From Ironsworn: Delve, p. 174:
    # 
    #       Some assets will bring a rarity into play more often than others,
    # so the experience point cost for a rarity will vary by the linked asset.
    # These costs are shown in the tables on page 175.
    # 
    #       If you are playing solo, and aren’t concerned with the relative
    # balance of rarity abilities, you can ignore these variable costs. If so,
    # spend 3 experience points to purchase a rarity.
    attr_accessor :xp_cost

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :icon
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = Rarity.new
      out.asset = Datasworn::from_json_data(AssetID, data["asset"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.id = Datasworn::from_json_data(RarityID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.xp_cost = Datasworn::from_json_data(Integer, data["xp_cost"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["asset"] = Datasworn::to_json_data(asset)
      data["description"] = Datasworn::to_json_data(description)
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["source"] = Datasworn::to_json_data(source)
      data["xp_cost"] = Datasworn::to_json_data(xp_cost)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  # A unique ID for a Rarity.
  class RarityID
    attr_accessor :value

    def self.from_json_data(data)
      out = RarityID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class RollableValue
    attr_accessor :using

    def self.from_json_data(data)
      {
        "asset_control" => RollableValueAssetControl,
        "asset_option" => RollableValueAssetOption,
        "attached_asset_control" => RollableValueAttachedAssetControl,
        "attached_asset_option" => RollableValueAttachedAssetOption,
        "condition_meter" => RollableValueConditionMeter,
        "custom" => RollableValueCustom,
        "stat" => RollableValueStat,
      }[data["using"]].from_json_data(data)
    end
  end

  # A reference to the value of an asset control.
  class RollableValueAssetControl < RollableValue
    attr_accessor :assets
    attr_accessor :control

    def self.from_json_data(data)
      out = RollableValueAssetControl.new
      out.using = "asset_control"
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.control = Datasworn::from_json_data(DictKey, data["control"])
      out
    end

    def to_json_data
      data = { "using" => "asset_control" }
      data["assets"] = Datasworn::to_json_data(assets)
      data["control"] = Datasworn::to_json_data(control)
      data
    end
  end

  # A reference to the value of an asset option.
  class RollableValueAssetOption < RollableValue
    attr_accessor :assets
    attr_accessor :option

    def self.from_json_data(data)
      out = RollableValueAssetOption.new
      out.using = "asset_option"
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.option = Datasworn::from_json_data(DictKey, data["option"])
      out
    end

    def to_json_data
      data = { "using" => "asset_option" }
      data["assets"] = Datasworn::to_json_data(assets)
      data["option"] = Datasworn::to_json_data(option)
      data
    end
  end

  # A reference to the value of an attached asset control. For example, a Module
  # asset could use this to roll using the `integrity` control of an attached
  # Vehicle.
  class RollableValueAttachedAssetControl < RollableValue
    attr_accessor :control

    def self.from_json_data(data)
      out = RollableValueAttachedAssetControl.new
      out.using = "attached_asset_control"
      out.control = Datasworn::from_json_data(DictKey, data["control"])
      out
    end

    def to_json_data
      data = { "using" => "attached_asset_control" }
      data["control"] = Datasworn::to_json_data(control)
      data
    end
  end

  # A reference to the value of an attached asset option.
  class RollableValueAttachedAssetOption < RollableValue
    attr_accessor :option

    def self.from_json_data(data)
      out = RollableValueAttachedAssetOption.new
      out.using = "attached_asset_option"
      out.option = Datasworn::from_json_data(DictKey, data["option"])
      out
    end

    def to_json_data
      data = { "using" => "attached_asset_option" }
      data["option"] = Datasworn::to_json_data(option)
      data
    end
  end

  # A reference to the value of a standard player condition meter.
  class RollableValueConditionMeter < RollableValue
    attr_accessor :condition_meter

    def self.from_json_data(data)
      out = RollableValueConditionMeter.new
      out.using = "condition_meter"
      out.condition_meter = Datasworn::from_json_data(ConditionMeterKey, data["condition_meter"])
      out
    end

    def to_json_data
      data = { "using" => "condition_meter" }
      data["condition_meter"] = Datasworn::to_json_data(condition_meter)
      data
    end
  end

  # An arbitrary static integer value with a label.
  class RollableValueCustom < RollableValue
    attr_accessor :label
    attr_accessor :value

    def self.from_json_data(data)
      out = RollableValueCustom.new
      out.using = "custom"
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out
    end

    def to_json_data
      data = { "using" => "custom" }
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data
    end
  end

  # A reference to the value of a standard player character stat.
  class RollableValueStat < RollableValue
    attr_accessor :stat

    def self.from_json_data(data)
      out = RollableValueStat.new
      out.using = "stat"
      out.stat = Datasworn::from_json_data(StatKey, data["stat"])
      out
    end

    def to_json_data
      data = { "using" => "stat" }
      data["stat"] = Datasworn::to_json_data(stat)
      data
    end
  end

  class RollableValueType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # A reference to the value of an asset control.
    ASSET_CONTROL = new("asset_control")

    # A reference to the value of an asset option.
    ASSET_OPTION = new("asset_option")

    # A reference to the value of an attached asset control. For example, a
    # Module asset could use this to roll using the `integrity` control of an
    # attached Vehicle.
    ATTACHED_ASSET_CONTROL = new("attached_asset_control")

    # A reference to the value of an attached asset option.
    ATTACHED_ASSET_OPTION = new("attached_asset_option")

    # A reference to the value of a standard player condition meter.
    CONDITION_METER = new("condition_meter")

    # An arbitrary static integer value with a label.
    CUSTOM = new("custom")

    # A reference to the value of a standard player character stat.
    STAT = new("stat")

    def self.from_json_data(data)
      {
        "asset_control" => ASSET_CONTROL,
        "asset_option" => ASSET_OPTION,
        "attached_asset_control" => ATTACHED_ASSET_CONTROL,
        "attached_asset_option" => ATTACHED_ASSET_OPTION,
        "condition_meter" => CONDITION_METER,
        "custom" => CUSTOM,
        "stat" => STAT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Describes rules for player characters in this ruleset, such as stats and
  # condition meters.
  class Rules
    # Describes the standard condition meters used by player characters in this
    # ruleset.
    attr_accessor :condition_meters

    # Describes the standard impacts/debilities used by player characters in
    # this ruleset.
    attr_accessor :impacts

    # Describes the special tracks used by player characters in this ruleset,
    # like Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    attr_accessor :special_tracks

    # Describes the standard stats used by player characters in this ruleset.
    attr_accessor :stats

    def self.from_json_data(data)
      out = Rules.new
      out.condition_meters = Datasworn::from_json_data(Hash[String, ConditionMeterRule], data["condition_meters"])
      out.impacts = Datasworn::from_json_data(Hash[String, ImpactCategory], data["impacts"])
      out.special_tracks = Datasworn::from_json_data(Hash[String, SpecialTrackRule], data["special_tracks"])
      out.stats = Datasworn::from_json_data(Hash[String, StatRule], data["stats"])
      out
    end

    def to_json_data
      data = {}
      data["condition_meters"] = Datasworn::to_json_data(condition_meters)
      data["impacts"] = Datasworn::to_json_data(impacts)
      data["special_tracks"] = Datasworn::to_json_data(special_tracks)
      data["stats"] = Datasworn::to_json_data(stats)
      data
    end
  end

  # Describes rules for player characters in this ruleset, such as stats and
  # condition meters.
  class RulesExpansion
    # Describes the standard condition meters used by player characters in this
    # ruleset.
    attr_accessor :condition_meters

    # Describes the standard impacts/debilities used by player characters in
    # this ruleset.
    attr_accessor :impacts

    # Describes the special tracks used by player characters in this ruleset,
    # like Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    attr_accessor :special_tracks

    # Describes the standard stats used by player characters in this ruleset.
    attr_accessor :stats

    def self.from_json_data(data)
      out = RulesExpansion.new
      out.condition_meters = Datasworn::from_json_data(Hash[String, ConditionMeterRule], data["condition_meters"])
      out.impacts = Datasworn::from_json_data(Hash[String, ImpactCategory], data["impacts"])
      out.special_tracks = Datasworn::from_json_data(Hash[String, SpecialTrackRule], data["special_tracks"])
      out.stats = Datasworn::from_json_data(Hash[String, StatRule], data["stats"])
      out
    end

    def to_json_data
      data = {}
      data["condition_meters"] = Datasworn::to_json_data(condition_meters) unless condition_meters.nil?
      data["impacts"] = Datasworn::to_json_data(impacts) unless impacts.nil?
      data["special_tracks"] = Datasworn::to_json_data(special_tracks) unless special_tracks.nil?
      data["stats"] = Datasworn::to_json_data(stats) unless stats.nil?
      data
    end
  end

  # The ID of standalone Datasworn package that describes its own ruleset.
  class RulesetID
    attr_accessor :value

    def self.from_json_data(data)
      out = RulesetID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class SemanticVersion
    attr_accessor :value

    def self.from_json_data(data)
      out = SemanticVersion.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class SourceAuthor
    attr_accessor :name

    # An optional email contact for the author
    attr_accessor :email

    # An optional URL for the author's website.
    attr_accessor :url

    def self.from_json_data(data)
      out = SourceAuthor.new
      out.name = Datasworn::from_json_data(String, data["name"])
      out.email = Datasworn::from_json_data(String, data["email"])
      out.url = Datasworn::from_json_data(String, data["url"])
      out
    end

    def to_json_data
      data = {}
      data["name"] = Datasworn::to_json_data(name)
      data["email"] = Datasworn::to_json_data(email) unless email.nil?
      data["url"] = Datasworn::to_json_data(url) unless url.nil?
      data
    end
  end

  # Metadata describing the original source of this item
  class Source
    attr_accessor :authors

    # The date of the source documents's last update, formatted YYYY-MM-DD.
    # Required because it's used to determine whether the data needs updating.
    attr_accessor :date
    attr_accessor :license

    # The title of the source document.
    attr_accessor :title

    # An absolute URL where the source document is available.
    attr_accessor :url

    # The page number where this item is described in full.
    attr_accessor :page

    def self.from_json_data(data)
      out = Source.new
      out.authors = Datasworn::from_json_data(Array[SourceAuthor], data["authors"])
      out.date = Datasworn::from_json_data(String, data["date"])
      out.license = Datasworn::from_json_data(String, data["license"])
      out.title = Datasworn::from_json_data(String, data["title"])
      out.url = Datasworn::from_json_data(String, data["url"])
      out.page = Datasworn::from_json_data(Integer, data["page"])
      out
    end

    def to_json_data
      data = {}
      data["authors"] = Datasworn::to_json_data(authors)
      data["date"] = Datasworn::to_json_data(date)
      data["license"] = Datasworn::to_json_data(license)
      data["title"] = Datasworn::to_json_data(title)
      data["url"] = Datasworn::to_json_data(url)
      data["page"] = Datasworn::to_json_data(page) unless page.nil?
      data
    end
  end

  class SpecialTrackRollMethod
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # Use **every** roll option at once.
    ALL = new("all")

    # Use the roll option with the best/highest value.
    HIGHEST = new("highest")

    # Use the roll option with the worst/lowest value.
    LOWEST = new("lowest")

    # An automatic miss.
    MISS = new("miss")

    # The player chooses which roll option to use.
    PLAYER_CHOICE = new("player_choice")

    # An automatic strong hit.
    STRONG_HIT = new("strong_hit")

    # An automatic weak hit.
    WEAK_HIT = new("weak_hit")

    def self.from_json_data(data)
      {
        "all" => ALL,
        "highest" => HIGHEST,
        "lowest" => LOWEST,
        "miss" => MISS,
        "player_choice" => PLAYER_CHOICE,
        "strong_hit" => STRONG_HIT,
        "weak_hit" => WEAK_HIT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Describes a special track like Bonds (classic Ironsworn), Failure (Delve),
  # or Legacies (Starforged).
  class SpecialTrackRule
    # A description of this special track.
    attr_accessor :description

    # A label for this special track.
    attr_accessor :label

    # Is this track an optional rule?
    attr_accessor :optional

    # Is this track shared by all players?
    attr_accessor :shared

    def self.from_json_data(data)
      out = SpecialTrackRule.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out.optional = Datasworn::from_json_data(TrueClass, data["optional"])
      out.shared = Datasworn::from_json_data(TrueClass, data["shared"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["label"] = Datasworn::to_json_data(label)
      data["optional"] = Datasworn::to_json_data(optional)
      data["shared"] = Datasworn::to_json_data(shared)
      data
    end
  end

  # A unique ID for a SpecialTrackRule.
  class SpecialTrackRuleID
    attr_accessor :value

    def self.from_json_data(data)
      out = SpecialTrackRuleID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Special, ruleset-specific progress tracks. Usually, one exists per player
  # character, and they persist through the life of the player character.
  # 'Canonical' examples:
  #   * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged
  # legacy track, use `bonds_legacy` instead.
  #   * `failure_track`, described in Ironsworn: Delve
  #   * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described
  # Ironsworn: Starforged
  # 
  class SpecialTrackType
    attr_accessor :value

    def self.from_json_data(data)
      out = SpecialTrackType.new
      out.value = Datasworn.from_json_data(DictKey, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A basic player character stat.
  class StatKey
    attr_accessor :value

    def self.from_json_data(data)
      out = StatKey.new
      out.value = Datasworn.from_json_data(DictKey, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Describes a standard player character stat.
  class StatRule
    # A description of this stat.
    attr_accessor :description

    # A label for this stat.
    attr_accessor :label

    def self.from_json_data(data)
      out = StatRule.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.label = Datasworn::from_json_data(Label, data["label"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["label"] = Datasworn::to_json_data(label)
      data
    end
  end

  # A unique ID for a StatRule.
  class StatRuleID
    attr_accessor :value

    def self.from_json_data(data)
      out = StatRuleID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class Suggestions
    attr_accessor :assets
    attr_accessor :atlas
    attr_accessor :moves
    attr_accessor :npcs
    attr_accessor :oracles
    attr_accessor :rarities
    attr_accessor :site_domains
    attr_accessor :site_themes

    def self.from_json_data(data)
      out = Suggestions.new
      out.assets = Datasworn::from_json_data(Array[AssetID], data["assets"])
      out.atlas = Datasworn::from_json_data(Array[AtlasEntryID], data["atlas"])
      out.moves = Datasworn::from_json_data(Array[MoveID], data["moves"])
      out.npcs = Datasworn::from_json_data(Array[NpcID], data["npcs"])
      out.oracles = Datasworn::from_json_data(Array[OracleTableID], data["oracles"])
      out.rarities = Datasworn::from_json_data(Array[RarityID], data["rarities"])
      out.site_domains = Datasworn::from_json_data(Array[DelveSiteDomainID], data["site_domains"])
      out.site_themes = Datasworn::from_json_data(Array[DelveSiteThemeID], data["site_themes"])
      out
    end

    def to_json_data
      data = {}
      data["assets"] = Datasworn::to_json_data(assets) unless assets.nil?
      data["atlas"] = Datasworn::to_json_data(atlas) unless atlas.nil?
      data["moves"] = Datasworn::to_json_data(moves) unless moves.nil?
      data["npcs"] = Datasworn::to_json_data(npcs) unless npcs.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["rarities"] = Datasworn::to_json_data(rarities) unless rarities.nil?
      data["site_domains"] = Datasworn::to_json_data(site_domains) unless site_domains.nil?
      data["site_themes"] = Datasworn::to_json_data(site_themes) unless site_themes.nil?
      data
    end
  end

  # A relative URL pointing to a vector image in the SVG format.
  class SvgImageURL
    attr_accessor :value

    def self.from_json_data(data)
      out = SvgImageURL.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A rich text string in Markdown with replaced values from oracle roll
  # results.
  # 
  # The custom syntax `{{some_row_key:some_oracle_table_id}}` should be replaced
  # by the `some_row_key` string of a rolled oracle table. This is usually the
  # `result` key, for example `{{result:starforged/oracles/core/action}}`
  class TemplateString
    attr_accessor :value

    def self.from_json_data(data)
      out = TemplateString.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID for a ThemeDangerRow.
  class ThemeDangerRowID
    attr_accessor :value

    def self.from_json_data(data)
      out = ThemeDangerRowID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID for a ThemeFeatureRow.
  class ThemeFeatureRowID
    attr_accessor :value

    def self.from_json_data(data)
      out = ThemeFeatureRowID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Describes trigger conditions for a move that makes an action roll.
  class TriggerActionRoll
    # Specific conditions that qualify for this trigger.
    attr_accessor :conditions

    # A markdown string containing the primary trigger text for this move.
    # 
    # Secondary trigger text (for specific stats or uses of an asset ability)
    # may be described in individual trigger conditions.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerActionRoll.new
      out.conditions = Datasworn::from_json_data(Array[TriggerActionRollCondition], data["conditions"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class TriggerActionRollCondition
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerActionRollCondition.new
      out.method = Datasworn::from_json_data(ActionRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[RollableValue], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  class TriggerActionRollConditionEnhancement
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerActionRollConditionEnhancement.new
      out.method = Datasworn::from_json_data(ActionRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[RollableValue], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  # Describes changes/additions made to the enhanced move's trigger conditions.
  class TriggerActionRollEnhancement
    # Trigger conditions added to the enhanced move.
    attr_accessor :conditions

    def self.from_json_data(data)
      out = TriggerActionRollEnhancement.new
      out.conditions = Datasworn::from_json_data(Array[TriggerActionRollConditionEnhancement], data["conditions"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data
    end
  end

  # Information on who can trigger this trigger condition. Usually this is just
  # the player, but some asset abilities can trigger from an ally's move.
  class TriggerBy
    # Can this trigger be activated by one of the player's allies?
    attr_accessor :ally

    # Can this trigger be activated by the player who owns this?
    attr_accessor :player

    def self.from_json_data(data)
      out = TriggerBy.new
      out.ally = Datasworn::from_json_data(TrueClass, data["ally"])
      out.player = Datasworn::from_json_data(TrueClass, data["player"])
      out
    end

    def to_json_data
      data = {}
      data["ally"] = Datasworn::to_json_data(ally)
      data["player"] = Datasworn::to_json_data(player)
      data
    end
  end

  # Describes trigger conditions for a move that makes no rolls.
  class TriggerNoRoll
    attr_accessor :conditions

    # A markdown string containing the primary trigger text for this move.
    # 
    # Secondary trigger text (for specific stats or uses of an asset ability)
    # may be described in individual trigger conditions.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerNoRoll.new
      out.conditions = Datasworn::from_json_data(Array[TriggerNoRollCondition], data["conditions"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class TriggerNoRollCondition
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerNoRollCondition.new
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  # Describes changes/additions made to the enhanced move's trigger conditions.
  class TriggerNoRollEnhancement
    # Trigger conditions added to the enhanced move.
    attr_accessor :conditions

    def self.from_json_data(data)
      out = TriggerNoRollEnhancement.new
      out.conditions = Datasworn::from_json_data(Array[TriggerNoRollCondition], data["conditions"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data
    end
  end

  class TriggerProgressRoll
    # Specific conditions that qualify for this trigger.
    attr_accessor :conditions

    # A markdown string containing the primary trigger text for this move.
    # 
    # Secondary trigger text (for specific stats or uses of an asset ability)
    # may be described in individual trigger conditions.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerProgressRoll.new
      out.conditions = Datasworn::from_json_data(Array[TriggerProgressRollCondition], data["conditions"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class TriggerProgressRollCondition
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerProgressRollCondition.new
      out.method = Datasworn::from_json_data(ProgressRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[ProgressRollOption], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  class TriggerProgressRollConditionEnhancement
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerProgressRollConditionEnhancement.new
      out.method = Datasworn::from_json_data(ProgressRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[ProgressRollOption], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  # Describes changes/additions made to the enhanced move's trigger conditions.
  class TriggerProgressRollEnhancement
    # Trigger conditions added to the enhanced move.
    attr_accessor :conditions

    def self.from_json_data(data)
      out = TriggerProgressRollEnhancement.new
      out.conditions = Datasworn::from_json_data(Array[TriggerProgressRollConditionEnhancement], data["conditions"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data
    end
  end

  class TriggerSpecialTrack
    # Specific conditions that qualify for this trigger.
    attr_accessor :conditions

    # A markdown string containing the primary trigger text for this move.
    # 
    # Secondary trigger text (for specific stats or uses of an asset ability)
    # may be described in individual trigger conditions.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerSpecialTrack.new
      out.conditions = Datasworn::from_json_data(Array[TriggerSpecialTrackCondition], data["conditions"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class TriggerSpecialTrackCondition
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerSpecialTrackCondition.new
      out.method = Datasworn::from_json_data(SpecialTrackRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[TriggerSpecialTrackConditionOption], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  # A progress move that rolls on one or more special tracks, like Bonds
  # (classic Ironsworn), Failure (Delve), or Legacy (Starforged).
  class TriggerSpecialTrackConditionEnhancement
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerSpecialTrackConditionEnhancement.new
      out.method = Datasworn::from_json_data(SpecialTrackRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[TriggerSpecialTrackConditionOption], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  class TriggerSpecialTrackConditionOption
    attr_accessor :using

    def self.from_json_data(data)
      out = TriggerSpecialTrackConditionOption.new
      out.using = Datasworn::from_json_data(SpecialTrackType, data["using"])
      out
    end

    def to_json_data
      data = {}
      data["using"] = Datasworn::to_json_data(using)
      data
    end
  end

  # Describes changes/additions made to the enhanced move's trigger conditions.
  class TriggerSpecialTrackEnhancement
    # Trigger conditions added to the enhanced move.
    attr_accessor :conditions

    def self.from_json_data(data)
      out = TriggerSpecialTrackEnhancement.new
      out.conditions = Datasworn::from_json_data(Array[TriggerSpecialTrackConditionEnhancement], data["conditions"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data
    end
  end

  # A setting truth category.
  class Truth
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The primary name/label for this item.
    attr_accessor :name
    attr_accessor :options

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :icon
    attr_accessor :suggestions
    attr_accessor :your_character

    def self.from_json_data(data)
      out = Truth.new
      out.id = Datasworn::from_json_data(TruthID, data["id"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.options = Datasworn::from_json_data(Array[TruthOption], data["options"])
      out.source = Datasworn::from_json_data(Source, data["source"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.your_character = Datasworn::from_json_data(MarkdownString, data["your_character"])
      out
    end

    def to_json_data
      data = {}
      data["id"] = Datasworn::to_json_data(id)
      data["name"] = Datasworn::to_json_data(name)
      data["options"] = Datasworn::to_json_data(options)
      data["source"] = Datasworn::to_json_data(source)
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["your_character"] = Datasworn::to_json_data(your_character) unless your_character.nil?
      data
    end
  end

  # A unique ID for a Truth.
  class TruthID
    attr_accessor :value

    def self.from_json_data(data)
      out = TruthID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class TruthOption
    attr_accessor :description

    # The unique Datasworn ID for this item.
    attr_accessor :id
    attr_accessor :quest_starter
    attr_accessor :max
    attr_accessor :min
    attr_accessor :summary
    attr_accessor :table

    def self.from_json_data(data)
      out = TruthOption.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.id = Datasworn::from_json_data(TruthOptionID, data["id"])
      out.quest_starter = Datasworn::from_json_data(MarkdownString, data["quest_starter"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.table = Datasworn::from_json_data(Array[TruthOptionTableRow], data["table"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["id"] = Datasworn::to_json_data(id)
      data["quest_starter"] = Datasworn::to_json_data(quest_starter)
      data["max"] = Datasworn::to_json_data(max) unless max.nil?
      data["min"] = Datasworn::to_json_data(min) unless min.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["table"] = Datasworn::to_json_data(table) unless table.nil?
      data
    end
  end

  # A unique ID for a TruthOption.
  class TruthOptionID
    attr_accessor :value

    def self.from_json_data(data)
      out = TruthOptionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Represents a row in an oracle table.
  class TruthOptionTableRow
    # High end of the dice range for this table row.
    attr_accessor :max

    # Low end of the dice range for this table row.
    attr_accessor :min

    # The primary text content of this row.
    attr_accessor :result

    # Optional tertiary text content for this row. Generally, this is longer
    # than both `result` and `summary`.
    attr_accessor :description

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :i18n
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :rolls
    attr_accessor :suggestions

    # Optional secondary text content for this row. Generally, this is longer
    # than `result`.
    attr_accessor :summary
    attr_accessor :template

    def self.from_json_data(data)
      out = TruthOptionTableRow.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.result = Datasworn::from_json_data(MarkdownString, data["result"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.embed_table = Datasworn::from_json_data(OracleTableID, data["embed_table"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["i18n"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.rolls = Datasworn::from_json_data(Array[OracleTableRoll], data["rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["result"] = Datasworn::to_json_data(result)
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["rolls"] = Datasworn::to_json_data(rolls) unless rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # A relative URL pointing to a raster image in the WEBP format.
  class WebpImageURL
    attr_accessor :value

    def self.from_json_data(data)
      out = WebpImageURL.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  private

  def self.from_json_data(type, data)
    if data.nil? || [Object, TrueClass, Integer, Float, String].include?(type)
      data
    elsif type == DateTime
      DateTime.rfc3339(data)
    elsif type.is_a?(Array)
      data.map { |elem| from_json_data(type.first, elem) }
    elsif type.is_a?(Hash)
      data.transform_values { |elem| from_json_data(type.values.first, elem) }
    else
      type.from_json_data(data)
    end
  end

  def self.to_json_data(data)
    if data.nil? || [TrueClass, FalseClass, Integer, Float, String].include?(data.class)
      data
    elsif data.is_a?(DateTime)
      data.rfc3339
    elsif data.is_a?(Array)
      data.map { |elem| to_json_data(elem) }
    elsif data.is_a?(Hash)
      data.transform_values { |elem| to_json_data(elem) }
    else
      data.to_json_data
    end
  end
end
