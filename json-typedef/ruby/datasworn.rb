# Code generated by jtd-codegen for Ruby v0.1.1

require 'json'
require 'time'

module Datasworn

  # Describes game rules compatible with the Ironsworn tabletop role-playing
  # game by Shawn Tomkin.
  class RulesPackage
    attr_accessor :type

    def self.from_json_data(data)
      {
        "expansion" => RulesPackageExpansion,
        "ruleset" => RulesPackageRuleset,
      }[data["type"]].from_json_data(data)
    end
  end

  # The version of the Datasworn format used by this data.
  class RulesPackageExpansionDataswornVersion
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    DEFAULT_NAME = new("0.0.9")

    def self.from_json_data(data)
      {
        "0.0.9" => DEFAULT_NAME,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A Datasworn package that relies on an external package to provide its
  # ruleset.
  class RulesPackageExpansion < RulesPackage
    attr_accessor :id
    attr_accessor :datasworn_version
    attr_accessor :ruleset
    attr_accessor :assets
    attr_accessor :atlas
    attr_accessor :authors
    attr_accessor :date
    attr_accessor :delve_sites
    attr_accessor :description
    attr_accessor :license
    attr_accessor :moves
    attr_accessor :npcs
    attr_accessor :oracles
    attr_accessor :rarities
    attr_accessor :rules
    attr_accessor :site_domains
    attr_accessor :site_themes
    attr_accessor :title
    attr_accessor :truths
    attr_accessor :url

    def self.from_json_data(data)
      out = RulesPackageExpansion.new
      out.type = "expansion"
      out.id = Datasworn::from_json_data(ExpansionID, data["_id"])
      out.datasworn_version = Datasworn::from_json_data(RulesPackageExpansionDataswornVersion, data["datasworn_version"])
      out.ruleset = Datasworn::from_json_data(RulesetID, data["ruleset"])
      out.assets = Datasworn::from_json_data(Hash[String, AssetCollection], data["assets"])
      out.atlas = Datasworn::from_json_data(Hash[String, AtlasCollection], data["atlas"])
      out.authors = Datasworn::from_json_data(Array[AuthorInfo], data["authors"])
      out.date = Datasworn::from_json_data(DateTime, data["date"])
      out.delve_sites = Datasworn::from_json_data(Hash[String, DelveSite], data["delve_sites"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.license = Datasworn::from_json_data(License, data["license"])
      out.moves = Datasworn::from_json_data(Hash[String, MoveCategory], data["moves"])
      out.npcs = Datasworn::from_json_data(Hash[String, NpcCollection], data["npcs"])
      out.oracles = Datasworn::from_json_data(Hash[String, OracleTablesCollection], data["oracles"])
      out.rarities = Datasworn::from_json_data(Hash[String, Rarity], data["rarities"])
      out.rules = Datasworn::from_json_data(RulesExpansion, data["rules"])
      out.site_domains = Datasworn::from_json_data(Hash[String, DelveSiteDomain], data["site_domains"])
      out.site_themes = Datasworn::from_json_data(Hash[String, DelveSiteTheme], data["site_themes"])
      out.title = Datasworn::from_json_data(String, data["title"])
      out.truths = Datasworn::from_json_data(Hash[String, Truth], data["truths"])
      out.url = Datasworn::from_json_data(WebURL, data["url"])
      out
    end

    def to_json_data
      data = { "type" => "expansion" }
      data["_id"] = Datasworn::to_json_data(id)
      data["datasworn_version"] = Datasworn::to_json_data(datasworn_version)
      data["ruleset"] = Datasworn::to_json_data(ruleset)
      data["assets"] = Datasworn::to_json_data(assets) unless assets.nil?
      data["atlas"] = Datasworn::to_json_data(atlas) unless atlas.nil?
      data["authors"] = Datasworn::to_json_data(authors) unless authors.nil?
      data["date"] = Datasworn::to_json_data(date) unless date.nil?
      data["delve_sites"] = Datasworn::to_json_data(delve_sites) unless delve_sites.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["license"] = Datasworn::to_json_data(license) unless license.nil?
      data["moves"] = Datasworn::to_json_data(moves) unless moves.nil?
      data["npcs"] = Datasworn::to_json_data(npcs) unless npcs.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["rarities"] = Datasworn::to_json_data(rarities) unless rarities.nil?
      data["rules"] = Datasworn::to_json_data(rules) unless rules.nil?
      data["site_domains"] = Datasworn::to_json_data(site_domains) unless site_domains.nil?
      data["site_themes"] = Datasworn::to_json_data(site_themes) unless site_themes.nil?
      data["title"] = Datasworn::to_json_data(title) unless title.nil?
      data["truths"] = Datasworn::to_json_data(truths) unless truths.nil?
      data["url"] = Datasworn::to_json_data(url) unless url.nil?
      data
    end
  end

  # The version of the Datasworn format used by this data.
  class RulesPackageRulesetDataswornVersion
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    DEFAULT_NAME = new("0.0.9")

    def self.from_json_data(data)
      {
        "0.0.9" => DEFAULT_NAME,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A standalone Datasworn package that describes its own ruleset.
  class RulesPackageRuleset < RulesPackage
    attr_accessor :id
    attr_accessor :assets
    attr_accessor :authors
    attr_accessor :datasworn_version
    attr_accessor :date
    attr_accessor :license
    attr_accessor :moves
    attr_accessor :oracles
    attr_accessor :rules
    attr_accessor :title
    attr_accessor :url
    attr_accessor :atlas
    attr_accessor :delve_sites
    attr_accessor :description
    attr_accessor :npcs
    attr_accessor :rarities
    attr_accessor :site_domains
    attr_accessor :site_themes
    attr_accessor :truths

    def self.from_json_data(data)
      out = RulesPackageRuleset.new
      out.type = "ruleset"
      out.id = Datasworn::from_json_data(RulesetID, data["_id"])
      out.assets = Datasworn::from_json_data(Hash[String, AssetCollection], data["assets"])
      out.authors = Datasworn::from_json_data(Array[AuthorInfo], data["authors"])
      out.datasworn_version = Datasworn::from_json_data(RulesPackageRulesetDataswornVersion, data["datasworn_version"])
      out.date = Datasworn::from_json_data(DateTime, data["date"])
      out.license = Datasworn::from_json_data(License, data["license"])
      out.moves = Datasworn::from_json_data(Hash[String, MoveCategory], data["moves"])
      out.oracles = Datasworn::from_json_data(Hash[String, OracleTablesCollection], data["oracles"])
      out.rules = Datasworn::from_json_data(Rules, data["rules"])
      out.title = Datasworn::from_json_data(String, data["title"])
      out.url = Datasworn::from_json_data(WebURL, data["url"])
      out.atlas = Datasworn::from_json_data(Hash[String, AtlasCollection], data["atlas"])
      out.delve_sites = Datasworn::from_json_data(Hash[String, DelveSite], data["delve_sites"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.npcs = Datasworn::from_json_data(Hash[String, NpcCollection], data["npcs"])
      out.rarities = Datasworn::from_json_data(Hash[String, Rarity], data["rarities"])
      out.site_domains = Datasworn::from_json_data(Hash[String, DelveSiteDomain], data["site_domains"])
      out.site_themes = Datasworn::from_json_data(Hash[String, DelveSiteTheme], data["site_themes"])
      out.truths = Datasworn::from_json_data(Hash[String, Truth], data["truths"])
      out
    end

    def to_json_data
      data = { "type" => "ruleset" }
      data["_id"] = Datasworn::to_json_data(id)
      data["assets"] = Datasworn::to_json_data(assets)
      data["authors"] = Datasworn::to_json_data(authors)
      data["datasworn_version"] = Datasworn::to_json_data(datasworn_version)
      data["date"] = Datasworn::to_json_data(date)
      data["license"] = Datasworn::to_json_data(license)
      data["moves"] = Datasworn::to_json_data(moves)
      data["oracles"] = Datasworn::to_json_data(oracles)
      data["rules"] = Datasworn::to_json_data(rules)
      data["title"] = Datasworn::to_json_data(title)
      data["url"] = Datasworn::to_json_data(url)
      data["atlas"] = Datasworn::to_json_data(atlas) unless atlas.nil?
      data["delve_sites"] = Datasworn::to_json_data(delve_sites) unless delve_sites.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["npcs"] = Datasworn::to_json_data(npcs) unless npcs.nil?
      data["rarities"] = Datasworn::to_json_data(rarities) unless rarities.nil?
      data["site_domains"] = Datasworn::to_json_data(site_domains) unless site_domains.nil?
      data["site_themes"] = Datasworn::to_json_data(site_themes) unless site_themes.nil?
      data["truths"] = Datasworn::to_json_data(truths) unless truths.nil?
      data
    end
  end

  class ActionRollMethod
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # Use _every_ roll option at once.
    ALL = new("all")

    # Use the roll option with the best/highest value.
    HIGHEST = new("highest")

    # Use the roll option with the worst/lowest value.
    LOWEST = new("lowest")

    # An automatic miss.
    MISS = new("miss")

    # The player chooses which roll option to use.
    PLAYER_CHOICE = new("player_choice")

    # An automatic strong hit.
    STRONG_HIT = new("strong_hit")

    # An automatic weak hit.
    WEAK_HIT = new("weak_hit")

    def self.from_json_data(data)
      {
        "all" => ALL,
        "highest" => HIGHEST,
        "lowest" => LOWEST,
        "miss" => MISS,
        "player_choice" => PLAYER_CHOICE,
        "strong_hit" => STRONG_HIT,
        "weak_hit" => WEAK_HIT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class AssetType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ASSET = new("asset")

    def self.from_json_data(data)
      {
        "asset" => ASSET,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class Asset
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source
    attr_accessor :abilities

    # A localized category label for this asset. This is the surtitle above the
    # asset's name on the card.
    attr_accessor :category

    # If `true`, this asset counts as an impact (Starforged) or a debility
    # (classic Ironsworn).
    attr_accessor :count_as_impact

    # The primary name/label for this item.
    attr_accessor :name

    # Most assets only benefit to their owner, but certain assets (like
    # Starforged's module and command vehicle assets) are shared amongst the
    # player's allies, too.
    attr_accessor :shared
    attr_accessor :type

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment
    attr_accessor :attachments

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this asset.
    attr_accessor :color

    # Controls are condition meters, clocks, counters, and other asset input
    # fields whose values are expected to change throughout the life of the
    # asset.
    attr_accessor :controls

    # This asset's icon.
    attr_accessor :icon

    # Options are input fields set when the player purchases the asset. They're
    # likely to remain the same through the life of the asset. Typically, they
    # are rendered at the top of the asset card.
    attr_accessor :options

    # Describes prerequisites for purchasing or using this asset.
    attr_accessor :requirement
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = Asset.new
      out.id = Datasworn::from_json_data(AssetID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.abilities = Datasworn::from_json_data(Array[AssetAbility], data["abilities"])
      out.category = Datasworn::from_json_data(Label, data["category"])
      out.count_as_impact = Datasworn::from_json_data(TrueClass, data["count_as_impact"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.shared = Datasworn::from_json_data(TrueClass, data["shared"])
      out.type = Datasworn::from_json_data(AssetType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.attachments = Datasworn::from_json_data(AssetAttachment, data["attachments"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.controls = Datasworn::from_json_data(Hash[String, AssetControlField], data["controls"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.options = Datasworn::from_json_data(Hash[String, AssetOptionField], data["options"])
      out.requirement = Datasworn::from_json_data(MarkdownString, data["requirement"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["abilities"] = Datasworn::to_json_data(abilities)
      data["category"] = Datasworn::to_json_data(category)
      data["count_as_impact"] = Datasworn::to_json_data(count_as_impact)
      data["name"] = Datasworn::to_json_data(name)
      data["shared"] = Datasworn::to_json_data(shared)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["attachments"] = Datasworn::to_json_data(attachments) unless attachments.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["controls"] = Datasworn::to_json_data(controls) unless controls.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["options"] = Datasworn::to_json_data(options) unless options.nil?
      data["requirement"] = Datasworn::to_json_data(requirement) unless requirement.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # An asset ability: one of the purchasable features of an asset. Most assets
  # have three.
  class AssetAbility
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # Is this asset ability enabled?
    attr_accessor :enabled

    # The complete rules text of this asset ability.
    attr_accessor :text

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # Fields whose values are expected to change over the life of the asset.
    attr_accessor :controls

    # Changes made to the asset, when this ability is enabled.
    attr_accessor :enhance_asset

    # Describes changes made to various moves by this asset ability. Usually
    # these require specific trigger conditions.
    attr_accessor :enhance_moves

    # Unique moves added by this asset ability.
    attr_accessor :moves

    # A handful of asset abilities have a label/name, for instance classic
    # Ironsworn companion assets. Most canonical assets omit this property.
    attr_accessor :name

    # Fields that are expected to be set once and remain the same through the
    # life of the asset.
    attr_accessor :options

    def self.from_json_data(data)
      out = AssetAbility.new
      out.id = Datasworn::from_json_data(AssetAbilityID, data["_id"])
      out.enabled = Datasworn::from_json_data(TrueClass, data["enabled"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.controls = Datasworn::from_json_data(Hash[String, AssetAbilityControlField], data["controls"])
      out.enhance_asset = Datasworn::from_json_data(AssetEnhancement, data["enhance_asset"])
      out.enhance_moves = Datasworn::from_json_data(Array[MoveEnhancement], data["enhance_moves"])
      out.moves = Datasworn::from_json_data(Hash[String, Move], data["moves"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.options = Datasworn::from_json_data(Hash[String, AssetAbilityOptionField], data["options"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["enabled"] = Datasworn::to_json_data(enabled)
      data["text"] = Datasworn::to_json_data(text)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["controls"] = Datasworn::to_json_data(controls) unless controls.nil?
      data["enhance_asset"] = Datasworn::to_json_data(enhance_asset) unless enhance_asset.nil?
      data["enhance_moves"] = Datasworn::to_json_data(enhance_moves) unless enhance_moves.nil?
      data["moves"] = Datasworn::to_json_data(moves) unless moves.nil?
      data["name"] = Datasworn::to_json_data(name) unless name.nil?
      data["options"] = Datasworn::to_json_data(options) unless options.nil?
      data
    end
  end

  class AssetAbilityControlField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "checkbox" => AssetAbilityControlFieldCheckbox,
        "clock" => AssetAbilityControlFieldClock,
        "counter" => AssetAbilityControlFieldCounter,
        "text" => AssetAbilityControlFieldText,
      }[data["field_type"]].from_json_data(data)
    end
  end

  class AssetAbilityControlFieldCheckbox < AssetAbilityControlField
    attr_accessor :disables_asset
    attr_accessor :is_impact
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetAbilityControlFieldCheckbox.new
      out.field_type = "checkbox"
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "checkbox" }
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A clock with 4 or more segments.
  class AssetAbilityControlFieldClock < AssetAbilityControlField
    attr_accessor :label
    attr_accessor :max
    attr_accessor :min
    attr_accessor :rollable
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetAbilityControlFieldClock.new
      out.field_type = "clock"
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.rollable = Datasworn::from_json_data(TrueClass, data["rollable"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "clock" }
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["rollable"] = Datasworn::to_json_data(rollable)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A basic counter representing a non-rollable integer value. They usually
  # start at 0, and may or may not have a maximum.
  class AssetAbilityControlFieldCounter < AssetAbilityControlField
    attr_accessor :label
    attr_accessor :max
    attr_accessor :min
    attr_accessor :rollable
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetAbilityControlFieldCounter.new
      out.field_type = "counter"
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.rollable = Datasworn::from_json_data(TrueClass, data["rollable"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "counter" }
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["rollable"] = Datasworn::to_json_data(rollable)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # Represents an input that accepts plain text.
  class AssetAbilityControlFieldText < AssetAbilityControlField
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetAbilityControlFieldText.new
      out.field_type = "text"
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(String, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "text" }
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # A unique ID for an AssetAbility.
  class AssetAbilityID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class AssetAbilityOptionField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "text" => AssetAbilityOptionFieldText,
      }[data["field_type"]].from_json_data(data)
    end
  end

  # Represents an input that accepts plain text.
  class AssetAbilityOptionFieldText < AssetAbilityOptionField
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetAbilityOptionFieldText.new
      out.field_type = "text"
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(String, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "text" }
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # Describes which assets can be attached to this asset. Example: Starforged's
  # Module assets, which can be equipped by Command Vehicle assets. See p. 55 of
  # Starforged for more info.
  class AssetAttachment
    # Asset IDs (which may be wildcards) that may be attached to this asset
    attr_accessor :assets
    attr_accessor :max

    def self.from_json_data(data)
      out = AssetAttachment.new
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out
    end

    def to_json_data
      data = {}
      data["assets"] = Datasworn::to_json_data(assets)
      data["max"] = Datasworn::to_json_data(max)
      data
    end
  end

  class AssetCollectionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ASSET_COLLECTION = new("asset_collection")

    def self.from_json_data(data)
      {
        "asset_collection" => ASSET_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class AssetCollection
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source

    # The primary name/label for this item.
    attr_accessor :name
    attr_accessor :type

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this collection.
    attr_accessor :color
    attr_accessor :contents

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This collection's content enhances the identified collection, rather than
    # being a standalone collection of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This collection replaces the identified collection. References to the
    # replaced collection can be considered equivalent to this collection.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = AssetCollection.new
      out.id = Datasworn::from_json_data(AssetCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(AssetCollectionType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.contents = Datasworn::from_json_data(Hash[String, Asset], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(AssetCollectionID, data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(AssetCollectionID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["contents"] = Datasworn::to_json_data(contents) unless contents.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A unique ID for an AssetCollection.
  class AssetCollectionID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetCollectionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A checkbox control field, rendered as part of an asset condition meter.
  class AssetConditionMeterControlField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "card_flip" => AssetConditionMeterControlFieldCardFlip,
        "checkbox" => AssetConditionMeterControlFieldCheckbox,
      }[data["field_type"]].from_json_data(data)
    end
  end

  class AssetConditionMeterControlFieldCardFlip < AssetConditionMeterControlField
    attr_accessor :disables_asset
    attr_accessor :is_impact
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetConditionMeterControlFieldCardFlip.new
      out.field_type = "card_flip"
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "card_flip" }
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class AssetConditionMeterControlFieldCheckbox < AssetConditionMeterControlField
    attr_accessor :disables_asset
    attr_accessor :is_impact
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetConditionMeterControlFieldCheckbox.new
      out.field_type = "checkbox"
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "checkbox" }
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class AssetControlField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "card_flip" => AssetControlFieldCardFlip,
        "checkbox" => AssetControlFieldCheckbox,
        "condition_meter" => AssetControlFieldConditionMeter,
        "select_enhancement" => AssetControlFieldSelectEnhancement,
      }[data["field_type"]].from_json_data(data)
    end
  end

  class AssetControlFieldCardFlip < AssetControlField
    attr_accessor :disables_asset
    attr_accessor :is_impact
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetControlFieldCardFlip.new
      out.field_type = "card_flip"
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "card_flip" }
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class AssetControlFieldCheckbox < AssetControlField
    attr_accessor :disables_asset
    attr_accessor :is_impact
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetControlFieldCheckbox.new
      out.field_type = "checkbox"
      out.disables_asset = Datasworn::from_json_data(TrueClass, data["disables_asset"])
      out.is_impact = Datasworn::from_json_data(TrueClass, data["is_impact"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(TrueClass, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "checkbox" }
      data["disables_asset"] = Datasworn::to_json_data(disables_asset)
      data["is_impact"] = Datasworn::to_json_data(is_impact)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # Provides hints for moves that interact with this condition meter, such as
  # suffer and recovery moves.
  class AssetControlFieldConditionMeterMoves
    # The ID(s) of recovery moves associated with this meter.
    attr_accessor :recover

    # The ID(s) of suffer moves associated with the condition meter. If the
    # suffer move makes an action roll, this condition meter value should be
    # made available as a roll option.
    attr_accessor :suffer

    def self.from_json_data(data)
      out = AssetControlFieldConditionMeterMoves.new
      out.recover = Datasworn::from_json_data(Array[MoveIDWildcard], data["recover"])
      out.suffer = Datasworn::from_json_data(Array[MoveIDWildcard], data["suffer"])
      out
    end

    def to_json_data
      data = {}
      data["recover"] = Datasworn::to_json_data(recover) unless recover.nil?
      data["suffer"] = Datasworn::to_json_data(suffer) unless suffer.nil?
      data
    end
  end

  # Some assets provide a special condition meter of their own. The most common
  # example is the health meters on companion assets. Asset condition meters
  # may also include their own controls, such as the checkboxes that Starforged
  # companion assets use to indicate they are "out of action".
  class AssetControlFieldConditionMeter < AssetControlField
    attr_accessor :label
    attr_accessor :max
    attr_accessor :min
    attr_accessor :rollable
    attr_accessor :value
    attr_accessor :controls
    attr_accessor :icon
    attr_accessor :moves

    def self.from_json_data(data)
      out = AssetControlFieldConditionMeter.new
      out.field_type = "condition_meter"
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.rollable = Datasworn::from_json_data(TrueClass, data["rollable"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out.controls = Datasworn::from_json_data(Hash[String, AssetConditionMeterControlField], data["controls"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.moves = Datasworn::from_json_data(AssetControlFieldConditionMeterMoves, data["moves"])
      out
    end

    def to_json_data
      data = { "field_type" => "condition_meter" }
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["rollable"] = Datasworn::to_json_data(rollable)
      data["value"] = Datasworn::to_json_data(value)
      data["controls"] = Datasworn::to_json_data(controls) unless controls.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["moves"] = Datasworn::to_json_data(moves) unless moves.nil?
      data
    end
  end

  class AssetControlFieldSelectEnhancementChoice
    attr_accessor :choice_type

    def self.from_json_data(data)
      {
        "choice" => AssetControlFieldSelectEnhancementChoiceChoice,
        "choice_group" => AssetControlFieldSelectEnhancementChoiceChoiceGroup,
      }[data["choice_type"]].from_json_data(data)
    end
  end

  # Represents an option in a list of choices.
  class AssetControlFieldSelectEnhancementChoiceChoice < AssetControlFieldSelectEnhancementChoice
    attr_accessor :label
    attr_accessor :enhance_asset
    attr_accessor :enhance_moves

    def self.from_json_data(data)
      out = AssetControlFieldSelectEnhancementChoiceChoice.new
      out.choice_type = "choice"
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.enhance_asset = Datasworn::from_json_data(AssetEnhancement, data["enhance_asset"])
      out.enhance_moves = Datasworn::from_json_data(Array[MoveEnhancement], data["enhance_moves"])
      out
    end

    def to_json_data
      data = { "choice_type" => "choice" }
      data["label"] = Datasworn::to_json_data(label)
      data["enhance_asset"] = Datasworn::to_json_data(enhance_asset) unless enhance_asset.nil?
      data["enhance_moves"] = Datasworn::to_json_data(enhance_moves) unless enhance_moves.nil?
      data
    end
  end

  # Represents a grouping of options in a list of choices.
  class AssetControlFieldSelectEnhancementChoiceChoiceGroup < AssetControlFieldSelectEnhancementChoice
    attr_accessor :choices
    attr_accessor :name

    def self.from_json_data(data)
      out = AssetControlFieldSelectEnhancementChoiceChoiceGroup.new
      out.choice_type = "choice_group"
      out.choices = Datasworn::from_json_data(Hash[String, SelectEnhancementFieldChoice], data["choices"])
      out.name = Datasworn::from_json_data(InputLabel, data["name"])
      out
    end

    def to_json_data
      data = { "choice_type" => "choice_group" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["name"] = Datasworn::to_json_data(name)
      data
    end
  end

  # Select from player and/or asset enhancements. Use it to describe modal
  # abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
  # (Sundered Isles).
  class AssetControlFieldSelectEnhancement < AssetControlField
    attr_accessor :choices
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetControlFieldSelectEnhancement.new
      out.field_type = "select_enhancement"
      out.choices = Datasworn::from_json_data(Hash[String, AssetControlFieldSelectEnhancementChoice], data["choices"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(DictKey, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "select_enhancement" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class AssetControlFieldEnhancement
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "condition_meter" => AssetControlFieldEnhancementConditionMeter,
      }[data["field_type"]].from_json_data(data)
    end
  end

  # Some assets provide a special condition meter of their own. The most common
  # example is the health meters on companion assets. Asset condition meters
  # may also include their own controls, such as the checkboxes that Starforged
  # companion assets use to indicate they are "out of action".
  class AssetControlFieldEnhancementConditionMeter < AssetControlFieldEnhancement
    attr_accessor :max

    def self.from_json_data(data)
      out = AssetControlFieldEnhancementConditionMeter.new
      out.field_type = "condition_meter"
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out
    end

    def to_json_data
      data = { "field_type" => "condition_meter" }
      data["max"] = Datasworn::to_json_data(max)
      data
    end
  end

  # Describes enhancements made to this asset in a partial asset object. The
  # changes should be applied recursively; only the values that are specified
  # should be changed.
  class AssetEnhancement
    attr_accessor :attachments

    # Controls are condition meters, clocks, counters, and other asset input
    # fields whose values are expected to change throughout the life of the
    # asset.
    attr_accessor :controls

    # If `true`, this asset counts as an impact (Starforged) or a debility
    # (classic Ironsworn).
    attr_accessor :count_as_impact

    # Most assets only benefit to their owner, but certain assets (like
    # Starforged's module and command vehicle assets) are shared amongst the
    # player's allies, too.
    attr_accessor :shared
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = AssetEnhancement.new
      out.attachments = Datasworn::from_json_data(AssetAttachment, data["attachments"])
      out.controls = Datasworn::from_json_data(Hash[String, AssetControlFieldEnhancement], data["controls"])
      out.count_as_impact = Datasworn::from_json_data(TrueClass, data["count_as_impact"])
      out.shared = Datasworn::from_json_data(TrueClass, data["shared"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["attachments"] = Datasworn::to_json_data(attachments) unless attachments.nil?
      data["controls"] = Datasworn::to_json_data(controls) unless controls.nil?
      data["count_as_impact"] = Datasworn::to_json_data(count_as_impact) unless count_as_impact.nil?
      data["shared"] = Datasworn::to_json_data(shared) unless shared.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  # A unique ID for an Asset.
  class AssetID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A wildcarded ID that can be used to match multiple Assets.
  class AssetIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Options are asset input fields which are set once, usually when the
  # character takes the asset. The most common example is the "name" field on
  # companion assets. A more complex example is the choice of a god's stat for
  # the Devotant asset.
  class AssetOptionField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "select_enhancement" => AssetOptionFieldSelectEnhancement,
        "select_value" => AssetOptionFieldSelectValue,
        "text" => AssetOptionFieldText,
      }[data["field_type"]].from_json_data(data)
    end
  end

  class AssetOptionFieldSelectEnhancementChoice
    attr_accessor :choice_type

    def self.from_json_data(data)
      {
        "choice" => AssetOptionFieldSelectEnhancementChoiceChoice,
        "choice_group" => AssetOptionFieldSelectEnhancementChoiceChoiceGroup,
      }[data["choice_type"]].from_json_data(data)
    end
  end

  # Represents an option in a list of choices.
  class AssetOptionFieldSelectEnhancementChoiceChoice < AssetOptionFieldSelectEnhancementChoice
    attr_accessor :label
    attr_accessor :enhance_asset
    attr_accessor :enhance_moves

    def self.from_json_data(data)
      out = AssetOptionFieldSelectEnhancementChoiceChoice.new
      out.choice_type = "choice"
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.enhance_asset = Datasworn::from_json_data(AssetEnhancement, data["enhance_asset"])
      out.enhance_moves = Datasworn::from_json_data(Array[MoveEnhancement], data["enhance_moves"])
      out
    end

    def to_json_data
      data = { "choice_type" => "choice" }
      data["label"] = Datasworn::to_json_data(label)
      data["enhance_asset"] = Datasworn::to_json_data(enhance_asset) unless enhance_asset.nil?
      data["enhance_moves"] = Datasworn::to_json_data(enhance_moves) unless enhance_moves.nil?
      data
    end
  end

  # Represents a grouping of options in a list of choices.
  class AssetOptionFieldSelectEnhancementChoiceChoiceGroup < AssetOptionFieldSelectEnhancementChoice
    attr_accessor :choices
    attr_accessor :name

    def self.from_json_data(data)
      out = AssetOptionFieldSelectEnhancementChoiceChoiceGroup.new
      out.choice_type = "choice_group"
      out.choices = Datasworn::from_json_data(Hash[String, SelectEnhancementFieldChoice], data["choices"])
      out.name = Datasworn::from_json_data(InputLabel, data["name"])
      out
    end

    def to_json_data
      data = { "choice_type" => "choice_group" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["name"] = Datasworn::to_json_data(name)
      data
    end
  end

  # Select from player and/or asset enhancements. Use it to describe modal
  # abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
  # (Sundered Isles).
  class AssetOptionFieldSelectEnhancement < AssetOptionField
    attr_accessor :choices
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetOptionFieldSelectEnhancement.new
      out.field_type = "select_enhancement"
      out.choices = Datasworn::from_json_data(Hash[String, AssetOptionFieldSelectEnhancementChoice], data["choices"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(DictKey, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "select_enhancement" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # Represents a list of mutually exclusive choices.
  class AssetOptionFieldSelectValue < AssetOptionField
    attr_accessor :choices
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetOptionFieldSelectValue.new
      out.field_type = "select_value"
      out.choices = Datasworn::from_json_data(Hash[String, SelectValueFieldChoice], data["choices"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(DictKey, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "select_value" }
      data["choices"] = Datasworn::to_json_data(choices)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  # Represents an input that accepts plain text.
  class AssetOptionFieldText < AssetOptionField
    attr_accessor :label
    attr_accessor :value
    attr_accessor :icon

    def self.from_json_data(data)
      out = AssetOptionFieldText.new
      out.field_type = "text"
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(String, data["value"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out
    end

    def to_json_data
      data = { "field_type" => "text" }
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data
    end
  end

  class AtlasCollectionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ATLAS = new("atlas")

    def self.from_json_data(data)
      {
        "atlas" => ATLAS,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class AtlasCollection
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source

    # The primary name/label for this item.
    attr_accessor :name
    attr_accessor :type

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :collections

    # A thematic color associated with this collection.
    attr_accessor :color
    attr_accessor :contents

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This collection's content enhances the identified collection, rather than
    # being a standalone collection of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This collection replaces the identified collection. References to the
    # replaced collection can be considered equivalent to this collection.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = AtlasCollection.new
      out.id = Datasworn::from_json_data(AtlasCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(AtlasCollectionType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.collections = Datasworn::from_json_data(Hash[String, AtlasCollection], data["collections"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.contents = Datasworn::from_json_data(Hash[String, AtlasEntry], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(AtlasCollectionID, data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(AtlasCollectionID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["collections"] = Datasworn::to_json_data(collections) unless collections.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["contents"] = Datasworn::to_json_data(contents) unless contents.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A unique ID for an AtlasCollection.
  class AtlasCollectionID
    attr_accessor :value

    def self.from_json_data(data)
      out = AtlasCollectionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class AtlasEntryType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ATLAS_ENTRY = new("atlas_entry")

    def self.from_json_data(data)
      {
        "atlas_entry" => ATLAS_ENTRY,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An atlas entry, like the Ironlands region entries found in classic
  # Ironsworn.
  class AtlasEntry
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source
    attr_accessor :description
    attr_accessor :features

    # The primary name/label for this item.
    attr_accessor :name
    attr_accessor :type

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :quest_starter
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags
    attr_accessor :your_truth

    def self.from_json_data(data)
      out = AtlasEntry.new
      out.id = Datasworn::from_json_data(AtlasEntryID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.features = Datasworn::from_json_data(Array[MarkdownString], data["features"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(AtlasEntryType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.quest_starter = Datasworn::from_json_data(MarkdownString, data["quest_starter"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out.your_truth = Datasworn::from_json_data(MarkdownString, data["your_truth"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["description"] = Datasworn::to_json_data(description)
      data["features"] = Datasworn::to_json_data(features)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["quest_starter"] = Datasworn::to_json_data(quest_starter) unless quest_starter.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data["your_truth"] = Datasworn::to_json_data(your_truth) unless your_truth.nil?
      data
    end
  end

  # A unique ID for an AtlasEntry.
  class AtlasEntryID
    attr_accessor :value

    def self.from_json_data(data)
      out = AtlasEntryID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Information on the original creator of this material.
  class AuthorInfo
    attr_accessor :name

    # An optional email contact for the author
    attr_accessor :email

    # An optional URL for the author's website.
    attr_accessor :url

    def self.from_json_data(data)
      out = AuthorInfo.new
      out.name = Datasworn::from_json_data(String, data["name"])
      out.email = Datasworn::from_json_data(String, data["email"])
      out.url = Datasworn::from_json_data(String, data["url"])
      out
    end

    def to_json_data
      data = {}
      data["name"] = Datasworn::to_json_data(name)
      data["email"] = Datasworn::to_json_data(email) unless email.nil?
      data["url"] = Datasworn::to_json_data(url) unless url.nil?
      data
    end
  end

  # Challenge rank, represented as an integer from 1 (troublesome) to 5 (epic).
  class ChallengeRank
    attr_accessor :value

    def self.from_json_data(data)
      out = ChallengeRank.new
      out.value = Datasworn.from_json_data(Integer, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A basic, rollable player character resource specified by the ruleset.
  class ConditionMeterKey
    attr_accessor :value

    def self.from_json_data(data)
      out = ConditionMeterKey.new
      out.value = Datasworn.from_json_data(DictKey, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Describes a standard player character condition meter.
  class ConditionMeterRule
    # A description of this condition meter.
    attr_accessor :description
    attr_accessor :label

    # The maximum value of this meter.
    attr_accessor :max

    # The minimum value of this meter.
    attr_accessor :min

    # Is this meter's `value` usable as a stat in an action roll?
    attr_accessor :rollable

    # Is this condition meter shared by all players?
    attr_accessor :shared

    # The current value of this meter.
    attr_accessor :value

    def self.from_json_data(data)
      out = ConditionMeterRule.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.rollable = Datasworn::from_json_data(TrueClass, data["rollable"])
      out.shared = Datasworn::from_json_data(TrueClass, data["shared"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["label"] = Datasworn::to_json_data(label)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["rollable"] = Datasworn::to_json_data(rollable)
      data["shared"] = Datasworn::to_json_data(shared)
      data["value"] = Datasworn::to_json_data(value)
      data
    end
  end

  # A CSS color value.
  class CSSColor
    attr_accessor :value

    def self.from_json_data(data)
      out = CSSColor.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class DelveSiteType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    DELVE_SITE = new("delve_site")

    def self.from_json_data(data)
      {
        "delve_site" => DELVE_SITE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A delve site with a theme, domain, and denizens.
  class DelveSite
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source

    # Represents the delve site's denizen matrix as an array of objects.
    attr_accessor :denizens
    attr_accessor :description

    # The ID of the site's DelveSiteDomain card.
    attr_accessor :domain

    # The primary name/label for this item.
    attr_accessor :name
    attr_accessor :rank

    # The ID of the site's DelveSiteTheme card.
    attr_accessor :theme
    attr_accessor :type

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # An additional theme or domain card ID, for use with optional rules in
    # Ironsworn: Delve.
    attr_accessor :extra_card
    attr_accessor :icon

    # The ID of an atlas entry representing the region in which this delve site
    # is located.
    attr_accessor :region
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = DelveSite.new
      out.id = Datasworn::from_json_data(DelveSiteID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.denizens = Datasworn::from_json_data(Array[DelveSiteDenizen], data["denizens"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.domain = Datasworn::from_json_data(DelveSiteDomainID, data["domain"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rank = Datasworn::from_json_data(ChallengeRank, data["rank"])
      out.theme = Datasworn::from_json_data(DelveSiteThemeID, data["theme"])
      out.type = Datasworn::from_json_data(DelveSiteType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.extra_card = Datasworn::from_json_data(String, data["extra_card"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.region = Datasworn::from_json_data(AtlasEntryID, data["region"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["denizens"] = Datasworn::to_json_data(denizens)
      data["description"] = Datasworn::to_json_data(description)
      data["domain"] = Datasworn::to_json_data(domain)
      data["name"] = Datasworn::to_json_data(name)
      data["rank"] = Datasworn::to_json_data(rank)
      data["theme"] = Datasworn::to_json_data(theme)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["extra_card"] = Datasworn::to_json_data(extra_card) unless extra_card.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["region"] = Datasworn::to_json_data(region) unless region.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # Represents an entry in a site denizen matrix. Denizen matrices are described
  # in Ironsworn: Delve.
  class DelveSiteDenizen
    attr_accessor :frequency

    # High end of the dice range for this denizen.
    attr_accessor :max

    # Low end of the dice range for this denizen.
    attr_accessor :min

    # A name for the denizen, if it's different than the `name` property of
    # the NPC.
    attr_accessor :name

    # The ID of the relevant NPC entry, if one is specified.
    attr_accessor :npc

    def self.from_json_data(data)
      out = DelveSiteDenizen.new
      out.frequency = Datasworn::from_json_data(DelveSiteDenizenFrequency, data["frequency"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.npc = Datasworn::from_json_data(NpcID, data["npc"])
      out
    end

    def to_json_data
      data = {}
      data["frequency"] = Datasworn::to_json_data(frequency)
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["name"] = Datasworn::to_json_data(name) unless name.nil?
      data["npc"] = Datasworn::to_json_data(npc) unless npc.nil?
      data
    end
  end

  class DelveSiteDenizenFrequency
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    COMMON = new("common")
    RARE = new("rare")
    UNCOMMON = new("uncommon")
    UNFORESEEN = new("unforeseen")
    VERY_COMMON = new("very_common")

    def self.from_json_data(data)
      {
        "common" => COMMON,
        "rare" => RARE,
        "uncommon" => UNCOMMON,
        "unforeseen" => UNFORESEEN,
        "very_common" => VERY_COMMON,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class DelveSiteDomainType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    DELVE_SITE_DOMAIN = new("delve_site_domain")

    def self.from_json_data(data)
      {
        "delve_site_domain" => DELVE_SITE_DOMAIN,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A delve site Domain card.
  class DelveSiteDomain
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source
    attr_accessor :dangers
    attr_accessor :features

    # The primary name/label for this item.
    attr_accessor :name
    attr_accessor :summary
    attr_accessor :type

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :description
    attr_accessor :icon

    # An oracle table ID containing place name elements. For examples, see
    # oracle ID `delve/oracles/site_name/place/barrow`, and its siblings in
    # oracle collection ID `delve/collections/oracles/site_name/place`. These
    # oracles are used by the site name oracle from Ironsworn: Delve (ID:
    # delve/oracles/site_name/format) to create random names for delve sites.
    attr_accessor :name_oracle
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = DelveSiteDomain.new
      out.id = Datasworn::from_json_data(DelveSiteDomainID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.dangers = Datasworn::from_json_data(Array[OracleTableRowText], data["dangers"])
      out.features = Datasworn::from_json_data(Array[OracleTableRowText], data["features"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.type = Datasworn::from_json_data(DelveSiteDomainType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.name_oracle = Datasworn::from_json_data(OracleRollableID, data["name_oracle"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["dangers"] = Datasworn::to_json_data(dangers)
      data["features"] = Datasworn::to_json_data(features)
      data["name"] = Datasworn::to_json_data(name)
      data["summary"] = Datasworn::to_json_data(summary)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["name_oracle"] = Datasworn::to_json_data(name_oracle) unless name_oracle.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A unique ID for a DelveSiteDomain.
  class DelveSiteDomainID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteDomainID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID for a DelveSite.
  class DelveSiteID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class DelveSiteThemeType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    DELVE_SITE_THEME = new("delve_site_theme")

    def self.from_json_data(data)
      {
        "delve_site_theme" => DELVE_SITE_THEME,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A delve site theme card.
  class DelveSiteTheme
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source
    attr_accessor :dangers
    attr_accessor :features

    # The primary name/label for this item.
    attr_accessor :name
    attr_accessor :summary
    attr_accessor :type

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :description
    attr_accessor :icon
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = DelveSiteTheme.new
      out.id = Datasworn::from_json_data(DelveSiteThemeID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.dangers = Datasworn::from_json_data(Array[OracleTableRowText], data["dangers"])
      out.features = Datasworn::from_json_data(Array[OracleTableRowText], data["features"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.type = Datasworn::from_json_data(DelveSiteThemeType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["dangers"] = Datasworn::to_json_data(dangers)
      data["features"] = Datasworn::to_json_data(features)
      data["name"] = Datasworn::to_json_data(name)
      data["summary"] = Datasworn::to_json_data(summary)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A unique ID for a DelveSiteTheme.
  class DelveSiteThemeID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteThemeID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A simple dice roll expression with an optional modifer.
  class DiceExpression
    attr_accessor :value

    def self.from_json_data(data)
      out = DiceExpression.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A `snake_case` key used in a Datasworn dictionary object.
  class DictKey
    attr_accessor :value

    def self.from_json_data(data)
      out = DictKey.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # The ID of a Datasworn package that relies on an external package to provide
  # its ruleset.
  class ExpansionID
    attr_accessor :value

    def self.from_json_data(data)
      out = ExpansionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class I18nHint
    # The part of speech for this string.
    attr_accessor :part_of_speech

    def self.from_json_data(data)
      out = I18nHint.new
      out.part_of_speech = Datasworn::from_json_data(PartOfSpeech, data["part_of_speech"])
      out
    end

    def to_json_data
      data = {}
      data["part_of_speech"] = Datasworn::to_json_data(part_of_speech) unless part_of_speech.nil?
      data
    end
  end

  class I18nHintsTemplate
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :text3

    def self.from_json_data(data)
      out = I18nHintsTemplate.new
      out.text = Datasworn::from_json_data(I18nHint, data["text"])
      out.text2 = Datasworn::from_json_data(I18nHint, data["text2"])
      out.text3 = Datasworn::from_json_data(I18nHint, data["text3"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data["text2"] = Datasworn::to_json_data(text2) unless text2.nil?
      data["text3"] = Datasworn::to_json_data(text3) unless text3.nil?
      data
    end
  end

  # Internationalization/localization hints for the text content of this object.
  class I18nHints
    attr_accessor :template
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :text3

    def self.from_json_data(data)
      out = I18nHints.new
      out.template = Datasworn::from_json_data(I18nHintsTemplate, data["template"])
      out.text = Datasworn::from_json_data(I18nHint, data["text"])
      out.text2 = Datasworn::from_json_data(I18nHint, data["text2"])
      out.text3 = Datasworn::from_json_data(I18nHint, data["text3"])
      out
    end

    def to_json_data
      data = {}
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data["text2"] = Datasworn::to_json_data(text2) unless text2.nil?
      data["text3"] = Datasworn::to_json_data(text3) unless text3.nil?
      data
    end
  end

  # Describes a category of standard impacts/debilities.
  class ImpactCategory
    # A dictionary object of the Impacts in this category.
    attr_accessor :contents

    # A description of this impact category.
    attr_accessor :description

    # A label for this impact category.
    attr_accessor :label

    def self.from_json_data(data)
      out = ImpactCategory.new
      out.contents = Datasworn::from_json_data(Hash[String, ImpactRule], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out
    end

    def to_json_data
      data = {}
      data["contents"] = Datasworn::to_json_data(contents)
      data["description"] = Datasworn::to_json_data(description)
      data["label"] = Datasworn::to_json_data(label)
      data
    end
  end

  # Describes a standard impact/debility.
  class ImpactRule
    # A description of this impact.
    attr_accessor :description

    # The label for this impact.
    attr_accessor :label

    # Is this impact permanent?
    attr_accessor :permanent

    # Any ruleset condition meters that can't recover when this impact is
    # active.
    attr_accessor :prevents_recovery

    # Is this impact applied to all players at once?
    attr_accessor :shared

    def self.from_json_data(data)
      out = ImpactRule.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.permanent = Datasworn::from_json_data(TrueClass, data["permanent"])
      out.prevents_recovery = Datasworn::from_json_data(Array[ConditionMeterKey], data["prevents_recovery"])
      out.shared = Datasworn::from_json_data(TrueClass, data["shared"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["label"] = Datasworn::to_json_data(label)
      data["permanent"] = Datasworn::to_json_data(permanent)
      data["prevents_recovery"] = Datasworn::to_json_data(prevents_recovery)
      data["shared"] = Datasworn::to_json_data(shared)
      data
    end
  end

  # A localized label for an input. In some contexts it may be undesirable to
  # render this text, but it should always be exposed to assistive technology
  # (e.g. with `aria-label` in HTML).
  class InputLabel
    attr_accessor :value

    def self.from_json_data(data)
      out = InputLabel.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A localized plain text name or label.
  class Label
    attr_accessor :value

    def self.from_json_data(data)
      out = Label.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # An URL pointing to the location where this element's license can be found.
  # 
  # A `null` here indicates that the content provides __no__ license, and is not
  # intended for redistribution.
  class License
    attr_accessor :value

    def self.from_json_data(data)
      out = License.new
      out.value = Datasworn.from_json_data(WebURL, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Localized text, formatted in Markdown.
  # 
  # It uses some custom syntax; e.g. `{{table:some_oracle_table_id}}` indicates
  # that the referenced oracle table is rendered there in the source material.
  class MarkdownString
    attr_accessor :value

    def self.from_json_data(data)
      out = MarkdownString.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class Move
    attr_accessor :roll_type

    def self.from_json_data(data)
      {
        "action_roll" => MoveActionRoll,
        "no_roll" => MoveNoRoll,
        "progress_roll" => MoveProgressRoll,
        "special_track" => MoveSpecialTrack,
      }[data["roll_type"]].from_json_data(data)
    end
  end

  class MoveActionRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A move that makes an action roll.
  class MoveActionRoll < Move
    attr_accessor :id
    attr_accessor :source
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :text
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :oracles
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = MoveActionRoll.new
      out.roll_type = "action_roll"
      out.id = Datasworn::from_json_data(MoveID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerActionRoll, data["trigger"])
      out.type = Datasworn::from_json_data(MoveActionRollType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.oracles = Datasworn::from_json_data(Array[OracleRollableID], data["oracles"])
      out.replaces = Datasworn::from_json_data(MoveID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = { "roll_type" => "action_roll" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class MoveNoRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A move that makes no progress rolls or action rolls.
  class MoveNoRoll < Move
    attr_accessor :id
    attr_accessor :source
    attr_accessor :name
    attr_accessor :text
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :oracles
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = MoveNoRoll.new
      out.roll_type = "no_roll"
      out.id = Datasworn::from_json_data(MoveID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerNoRoll, data["trigger"])
      out.type = Datasworn::from_json_data(MoveNoRollType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.oracles = Datasworn::from_json_data(Array[OracleRollableID], data["oracles"])
      out.replaces = Datasworn::from_json_data(MoveID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = { "roll_type" => "no_roll" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["name"] = Datasworn::to_json_data(name)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class MoveProgressRollType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A progress move that rolls on a standard progress track type (whose features
  # are defined by this move object). For progress rolls that use special
  # tracks, see MoveSpecialTrack.
  class MoveProgressRoll < Move
    attr_accessor :id
    attr_accessor :source
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :text
    attr_accessor :tracks
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :oracles
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = MoveProgressRoll.new
      out.roll_type = "progress_roll"
      out.id = Datasworn::from_json_data(MoveID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.tracks = Datasworn::from_json_data(ProgressTrackTypeInfo, data["tracks"])
      out.trigger = Datasworn::from_json_data(TriggerProgressRoll, data["trigger"])
      out.type = Datasworn::from_json_data(MoveProgressRollType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.oracles = Datasworn::from_json_data(Array[OracleRollableID], data["oracles"])
      out.replaces = Datasworn::from_json_data(MoveID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = { "roll_type" => "progress_roll" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["text"] = Datasworn::to_json_data(text)
      data["tracks"] = Datasworn::to_json_data(tracks)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class MoveSpecialTrackType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE = new("move")

    def self.from_json_data(data)
      {
        "move" => MOVE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A progress move that rolls on a special track, such as Legacies (Starforged)
  # or Bonds (classic Ironsworn). For progress moves that use standard progress
  # tracks, see MoveProgressRoll instead.
  class MoveSpecialTrack < Move
    attr_accessor :id
    attr_accessor :source
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :text
    attr_accessor :trigger
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :oracles
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = MoveSpecialTrack.new
      out.roll_type = "special_track"
      out.id = Datasworn::from_json_data(MoveID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.outcomes = Datasworn::from_json_data(MoveOutcomes, data["outcomes"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.trigger = Datasworn::from_json_data(TriggerSpecialTrack, data["trigger"])
      out.type = Datasworn::from_json_data(MoveSpecialTrackType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.oracles = Datasworn::from_json_data(Array[OracleRollableID], data["oracles"])
      out.replaces = Datasworn::from_json_data(MoveID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = { "roll_type" => "special_track" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["name"] = Datasworn::to_json_data(name)
      data["outcomes"] = Datasworn::to_json_data(outcomes)
      data["text"] = Datasworn::to_json_data(text)
      data["trigger"] = Datasworn::to_json_data(trigger)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class MoveCategoryType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MOVE_CATEGORY = new("move_category")

    def self.from_json_data(data)
      {
        "move_category" => MOVE_CATEGORY,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class MoveCategory
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source

    # The primary name/label for this item.
    attr_accessor :name
    attr_accessor :type

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this collection.
    attr_accessor :color
    attr_accessor :contents

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This collection's content enhances the identified collection, rather than
    # being a standalone collection of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This collection replaces the identified collection. References to the
    # replaced collection can be considered equivalent to this collection.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = MoveCategory.new
      out.id = Datasworn::from_json_data(MoveCategoryID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(MoveCategoryType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.contents = Datasworn::from_json_data(Hash[String, Move], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(MoveCategoryID, data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(MoveCategoryID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["contents"] = Datasworn::to_json_data(contents) unless contents.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A unique ID for a MoveCategory.
  class MoveCategoryID
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveCategoryID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class MoveEnhancement
    attr_accessor :roll_type

    def self.from_json_data(data)
      {
        "action_roll" => MoveEnhancementActionRoll,
        "no_roll" => MoveEnhancementNoRoll,
        "progress_roll" => MoveEnhancementProgressRoll,
        "special_track" => MoveEnhancementSpecialTrack,
      }[data["roll_type"]].from_json_data(data)
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveEnhancementActionRoll < MoveEnhancement
    attr_accessor :enhances
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveEnhancementActionRoll.new
      out.roll_type = "action_roll"
      out.enhances = Datasworn::from_json_data(Array[MoveIDWildcard], data["enhances"])
      out.trigger = Datasworn::from_json_data(TriggerActionRollEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = { "roll_type" => "action_roll" }
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveEnhancementNoRoll < MoveEnhancement
    attr_accessor :enhances
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveEnhancementNoRoll.new
      out.roll_type = "no_roll"
      out.enhances = Datasworn::from_json_data(Array[MoveIDWildcard], data["enhances"])
      out.trigger = Datasworn::from_json_data(TriggerNoRollEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = { "roll_type" => "no_roll" }
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveEnhancementProgressRoll < MoveEnhancement
    attr_accessor :enhances
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveEnhancementProgressRoll.new
      out.roll_type = "progress_roll"
      out.enhances = Datasworn::from_json_data(Array[MoveIDWildcard], data["enhances"])
      out.trigger = Datasworn::from_json_data(TriggerProgressRollEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = { "roll_type" => "progress_roll" }
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  # An object that describes changes to a move. These changes should be applied
  # recursively, altering only the specified properties; enhanced arrays should
  # be concatencated with the original array value.
  class MoveEnhancementSpecialTrack < MoveEnhancement
    attr_accessor :enhances
    attr_accessor :trigger

    def self.from_json_data(data)
      out = MoveEnhancementSpecialTrack.new
      out.roll_type = "special_track"
      out.enhances = Datasworn::from_json_data(Array[MoveIDWildcard], data["enhances"])
      out.trigger = Datasworn::from_json_data(TriggerSpecialTrackEnhancement, data["trigger"])
      out
    end

    def to_json_data
      data = { "roll_type" => "special_track" }
      data["enhances"] = Datasworn::to_json_data(enhances)
      data["trigger"] = Datasworn::to_json_data(trigger) unless trigger.nil?
      data
    end
  end

  # A move ID, for a standard move or a unique asset move
  class MoveID
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A move ID with wildcards.
  class MoveIDWildcard
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveIDWildcard.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class MoveOutcome
    attr_accessor :text
    attr_accessor :oracle_rolls

    def self.from_json_data(data)
      out = MoveOutcome.new
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.oracle_rolls = Datasworn::from_json_data(Array[OracleRoll], data["oracle_rolls"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data["oracle_rolls"] = Datasworn::to_json_data(oracle_rolls) unless oracle_rolls.nil?
      data
    end
  end

  # A standalone localized description for each move outcome (miss, weak hit,
  # or strong hit). This is for for e.g. VTT implementations, where it's often
  # useful to display only the rules text relevant to a roll result.
  # 
  #   This often requires light editorialization to create text that can stand
  # alone without reference to the rest of the move. For example, 'as above'
  # (in reference to another move outcome) shouldn't be used here; instead, the
  # relevant text should be repeated.
  class MoveOutcomes
    attr_accessor :miss
    attr_accessor :strong_hit
    attr_accessor :weak_hit

    def self.from_json_data(data)
      out = MoveOutcomes.new
      out.miss = Datasworn::from_json_data(MoveOutcome, data["miss"])
      out.strong_hit = Datasworn::from_json_data(MoveOutcome, data["strong_hit"])
      out.weak_hit = Datasworn::from_json_data(MoveOutcome, data["weak_hit"])
      out
    end

    def to_json_data
      data = {}
      data["miss"] = Datasworn::to_json_data(miss)
      data["strong_hit"] = Datasworn::to_json_data(strong_hit)
      data["weak_hit"] = Datasworn::to_json_data(weak_hit)
      data
    end
  end

  class NpcType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    NPC = new("npc")

    def self.from_json_data(data)
      {
        "npc" => NPC,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A non-player character entry, similar to those in Chapter 5 of the Ironsworn
  # Rulebook, or Chapter 4 of Starforged.
  class Npc
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source
    attr_accessor :description
    attr_accessor :drives
    attr_accessor :features

    # The primary name/label for this item.
    attr_accessor :name
    attr_accessor :nature

    # The suggested challenge rank for this NPC.
    attr_accessor :rank
    attr_accessor :tactics
    attr_accessor :type

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :quest_starter
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags
    attr_accessor :variants
    attr_accessor :your_truth

    def self.from_json_data(data)
      out = Npc.new
      out.id = Datasworn::from_json_data(NpcID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.drives = Datasworn::from_json_data(Array[MarkdownString], data["drives"])
      out.features = Datasworn::from_json_data(Array[MarkdownString], data["features"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.nature = Datasworn::from_json_data(NpcNature, data["nature"])
      out.rank = Datasworn::from_json_data(ChallengeRank, data["rank"])
      out.tactics = Datasworn::from_json_data(Array[MarkdownString], data["tactics"])
      out.type = Datasworn::from_json_data(NpcType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.quest_starter = Datasworn::from_json_data(MarkdownString, data["quest_starter"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out.variants = Datasworn::from_json_data(Hash[String, NpcVariant], data["variants"])
      out.your_truth = Datasworn::from_json_data(MarkdownString, data["your_truth"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["description"] = Datasworn::to_json_data(description)
      data["drives"] = Datasworn::to_json_data(drives)
      data["features"] = Datasworn::to_json_data(features)
      data["name"] = Datasworn::to_json_data(name)
      data["nature"] = Datasworn::to_json_data(nature)
      data["rank"] = Datasworn::to_json_data(rank)
      data["tactics"] = Datasworn::to_json_data(tactics)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["quest_starter"] = Datasworn::to_json_data(quest_starter) unless quest_starter.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data["variants"] = Datasworn::to_json_data(variants) unless variants.nil?
      data["your_truth"] = Datasworn::to_json_data(your_truth) unless your_truth.nil?
      data
    end
  end

  class NpcCollectionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    NPC_COLLECTION = new("npc_collection")

    def self.from_json_data(data)
      {
        "npc_collection" => NPC_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class NpcCollection
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source

    # The primary name/label for this item.
    attr_accessor :name
    attr_accessor :type

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name

    # A thematic color associated with this collection.
    attr_accessor :color
    attr_accessor :contents

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This collection's content enhances the identified collection, rather than
    # being a standalone collection of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This collection replaces the identified collection. References to the
    # replaced collection can be considered equivalent to this collection.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = NpcCollection.new
      out.id = Datasworn::from_json_data(NpcCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(NpcCollectionType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.contents = Datasworn::from_json_data(Hash[String, Npc], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(NpcCollectionID, data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(NpcCollectionID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["contents"] = Datasworn::to_json_data(contents) unless contents.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A unique ID for a NpcCollection.
  class NpcCollectionID
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcCollectionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A unique ID for a Npc.
  class NpcID
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A localized category label describing the nature of this NPC.
  # 
  # In Ironsworn classic, this is probably the singular form of the parent
  # collection's name.
  # 
  # For Starforged, see the table on p. 258 for examples.
  class NpcNature
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcNature.new
      out.value = Datasworn.from_json_data(Label, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class NpcVariant
    # The unique Datasworn ID for this item.
    attr_accessor :id
    attr_accessor :description
    attr_accessor :name
    attr_accessor :nature

    # The suggested challenge rank for this NPC.
    attr_accessor :rank

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment
    attr_accessor :summary

    def self.from_json_data(data)
      out = NpcVariant.new
      out.id = Datasworn::from_json_data(NpcVariantID, data["_id"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.nature = Datasworn::from_json_data(NpcNature, data["nature"])
      out.rank = Datasworn::from_json_data(ChallengeRank, data["rank"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["description"] = Datasworn::to_json_data(description)
      data["name"] = Datasworn::to_json_data(name)
      data["nature"] = Datasworn::to_json_data(nature)
      data["rank"] = Datasworn::to_json_data(rank)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data
    end
  end

  # A unique ID for a NpcVariant.
  class NpcVariantID
    attr_accessor :value

    def self.from_json_data(data)
      out = NpcVariantID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class ObjectType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ASSET = new("asset")
    ASSET_COLLECTION = new("asset_collection")
    ATLAS_COLLECTION = new("atlas_collection")
    ATLAS_ENTRY = new("atlas_entry")
    DELVE_SITE = new("delve_site")
    DELVE_SITE_DOMAIN = new("delve_site_domain")
    DELVE_SITE_THEME = new("delve_site_theme")
    MOVE = new("move")
    MOVE_CATEGORY = new("move_category")
    NPC = new("npc")
    NPC_COLLECTION = new("npc_collection")
    ORACLE_COLLECTION = new("oracle_collection")
    ORACLE_ROLLABLE = new("oracle_rollable")
    RARITY = new("rarity")
    TRUTH = new("truth")

    def self.from_json_data(data)
      {
        "asset" => ASSET,
        "asset_collection" => ASSET_COLLECTION,
        "atlas_collection" => ATLAS_COLLECTION,
        "atlas_entry" => ATLAS_ENTRY,
        "delve_site" => DELVE_SITE,
        "delve_site_domain" => DELVE_SITE_DOMAIN,
        "delve_site_theme" => DELVE_SITE_THEME,
        "move" => MOVE,
        "move_category" => MOVE_CATEGORY,
        "npc" => NPC,
        "npc_collection" => NPC_COLLECTION,
        "oracle_collection" => ORACLE_COLLECTION,
        "oracle_rollable" => ORACLE_ROLLABLE,
        "rarity" => RARITY,
        "truth" => TRUTH,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleCollection
    attr_accessor :oracle_type

    def self.from_json_data(data)
      {
        "OracleTableSharedText3" => OracleCollectionOracleTableSharedText3,
        "table_shared_rolls" => OracleCollectionTableSharedRolls,
        "table_shared_text" => OracleCollectionTableSharedText,
        "table_shared_text2" => OracleCollectionTableSharedText2,
        "tables" => OracleCollectionTables,
      }[data["oracle_type"]].from_json_data(data)
    end
  end

  # The label at the head of each table column. The `roll` key refers to the
  # roll column showing the dice range (`min` and `max` on each table row).
  class OracleCollectionOracleTableSharedText3ColumnLabels
    attr_accessor :text

    def self.from_json_data(data)
      out = OracleCollectionOracleTableSharedText3ColumnLabels.new
      out.text = Datasworn::from_json_data(Label, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class OracleCollectionOracleTableSharedText3Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection representing a single table with multiple roll columns,
  # and 2 shared text columns.
  class OracleCollectionOracleTableSharedText3 < OracleCollection
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :contents
    attr_accessor :description
    attr_accessor :enhances
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleCollectionOracleTableSharedText3.new
      out.oracle_type = "OracleTableSharedText3"
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleCollectionOracleTableSharedText3ColumnLabels, data["column_labels"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(OracleCollectionOracleTableSharedText3Type, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleColumnText3], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(OracleCollectionID, data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(OracleCollectionID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "OracleTableSharedText3" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["contents"] = Datasworn::to_json_data(contents) unless contents.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # Provides column labels for this table. The `roll` key refers to the roll
  # column showing the dice range (`min` and `max` on each table row). For all
  # other column labels, see the `name` property of each child `OracleColumn`.
  class OracleCollectionTableSharedRollsColumnLabels
    attr_accessor :roll

    def self.from_json_data(data)
      out = OracleCollectionTableSharedRollsColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data
    end
  end

  class OracleCollectionTableSharedRollsType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection representing a single table with one roll column and
  # multiple `result` columns.
  class OracleCollectionTableSharedRolls < OracleCollection
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :contents
    attr_accessor :description
    attr_accessor :enhances
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleCollectionTableSharedRolls.new
      out.oracle_type = "table_shared_rolls"
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleCollectionTableSharedRollsColumnLabels, data["column_labels"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(OracleCollectionTableSharedRollsType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleColumnText], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(OracleCollectionID, data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(OracleCollectionID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_shared_rolls" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["contents"] = Datasworn::to_json_data(contents) unless contents.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # The label at the head of each table column. The `roll` key refers to the
  # roll column showing the dice range (`min` and `max` on each table row).
  class OracleCollectionTableSharedTextColumnLabels
    attr_accessor :text

    def self.from_json_data(data)
      out = OracleCollectionTableSharedTextColumnLabels.new
      out.text = Datasworn::from_json_data(Label, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class OracleCollectionTableSharedTextType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection representing a single table with multiple roll columns
  # and one `result` column.
  class OracleCollectionTableSharedText < OracleCollection
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :contents
    attr_accessor :description
    attr_accessor :enhances
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleCollectionTableSharedText.new
      out.oracle_type = "table_shared_text"
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleCollectionTableSharedTextColumnLabels, data["column_labels"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(OracleCollectionTableSharedTextType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleColumnText], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(OracleCollectionID, data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(OracleCollectionID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_shared_text" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["contents"] = Datasworn::to_json_data(contents) unless contents.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # The label at the head of each table column. The `roll` key refers to the
  # roll column showing the dice range (`min` and `max` on each table row).
  class OracleCollectionTableSharedText2ColumnLabels
    attr_accessor :text
    attr_accessor :text2

    def self.from_json_data(data)
      out = OracleCollectionTableSharedText2ColumnLabels.new
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data
    end
  end

  class OracleCollectionTableSharedText2Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection representing a single table with multiple roll columns,
  # and 2 shared text columns.
  class OracleCollectionTableSharedText2 < OracleCollection
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :contents
    attr_accessor :description
    attr_accessor :enhances
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleCollectionTableSharedText2.new
      out.oracle_type = "table_shared_text2"
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleCollectionTableSharedText2ColumnLabels, data["column_labels"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(OracleCollectionTableSharedText2Type, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleColumnText2], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(OracleCollectionID, data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(OracleCollectionID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_shared_text2" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["contents"] = Datasworn::to_json_data(contents) unless contents.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleCollectionTablesType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection that represents a category or grouping of tables, which
  # may themselves be `OracleTablesCollection`s.
  class OracleCollectionTables < OracleCollection
    attr_accessor :id
    attr_accessor :source
    attr_accessor :name
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :collections
    attr_accessor :color
    attr_accessor :contents
    attr_accessor :description
    attr_accessor :enhances
    attr_accessor :icon
    attr_accessor :images
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleCollectionTables.new
      out.oracle_type = "tables"
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(OracleCollectionTablesType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.collections = Datasworn::from_json_data(Hash[String, OracleCollection], data["collections"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleTableRollable], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(OracleCollectionID, data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(OracleCollectionID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "tables" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["collections"] = Datasworn::to_json_data(collections) unless collections.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["contents"] = Datasworn::to_json_data(contents) unless contents.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A unique ID for an OracleCollection.
  class OracleCollectionID
    attr_accessor :value

    def self.from_json_data(data)
      out = OracleCollectionID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class OracleColumnTextOracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    COLUMN_TEXT = new("column_text")

    def self.from_json_data(data)
      {
        "column_text" => COLUMN_TEXT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleColumnTextType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents a single column in an OracleCollection.
  class OracleColumnText
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The roll used to select a result on this oracle.
    attr_accessor :dice

    # The primary label at the head of this column.
    attr_accessor :name
    attr_accessor :oracle_type

    # An array of objects, each representing a single row of the table.
    attr_accessor :rows
    attr_accessor :type

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # An optional thematic color for this column. For an example, see "Basic
    # Creature Form" (Starforged p. 337)
    attr_accessor :color

    # An optional icon for this column.
    attr_accessor :icon

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match

    # Indicates that this object replaces the identified OracleRollable.
    # References to the replaced object can be considered equivalent to this
    # object.
    attr_accessor :replaces
    attr_accessor :suggestions

    # Optional secondary text at the head of this column. For best results, this
    # should be no more than a few words in length.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleColumnText.new
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(OracleColumnTextOracleType, data["oracle_type"])
      out.rows = Datasworn::from_json_data(Array[OracleTableRowText], data["rows"])
      out.type = Datasworn::from_json_data(OracleColumnTextType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.replaces = Datasworn::from_json_data(OracleRollableID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleColumnText2OracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    COLUMN_TEXT2 = new("column_text2")

    def self.from_json_data(data)
      {
        "column_text2" => COLUMN_TEXT2,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleColumnText2Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleColumnText2
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The roll used to select a result on this oracle.
    attr_accessor :dice

    # The primary label at the head of this column.
    attr_accessor :name
    attr_accessor :oracle_type

    # An array of objects, each representing a single row of the table.
    attr_accessor :rows
    attr_accessor :type

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # An optional thematic color for this column. For an example, see "Basic
    # Creature Form" (Starforged p. 337)
    attr_accessor :color

    # An optional icon for this column.
    attr_accessor :icon

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match

    # Indicates that this object replaces the identified OracleRollable.
    # References to the replaced object can be considered equivalent to this
    # object.
    attr_accessor :replaces
    attr_accessor :suggestions

    # Optional secondary text at the head of this column. For best results, this
    # should be no more than a few words in length.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleColumnText2.new
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(OracleColumnText2OracleType, data["oracle_type"])
      out.rows = Datasworn::from_json_data(Array[OracleTableRowText2], data["rows"])
      out.type = Datasworn::from_json_data(OracleColumnText2Type, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.replaces = Datasworn::from_json_data(OracleRollableID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class OracleColumnText3OracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    COLUMN_TEXT3 = new("column_text3")

    def self.from_json_data(data)
      {
        "column_text3" => COLUMN_TEXT3,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleColumnText3Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleColumnText3
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # The roll used to select a result on this oracle.
    attr_accessor :dice

    # The primary label at the head of this column.
    attr_accessor :name
    attr_accessor :oracle_type

    # An array of objects, each representing a single row of the table.
    attr_accessor :rows
    attr_accessor :type

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # An optional thematic color for this column. For an example, see "Basic
    # Creature Form" (Starforged p. 337)
    attr_accessor :color

    # An optional icon for this column.
    attr_accessor :icon

    # Most oracle tables are insensitive to matches, but a few define special
    # match behavior.
    attr_accessor :match

    # Indicates that this object replaces the identified OracleRollable.
    # References to the replaced object can be considered equivalent to this
    # object.
    attr_accessor :replaces
    attr_accessor :suggestions

    # Optional secondary text at the head of this column. For best results, this
    # should be no more than a few words in length.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleColumnText3.new
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(OracleColumnText3OracleType, data["oracle_type"])
      out.rows = Datasworn::from_json_data(Array[OracleTableRowText3], data["rows"])
      out.type = Datasworn::from_json_data(OracleColumnText3Type, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.replaces = Datasworn::from_json_data(OracleRollableID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # Special roll instructions to use when rolling multiple times on a single
  # oracle.
  class OracleDuplicateBehavior
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # Duplicates results should be kept.
    KEEP = new("keep")

    # Duplicate results should be kept, and they compound to make things worse.
    MAKE_IT_WORSE = new("make_it_worse")

    # Duplicate results should be re-rolled.
    REROLL = new("reroll")

    def self.from_json_data(data)
      {
        "keep" => KEEP,
        "make_it_worse" => MAKE_IT_WORSE,
        "reroll" => REROLL,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleMatchBehavior
    attr_accessor :text

    def self.from_json_data(data)
      out = OracleMatchBehavior.new
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class OracleRoll
    # Both Ironsworn and Starforged explicitly recommend *against* rolling
    # all details at once. That said, some oracle results only provide useful
    # information once a secondary roll occurs, such as "Action + Theme" or
    # "Roll twice".
    attr_accessor :auto
    attr_accessor :dice

    # Special rules on how to handle duplicate results, when rolling multiple
    # times.
    attr_accessor :duplicates

    # The number of times to roll.
    attr_accessor :number_of_rolls
    attr_accessor :oracle

    def self.from_json_data(data)
      out = OracleRoll.new
      out.auto = Datasworn::from_json_data(TrueClass, data["auto"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.duplicates = Datasworn::from_json_data(OracleDuplicateBehavior, data["duplicates"])
      out.number_of_rolls = Datasworn::from_json_data(Integer, data["number_of_rolls"])
      out.oracle = Datasworn::from_json_data(OracleRollableID, data["oracle"])
      out
    end

    def to_json_data
      data = {}
      data["auto"] = Datasworn::to_json_data(auto)
      data["dice"] = Datasworn::to_json_data(dice)
      data["duplicates"] = Datasworn::to_json_data(duplicates)
      data["number_of_rolls"] = Datasworn::to_json_data(number_of_rolls)
      data["oracle"] = Datasworn::to_json_data(oracle)
      data
    end
  end

  # Provides string templates that may be used in place of the static
  # row text from `OracleTableRow#text`, `OracleTableRow#text2`, and
  # `OracleTableRow#text3`.
  # 
  #   These strings are formatted in Markdown, but use a special syntax for
  # their placeholders: `{{text:some_oracle_table_id}}`. The placeholder should
  # be replaced with the value of a rolled (or selected) `OracleTableRow#text`
  # from the target oracle table ID.
  class OracleRollTemplate
    # A string template that may be used in place of OracleTableRow#text.
    attr_accessor :text

    # A string template that may be used in place of OracleTableRow#text2.
    attr_accessor :text2

    # A string template that may be used in place of OracleTableRow#text3.
    attr_accessor :text3

    def self.from_json_data(data)
      out = OracleRollTemplate.new
      out.text = Datasworn::from_json_data(TemplateString, data["text"])
      out.text2 = Datasworn::from_json_data(TemplateString, data["text2"])
      out.text3 = Datasworn::from_json_data(TemplateString, data["text3"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data["text2"] = Datasworn::to_json_data(text2) unless text2.nil?
      data["text3"] = Datasworn::to_json_data(text3) unless text3.nil?
      data
    end
  end

  # A unique ID for an OracleRollable.
  class OracleRollableID
    attr_accessor :value

    def self.from_json_data(data)
      out = OracleRollableID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class OracleTableRollable
    attr_accessor :oracle_type

    def self.from_json_data(data)
      {
        "table_text" => OracleTableRollableTableText,
        "table_text2" => OracleTableRollableTableText2,
        "table_text3" => OracleTableRollableTableText3,
      }[data["oracle_type"]].from_json_data(data)
    end
  end

  # The label at the head of each table column. The `roll` key refers to the
  # roll column showing the dice range (`min` and `max` on each table row).
  class OracleTableRollableTableTextColumnLabels
    attr_accessor :roll
    attr_accessor :text

    def self.from_json_data(data)
      out = OracleTableRollableTableTextColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class OracleTableRollableTableTextType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTableRollableTableTextRecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleTableRollableTableTextRecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  # Represents a basic rollable oracle table with one roll column and one text
  # result column.
  class OracleTableRollableTableText < OracleTableRollable
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :description
    attr_accessor :icon
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleTableRollableTableText.new
      out.oracle_type = "table_text"
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleTableRollableTableTextColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleTableRowText], data["rows"])
      out.type = Datasworn::from_json_data(OracleTableRollableTableTextType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleTableRollableTableTextRecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(OracleRollableID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_text" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # The label at the head of each table column. The `roll` key refers to the
  # roll column showing the dice range (`min` and `max` on each table row).
  class OracleTableRollableTableText2ColumnLabels
    attr_accessor :roll
    attr_accessor :text
    attr_accessor :text2

    def self.from_json_data(data)
      out = OracleTableRollableTableText2ColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data
    end
  end

  class OracleTableRollableTableText2Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTableRollableTableText2RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleTableRollableTableText2RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  # A rollable oracle table with one roll column and two text columns.
  class OracleTableRollableTableText2 < OracleTableRollable
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :description
    attr_accessor :icon
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleTableRollableTableText2.new
      out.oracle_type = "table_text2"
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleTableRollableTableText2ColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleTableRowText2], data["rows"])
      out.type = Datasworn::from_json_data(OracleTableRollableTableText2Type, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleTableRollableTableText2RecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(OracleRollableID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_text2" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # The label at the head of each table column. The `roll` key refers to the
  # roll column showing the dice range (`min` and `max` on each table row).
  class OracleTableRollableTableText3ColumnLabels
    attr_accessor :roll
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :text3

    def self.from_json_data(data)
      out = OracleTableRollableTableText3ColumnLabels.new
      out.roll = Datasworn::from_json_data(Label, data["roll"])
      out.text = Datasworn::from_json_data(Label, data["text"])
      out.text2 = Datasworn::from_json_data(Label, data["text2"])
      out.text3 = Datasworn::from_json_data(Label, data["text3"])
      out
    end

    def to_json_data
      data = {}
      data["roll"] = Datasworn::to_json_data(roll)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data["text3"] = Datasworn::to_json_data(text3)
      data
    end
  end

  class OracleTableRollableTableText3Type
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_ROLLABLE = new("oracle_rollable")

    def self.from_json_data(data)
      {
        "oracle_rollable" => ORACLE_ROLLABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTableRollableTableText3RecommendedRolls
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = OracleTableRollableTableText3RecommendedRolls.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data
    end
  end

  # A rollable oracle table with one roll column and 3 text columns.
  class OracleTableRollableTableText3 < OracleTableRollable
    attr_accessor :id
    attr_accessor :source
    attr_accessor :column_labels
    attr_accessor :dice
    attr_accessor :name
    attr_accessor :rows
    attr_accessor :type
    attr_accessor :comment
    attr_accessor :canonical_name
    attr_accessor :description
    attr_accessor :icon
    attr_accessor :match
    attr_accessor :recommended_rolls
    attr_accessor :replaces
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleTableRollableTableText3.new
      out.oracle_type = "table_text3"
      out.id = Datasworn::from_json_data(OracleRollableID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.column_labels = Datasworn::from_json_data(OracleTableRollableTableText3ColumnLabels, data["column_labels"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.rows = Datasworn::from_json_data(Array[OracleTableRowText3], data["rows"])
      out.type = Datasworn::from_json_data(OracleTableRollableTableText3Type, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.match = Datasworn::from_json_data(OracleMatchBehavior, data["match"])
      out.recommended_rolls = Datasworn::from_json_data(OracleTableRollableTableText3RecommendedRolls, data["recommended_rolls"])
      out.replaces = Datasworn::from_json_data(OracleRollableID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = { "oracle_type" => "table_text3" }
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["column_labels"] = Datasworn::to_json_data(column_labels)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["rows"] = Datasworn::to_json_data(rows)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["match"] = Datasworn::to_json_data(match) unless match.nil?
      data["recommended_rolls"] = Datasworn::to_json_data(recommended_rolls) unless recommended_rolls.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # Represents a row in an oracle table, with a single text cell.
  class OracleTableRowText
    # High end of the dice range for this table row.
    attr_accessor :max

    # Low end of the dice range for this table row.
    attr_accessor :min

    # The primary text content of this row.
    attr_accessor :text
    attr_accessor :i18n

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :oracle_rolls
    attr_accessor :suggestions
    attr_accessor :template

    def self.from_json_data(data)
      out = OracleTableRowText.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["_i18n"])
      out.embed_table = Datasworn::from_json_data(OracleRollableID, data["embed_table"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.oracle_rolls = Datasworn::from_json_data(Array[OracleRoll], data["oracle_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["text"] = Datasworn::to_json_data(text)
      data["_i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["oracle_rolls"] = Datasworn::to_json_data(oracle_rolls) unless oracle_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # Represents a row in an oracle table that provides a secondary text field.
  class OracleTableRowText2
    # High end of the dice range for this table row.
    attr_accessor :max

    # Low end of the dice range for this table row.
    attr_accessor :min

    # The primary text content of this row.
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :i18n

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :oracle_rolls
    attr_accessor :suggestions
    attr_accessor :template

    def self.from_json_data(data)
      out = OracleTableRowText2.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.text2 = Datasworn::from_json_data(MarkdownString, data["text2"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["_i18n"])
      out.embed_table = Datasworn::from_json_data(OracleRollableID, data["embed_table"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.oracle_rolls = Datasworn::from_json_data(Array[OracleRoll], data["oracle_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data["_i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["oracle_rolls"] = Datasworn::to_json_data(oracle_rolls) unless oracle_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # Represents a row in an oracle table with 3 text cells.
  class OracleTableRowText3
    # High end of the dice range for this table row.
    attr_accessor :max

    # Low end of the dice range for this table row.
    attr_accessor :min

    # The primary text content of this row.
    attr_accessor :text
    attr_accessor :text2
    attr_accessor :text3
    attr_accessor :i18n

    # Hints that the identified table should be rendered inside this table row.
    attr_accessor :embed_table
    attr_accessor :icon

    # Further oracle rolls prompted by this table row.
    attr_accessor :oracle_rolls
    attr_accessor :suggestions
    attr_accessor :template

    def self.from_json_data(data)
      out = OracleTableRowText3.new
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out.text2 = Datasworn::from_json_data(MarkdownString, data["text2"])
      out.text3 = Datasworn::from_json_data(MarkdownString, data["text3"])
      out.i18n = Datasworn::from_json_data(I18nHints, data["_i18n"])
      out.embed_table = Datasworn::from_json_data(OracleRollableID, data["embed_table"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.oracle_rolls = Datasworn::from_json_data(Array[OracleRoll], data["oracle_rolls"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.template = Datasworn::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Datasworn::to_json_data(max)
      data["min"] = Datasworn::to_json_data(min)
      data["text"] = Datasworn::to_json_data(text)
      data["text2"] = Datasworn::to_json_data(text2)
      data["text3"] = Datasworn::to_json_data(text3)
      data["_i18n"] = Datasworn::to_json_data(i18n) unless i18n.nil?
      data["embed_table"] = Datasworn::to_json_data(embed_table) unless embed_table.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["oracle_rolls"] = Datasworn::to_json_data(oracle_rolls) unless oracle_rolls.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["template"] = Datasworn::to_json_data(template) unless template.nil?
      data
    end
  end

  # A grouping of separate tables.
  class OracleTablesCollectionOracleType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    TABLES = new("tables")

    def self.from_json_data(data)
      {
        "tables" => TABLES,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTablesCollectionType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    ORACLE_COLLECTION = new("oracle_collection")

    def self.from_json_data(data)
      {
        "oracle_collection" => ORACLE_COLLECTION,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # An OracleCollection that represents a category or grouping of tables, which
  # may themselves be `OracleTablesCollection`s.
  class OracleTablesCollection
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source

    # The primary name/label for this item.
    attr_accessor :name

    # A grouping of separate tables.
    attr_accessor :oracle_type
    attr_accessor :type

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :collections

    # A thematic color associated with this collection.
    attr_accessor :color
    attr_accessor :contents

    # A longer description of this collection, which might include multiple
    # paragraphs. If it's only a couple sentences, use the `summary` key
    # instead.
    attr_accessor :description

    # This collection's content enhances the identified collection, rather than
    # being a standalone collection of its own.
    attr_accessor :enhances

    # An SVG icon associated with this collection.
    attr_accessor :icon
    attr_accessor :images

    # This collection replaces the identified collection. References to the
    # replaced collection can be considered equivalent to this collection.
    attr_accessor :replaces
    attr_accessor :suggestions

    # A brief summary of this collection, no more than a few sentences in
    # length. This is intended for use in application tooltips and similar sorts
    # of hints. Longer text should use the "description" key instead.
    attr_accessor :summary
    attr_accessor :tags

    def self.from_json_data(data)
      out = OracleTablesCollection.new
      out.id = Datasworn::from_json_data(OracleCollectionID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.oracle_type = Datasworn::from_json_data(OracleTablesCollectionOracleType, data["oracle_type"])
      out.type = Datasworn::from_json_data(OracleTablesCollectionType, data["type"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.collections = Datasworn::from_json_data(Hash[String, OracleCollection], data["collections"])
      out.color = Datasworn::from_json_data(CSSColor, data["color"])
      out.contents = Datasworn::from_json_data(Hash[String, OracleTableRollable], data["contents"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enhances = Datasworn::from_json_data(OracleCollectionID, data["enhances"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.images = Datasworn::from_json_data(Array[WebpImageURL], data["images"])
      out.replaces = Datasworn::from_json_data(OracleCollectionID, data["replaces"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["name"] = Datasworn::to_json_data(name)
      data["oracle_type"] = Datasworn::to_json_data(oracle_type)
      data["type"] = Datasworn::to_json_data(type)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["collections"] = Datasworn::to_json_data(collections) unless collections.nil?
      data["color"] = Datasworn::to_json_data(color) unless color.nil?
      data["contents"] = Datasworn::to_json_data(contents) unless contents.nil?
      data["description"] = Datasworn::to_json_data(description) unless description.nil?
      data["enhances"] = Datasworn::to_json_data(enhances) unless enhances.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["images"] = Datasworn::to_json_data(images) unless images.nil?
      data["replaces"] = Datasworn::to_json_data(replaces) unless replaces.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  class PartOfSpeech
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # An adjective.
    ADJECTIVE = new("adjective")

    # An adjective used as a proper noun.
    ADJECTIVE_AS_PROPER_NOUN = new("adjective_as_proper_noun")

    # A common noun used as an adjective, to modify another noun.
    ADJUNCT_COMMON_NOUN = new("adjunct_common_noun")

    # A proper noun used as an adjective, to modify another noun.
    ADJUNCT_PROPER_NOUN = new("adjunct_proper_noun")

    # A verb used as an adjective, to modify a noun.
    ATTRIBUTIVE_VERB = new("attributive_verb")

    # A common noun.
    COMMON_NOUN = new("common_noun")

    # An common noun used as a proper noun.
    COMMON_NOUN_AS_PROPER_NOUN = new("common_noun_as_proper_noun")

    # Gerund or present participle of a verb, e.g. "going", "seeing", "waving".
    # Can function as a noun, an adjective, or a progressive verb.
    GERUND = new("gerund")

    # A proper noun.
    PROPER_NOUN = new("proper_noun")

    # A verb in present tense
    VERB = new("verb")

    def self.from_json_data(data)
      {
        "adjective" => ADJECTIVE,
        "adjective_as_proper_noun" => ADJECTIVE_AS_PROPER_NOUN,
        "adjunct_common_noun" => ADJUNCT_COMMON_NOUN,
        "adjunct_proper_noun" => ADJUNCT_PROPER_NOUN,
        "attributive_verb" => ATTRIBUTIVE_VERB,
        "common_noun" => COMMON_NOUN,
        "common_noun_as_proper_noun" => COMMON_NOUN_AS_PROPER_NOUN,
        "gerund" => GERUND,
        "proper_noun" => PROPER_NOUN,
        "verb" => VERB,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class ProgressRollMethod
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # An automatic miss.
    MISS = new("miss")

    # Make a progress roll on a progress track associated with this move.
    PROGRESS_ROLL = new("progress_roll")

    # An automatic strong hit.
    STRONG_HIT = new("strong_hit")

    # An automatic weak hit.
    WEAK_HIT = new("weak_hit")

    def self.from_json_data(data)
      {
        "miss" => MISS,
        "progress_roll" => PROGRESS_ROLL,
        "strong_hit" => STRONG_HIT,
        "weak_hit" => WEAK_HIT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class ProgressRollOptionUsing
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    PROGRESS_TRACK = new("progress_track")

    def self.from_json_data(data)
      {
        "progress_track" => PROGRESS_TRACK,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class ProgressRollOption
    attr_accessor :using

    def self.from_json_data(data)
      out = ProgressRollOption.new
      out.using = Datasworn::from_json_data(ProgressRollOptionUsing, data["using"])
      out
    end

    def to_json_data
      data = {}
      data["using"] = Datasworn::to_json_data(using)
      data
    end
  end

  # Describes the features of a type of progress track.
  class ProgressTrackTypeInfo
    # A category label for progress tracks of this type.
    attr_accessor :category
    attr_accessor :controls

    def self.from_json_data(data)
      out = ProgressTrackTypeInfo.new
      out.category = Datasworn::from_json_data(Label, data["category"])
      out.controls = Datasworn::from_json_data(Hash[String, Object], data["controls"])
      out
    end

    def to_json_data
      data = {}
      data["category"] = Datasworn::to_json_data(category)
      data["controls"] = Datasworn::to_json_data(controls) unless controls.nil?
      data
    end
  end

  class RarityType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    RARITY = new("rarity")

    def self.from_json_data(data)
      {
        "rarity" => RARITY,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A rarity, as described in Ironsworn: Delve.
  class Rarity
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source

    # The asset augmented by this rarity.
    attr_accessor :asset
    attr_accessor :description

    # The primary name/label for this item.
    attr_accessor :name
    attr_accessor :type

    # From Ironsworn: Delve, p. 174:
    # 
    #       Some assets will bring a rarity into play more often than others,
    # so the experience point cost for a rarity will vary by the linked asset.
    # These costs are shown in the tables on page 175.
    # 
    #       If you are playing solo, and aren’t concerned with the relative
    # balance of rarity abilities, you can ignore these variable costs. If so,
    # spend 3 experience points to purchase a rarity.
    attr_accessor :xp_cost

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :icon
    attr_accessor :suggestions
    attr_accessor :tags

    def self.from_json_data(data)
      out = Rarity.new
      out.id = Datasworn::from_json_data(RarityID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.asset = Datasworn::from_json_data(AssetID, data["asset"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.type = Datasworn::from_json_data(RarityType, data["type"])
      out.xp_cost = Datasworn::from_json_data(Integer, data["xp_cost"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["asset"] = Datasworn::to_json_data(asset)
      data["description"] = Datasworn::to_json_data(description)
      data["name"] = Datasworn::to_json_data(name)
      data["type"] = Datasworn::to_json_data(type)
      data["xp_cost"] = Datasworn::to_json_data(xp_cost)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # A unique ID for a Rarity.
  class RarityID
    attr_accessor :value

    def self.from_json_data(data)
      out = RarityID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Provides a value like a stat, condition meter, or other number (usually for
  # use in an action roll). The expected value is an integer, or null.
  class RollableValue
    attr_accessor :using

    def self.from_json_data(data)
      {
        "asset_control" => RollableValueAssetControl,
        "asset_option" => RollableValueAssetOption,
        "attached_asset_control" => RollableValueAttachedAssetControl,
        "attached_asset_option" => RollableValueAttachedAssetOption,
        "condition_meter" => RollableValueConditionMeter,
        "custom" => RollableValueCustom,
        "stat" => RollableValueStat,
      }[data["using"]].from_json_data(data)
    end
  end

  # A reference to the value of an asset control.
  class RollableValueAssetControl < RollableValue
    attr_accessor :assets
    attr_accessor :control

    def self.from_json_data(data)
      out = RollableValueAssetControl.new
      out.using = "asset_control"
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.control = Datasworn::from_json_data(DictKey, data["control"])
      out
    end

    def to_json_data
      data = { "using" => "asset_control" }
      data["assets"] = Datasworn::to_json_data(assets)
      data["control"] = Datasworn::to_json_data(control)
      data
    end
  end

  # A reference to the value of an asset option.
  class RollableValueAssetOption < RollableValue
    attr_accessor :assets
    attr_accessor :option

    def self.from_json_data(data)
      out = RollableValueAssetOption.new
      out.using = "asset_option"
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.option = Datasworn::from_json_data(DictKey, data["option"])
      out
    end

    def to_json_data
      data = { "using" => "asset_option" }
      data["assets"] = Datasworn::to_json_data(assets)
      data["option"] = Datasworn::to_json_data(option)
      data
    end
  end

  # A reference to the value of an attached asset control. For example, a Module
  # asset could use this to roll using the `integrity` control of an attached
  # Vehicle.
  class RollableValueAttachedAssetControl < RollableValue
    attr_accessor :control

    def self.from_json_data(data)
      out = RollableValueAttachedAssetControl.new
      out.using = "attached_asset_control"
      out.control = Datasworn::from_json_data(DictKey, data["control"])
      out
    end

    def to_json_data
      data = { "using" => "attached_asset_control" }
      data["control"] = Datasworn::to_json_data(control)
      data
    end
  end

  # A reference to the value of an attached asset option.
  class RollableValueAttachedAssetOption < RollableValue
    attr_accessor :option

    def self.from_json_data(data)
      out = RollableValueAttachedAssetOption.new
      out.using = "attached_asset_option"
      out.option = Datasworn::from_json_data(DictKey, data["option"])
      out
    end

    def to_json_data
      data = { "using" => "attached_asset_option" }
      data["option"] = Datasworn::to_json_data(option)
      data
    end
  end

  # A reference to the value of a standard player condition meter.
  class RollableValueConditionMeter < RollableValue
    attr_accessor :condition_meter

    def self.from_json_data(data)
      out = RollableValueConditionMeter.new
      out.using = "condition_meter"
      out.condition_meter = Datasworn::from_json_data(ConditionMeterKey, data["condition_meter"])
      out
    end

    def to_json_data
      data = { "using" => "condition_meter" }
      data["condition_meter"] = Datasworn::to_json_data(condition_meter)
      data
    end
  end

  # An arbitrary static integer value with a label.
  class RollableValueCustom < RollableValue
    attr_accessor :label
    attr_accessor :value

    def self.from_json_data(data)
      out = RollableValueCustom.new
      out.using = "custom"
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out
    end

    def to_json_data
      data = { "using" => "custom" }
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data
    end
  end

  # A reference to the value of a standard player character stat.
  class RollableValueStat < RollableValue
    attr_accessor :stat

    def self.from_json_data(data)
      out = RollableValueStat.new
      out.using = "stat"
      out.stat = Datasworn::from_json_data(StatKey, data["stat"])
      out
    end

    def to_json_data
      data = { "using" => "stat" }
      data["stat"] = Datasworn::to_json_data(stat)
      data
    end
  end

  # Describes rules for player characters in this ruleset, such as stats and
  # condition meters.
  class Rules
    # Describes the standard condition meters used by player characters in this
    # ruleset.
    attr_accessor :condition_meters

    # Describes the standard impacts/debilities used by player characters in
    # this ruleset.
    attr_accessor :impacts

    # Describes the special tracks used by player characters in this ruleset,
    # like Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    attr_accessor :special_tracks

    # Describes the standard stats used by player characters in this ruleset.
    attr_accessor :stats
    attr_accessor :tags

    def self.from_json_data(data)
      out = Rules.new
      out.condition_meters = Datasworn::from_json_data(Hash[String, ConditionMeterRule], data["condition_meters"])
      out.impacts = Datasworn::from_json_data(Hash[String, ImpactCategory], data["impacts"])
      out.special_tracks = Datasworn::from_json_data(Hash[String, SpecialTrackRule], data["special_tracks"])
      out.stats = Datasworn::from_json_data(Hash[String, StatRule], data["stats"])
      out.tags = Datasworn::from_json_data(Hash[String, TagRule], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["condition_meters"] = Datasworn::to_json_data(condition_meters)
      data["impacts"] = Datasworn::to_json_data(impacts)
      data["special_tracks"] = Datasworn::to_json_data(special_tracks)
      data["stats"] = Datasworn::to_json_data(stats)
      data["tags"] = Datasworn::to_json_data(tags)
      data
    end
  end

  # Describes rules for player characters in this ruleset, such as stats and
  # condition meters.
  class RulesExpansion
    # Describes the standard condition meters used by player characters in this
    # ruleset.
    attr_accessor :condition_meters

    # Describes the standard impacts/debilities used by player characters in
    # this ruleset.
    attr_accessor :impacts

    # Describes the special tracks used by player characters in this ruleset,
    # like Bonds (classic Ironsworn), Failure (Delve), or Legacies (Starforged).
    attr_accessor :special_tracks

    # Describes the standard stats used by player characters in this ruleset.
    attr_accessor :stats
    attr_accessor :tags

    def self.from_json_data(data)
      out = RulesExpansion.new
      out.condition_meters = Datasworn::from_json_data(Hash[String, ConditionMeterRule], data["condition_meters"])
      out.impacts = Datasworn::from_json_data(Hash[String, ImpactCategory], data["impacts"])
      out.special_tracks = Datasworn::from_json_data(Hash[String, SpecialTrackRule], data["special_tracks"])
      out.stats = Datasworn::from_json_data(Hash[String, StatRule], data["stats"])
      out.tags = Datasworn::from_json_data(Hash[String, TagRule], data["tags"])
      out
    end

    def to_json_data
      data = {}
      data["condition_meters"] = Datasworn::to_json_data(condition_meters) unless condition_meters.nil?
      data["impacts"] = Datasworn::to_json_data(impacts) unless impacts.nil?
      data["special_tracks"] = Datasworn::to_json_data(special_tracks) unless special_tracks.nil?
      data["stats"] = Datasworn::to_json_data(stats) unless stats.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data
    end
  end

  # The ID of standalone Datasworn package that describes its own ruleset.
  class RulesetID
    attr_accessor :value

    def self.from_json_data(data)
      out = RulesetID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class SelectEnhancementFieldChoiceChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectEnhancementFieldChoice
    attr_accessor :choice_type
    attr_accessor :label
    attr_accessor :enhance_asset
    attr_accessor :enhance_moves

    def self.from_json_data(data)
      out = SelectEnhancementFieldChoice.new
      out.choice_type = Datasworn::from_json_data(SelectEnhancementFieldChoiceChoiceType, data["choice_type"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.enhance_asset = Datasworn::from_json_data(AssetEnhancement, data["enhance_asset"])
      out.enhance_moves = Datasworn::from_json_data(Array[MoveEnhancement], data["enhance_moves"])
      out
    end

    def to_json_data
      data = {}
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["label"] = Datasworn::to_json_data(label)
      data["enhance_asset"] = Datasworn::to_json_data(enhance_asset) unless enhance_asset.nil?
      data["enhance_moves"] = Datasworn::to_json_data(enhance_moves) unless enhance_moves.nil?
      data
    end
  end

  class SelectValueFieldChoice
    attr_accessor :using

    def self.from_json_data(data)
      {
        "asset_control" => SelectValueFieldChoiceAssetControl,
        "asset_option" => SelectValueFieldChoiceAssetOption,
        "attached_asset_control" => SelectValueFieldChoiceAttachedAssetControl,
        "attached_asset_option" => SelectValueFieldChoiceAttachedAssetOption,
        "condition_meter" => SelectValueFieldChoiceConditionMeter,
        "custom" => SelectValueFieldChoiceCustom,
        "stat" => SelectValueFieldChoiceStat,
      }[data["using"]].from_json_data(data)
    end
  end

  class SelectValueFieldChoiceAssetControlChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectValueFieldChoiceAssetControl < SelectValueFieldChoice
    attr_accessor :assets
    attr_accessor :choice_type
    attr_accessor :control
    attr_accessor :label

    def self.from_json_data(data)
      out = SelectValueFieldChoiceAssetControl.new
      out.using = "asset_control"
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.choice_type = Datasworn::from_json_data(SelectValueFieldChoiceAssetControlChoiceType, data["choice_type"])
      out.control = Datasworn::from_json_data(DictKey, data["control"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out
    end

    def to_json_data
      data = { "using" => "asset_control" }
      data["assets"] = Datasworn::to_json_data(assets)
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["control"] = Datasworn::to_json_data(control)
      data["label"] = Datasworn::to_json_data(label)
      data
    end
  end

  class SelectValueFieldChoiceAssetOptionChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectValueFieldChoiceAssetOption < SelectValueFieldChoice
    attr_accessor :assets
    attr_accessor :choice_type
    attr_accessor :label
    attr_accessor :option

    def self.from_json_data(data)
      out = SelectValueFieldChoiceAssetOption.new
      out.using = "asset_option"
      out.assets = Datasworn::from_json_data(Array[AssetIDWildcard], data["assets"])
      out.choice_type = Datasworn::from_json_data(SelectValueFieldChoiceAssetOptionChoiceType, data["choice_type"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.option = Datasworn::from_json_data(DictKey, data["option"])
      out
    end

    def to_json_data
      data = { "using" => "asset_option" }
      data["assets"] = Datasworn::to_json_data(assets)
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["label"] = Datasworn::to_json_data(label)
      data["option"] = Datasworn::to_json_data(option)
      data
    end
  end

  class SelectValueFieldChoiceAttachedAssetControlChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectValueFieldChoiceAttachedAssetControl < SelectValueFieldChoice
    attr_accessor :choice_type
    attr_accessor :control
    attr_accessor :label

    def self.from_json_data(data)
      out = SelectValueFieldChoiceAttachedAssetControl.new
      out.using = "attached_asset_control"
      out.choice_type = Datasworn::from_json_data(SelectValueFieldChoiceAttachedAssetControlChoiceType, data["choice_type"])
      out.control = Datasworn::from_json_data(DictKey, data["control"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out
    end

    def to_json_data
      data = { "using" => "attached_asset_control" }
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["control"] = Datasworn::to_json_data(control)
      data["label"] = Datasworn::to_json_data(label)
      data
    end
  end

  class SelectValueFieldChoiceAttachedAssetOptionChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectValueFieldChoiceAttachedAssetOption < SelectValueFieldChoice
    attr_accessor :choice_type
    attr_accessor :label
    attr_accessor :option

    def self.from_json_data(data)
      out = SelectValueFieldChoiceAttachedAssetOption.new
      out.using = "attached_asset_option"
      out.choice_type = Datasworn::from_json_data(SelectValueFieldChoiceAttachedAssetOptionChoiceType, data["choice_type"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.option = Datasworn::from_json_data(DictKey, data["option"])
      out
    end

    def to_json_data
      data = { "using" => "attached_asset_option" }
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["label"] = Datasworn::to_json_data(label)
      data["option"] = Datasworn::to_json_data(option)
      data
    end
  end

  class SelectValueFieldChoiceConditionMeterChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectValueFieldChoiceConditionMeter < SelectValueFieldChoice
    attr_accessor :choice_type
    attr_accessor :condition_meter
    attr_accessor :label

    def self.from_json_data(data)
      out = SelectValueFieldChoiceConditionMeter.new
      out.using = "condition_meter"
      out.choice_type = Datasworn::from_json_data(SelectValueFieldChoiceConditionMeterChoiceType, data["choice_type"])
      out.condition_meter = Datasworn::from_json_data(ConditionMeterKey, data["condition_meter"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out
    end

    def to_json_data
      data = { "using" => "condition_meter" }
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["condition_meter"] = Datasworn::to_json_data(condition_meter)
      data["label"] = Datasworn::to_json_data(label)
      data
    end
  end

  class SelectValueFieldChoiceCustomChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectValueFieldChoiceCustom < SelectValueFieldChoice
    attr_accessor :choice_type
    attr_accessor :label
    attr_accessor :value

    def self.from_json_data(data)
      out = SelectValueFieldChoiceCustom.new
      out.using = "custom"
      out.choice_type = Datasworn::from_json_data(SelectValueFieldChoiceCustomChoiceType, data["choice_type"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.value = Datasworn::from_json_data(Integer, data["value"])
      out
    end

    def to_json_data
      data = { "using" => "custom" }
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["label"] = Datasworn::to_json_data(label)
      data["value"] = Datasworn::to_json_data(value)
      data
    end
  end

  class SelectValueFieldChoiceStatChoiceType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    CHOICE = new("choice")

    def self.from_json_data(data)
      {
        "choice" => CHOICE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Represents an option in a list of choices.
  class SelectValueFieldChoiceStat < SelectValueFieldChoice
    attr_accessor :choice_type
    attr_accessor :label
    attr_accessor :stat

    def self.from_json_data(data)
      out = SelectValueFieldChoiceStat.new
      out.using = "stat"
      out.choice_type = Datasworn::from_json_data(SelectValueFieldChoiceStatChoiceType, data["choice_type"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.stat = Datasworn::from_json_data(StatKey, data["stat"])
      out
    end

    def to_json_data
      data = { "using" => "stat" }
      data["choice_type"] = Datasworn::to_json_data(choice_type)
      data["label"] = Datasworn::to_json_data(label)
      data["stat"] = Datasworn::to_json_data(stat)
      data
    end
  end

  # Metadata describing the original source of this item
  class SourceInfo
    # Lists authors credited by the source material.
    attr_accessor :authors

    # The date of the source documents's last update, formatted YYYY-MM-DD.
    # Required because it's used to determine whether the data needs updating.
    attr_accessor :date
    attr_accessor :license

    # The title of the source document.
    attr_accessor :title

    # A URL where the source document is available.
    attr_accessor :url

    # The page number where this item is described in full.
    attr_accessor :page

    def self.from_json_data(data)
      out = SourceInfo.new
      out.authors = Datasworn::from_json_data(Array[AuthorInfo], data["authors"])
      out.date = Datasworn::from_json_data(DateTime, data["date"])
      out.license = Datasworn::from_json_data(License, data["license"])
      out.title = Datasworn::from_json_data(String, data["title"])
      out.url = Datasworn::from_json_data(WebURL, data["url"])
      out.page = Datasworn::from_json_data(Integer, data["page"])
      out
    end

    def to_json_data
      data = {}
      data["authors"] = Datasworn::to_json_data(authors)
      data["date"] = Datasworn::to_json_data(date)
      data["license"] = Datasworn::to_json_data(license)
      data["title"] = Datasworn::to_json_data(title)
      data["url"] = Datasworn::to_json_data(url)
      data["page"] = Datasworn::to_json_data(page) unless page.nil?
      data
    end
  end

  class SpecialTrackRollMethod
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # Use _every_ roll option at once.
    ALL = new("all")

    # Use the roll option with the best/highest value.
    HIGHEST = new("highest")

    # Use the roll option with the worst/lowest value.
    LOWEST = new("lowest")

    # An automatic miss.
    MISS = new("miss")

    # The player chooses which roll option to use.
    PLAYER_CHOICE = new("player_choice")

    # An automatic strong hit.
    STRONG_HIT = new("strong_hit")

    # An automatic weak hit.
    WEAK_HIT = new("weak_hit")

    def self.from_json_data(data)
      {
        "all" => ALL,
        "highest" => HIGHEST,
        "lowest" => LOWEST,
        "miss" => MISS,
        "player_choice" => PLAYER_CHOICE,
        "strong_hit" => STRONG_HIT,
        "weak_hit" => WEAK_HIT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # Describes a special track like Bonds (classic Ironsworn), Failure (Delve),
  # or Legacies (Starforged).
  class SpecialTrackRule
    # A description of this special track.
    attr_accessor :description

    # A label for this special track.
    attr_accessor :label

    # Is this track an optional rule?
    attr_accessor :optional

    # Is this track shared by all players?
    attr_accessor :shared

    def self.from_json_data(data)
      out = SpecialTrackRule.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out.optional = Datasworn::from_json_data(TrueClass, data["optional"])
      out.shared = Datasworn::from_json_data(TrueClass, data["shared"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["label"] = Datasworn::to_json_data(label)
      data["optional"] = Datasworn::to_json_data(optional)
      data["shared"] = Datasworn::to_json_data(shared)
      data
    end
  end

  # Special, ruleset-specific progress tracks. Usually, one exists per player
  # character, and they persist through the life of the player character.
  # 'Canonical' examples:
  #   * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged
  # legacy track, use `bonds_legacy` instead.
  #   * `failure_track`, described in Ironsworn: Delve
  #   * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described
  # Ironsworn: Starforged
  # 
  class SpecialTrackType
    attr_accessor :value

    def self.from_json_data(data)
      out = SpecialTrackType.new
      out.value = Datasworn.from_json_data(DictKey, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A basic player character stat.
  class StatKey
    attr_accessor :value

    def self.from_json_data(data)
      out = StatKey.new
      out.value = Datasworn.from_json_data(DictKey, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Describes a standard player character stat.
  class StatRule
    # A description of this stat.
    attr_accessor :description

    # A label for this stat.
    attr_accessor :label

    def self.from_json_data(data)
      out = StatRule.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.label = Datasworn::from_json_data(InputLabel, data["label"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["label"] = Datasworn::to_json_data(label)
      data
    end
  end

  class Suggestions
    attr_accessor :assets
    attr_accessor :atlas
    attr_accessor :moves
    attr_accessor :npcs
    attr_accessor :oracles
    attr_accessor :rarities
    attr_accessor :site_domains
    attr_accessor :site_themes

    def self.from_json_data(data)
      out = Suggestions.new
      out.assets = Datasworn::from_json_data(Array[AssetID], data["assets"])
      out.atlas = Datasworn::from_json_data(Array[AtlasEntryID], data["atlas"])
      out.moves = Datasworn::from_json_data(Array[MoveID], data["moves"])
      out.npcs = Datasworn::from_json_data(Array[NpcID], data["npcs"])
      out.oracles = Datasworn::from_json_data(Array[OracleRollableID], data["oracles"])
      out.rarities = Datasworn::from_json_data(Array[RarityID], data["rarities"])
      out.site_domains = Datasworn::from_json_data(Array[DelveSiteDomainID], data["site_domains"])
      out.site_themes = Datasworn::from_json_data(Array[DelveSiteThemeID], data["site_themes"])
      out
    end

    def to_json_data
      data = {}
      data["assets"] = Datasworn::to_json_data(assets) unless assets.nil?
      data["atlas"] = Datasworn::to_json_data(atlas) unless atlas.nil?
      data["moves"] = Datasworn::to_json_data(moves) unless moves.nil?
      data["npcs"] = Datasworn::to_json_data(npcs) unless npcs.nil?
      data["oracles"] = Datasworn::to_json_data(oracles) unless oracles.nil?
      data["rarities"] = Datasworn::to_json_data(rarities) unless rarities.nil?
      data["site_domains"] = Datasworn::to_json_data(site_domains) unless site_domains.nil?
      data["site_themes"] = Datasworn::to_json_data(site_themes) unless site_themes.nil?
      data
    end
  end

  # A relative (local) URL pointing to a vector image in the SVG format.
  class SvgImageURL
    attr_accessor :value

    def self.from_json_data(data)
      out = SvgImageURL.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class Tag
    attr_accessor :value

    def self.from_json_data(data)
      out = Tag.new
      out.value = Datasworn.from_json_data(Object, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class TagRule
    attr_accessor :value_type

    def self.from_json_data(data)
      {
        "asset" => TagRuleAsset,
        "asset_collection" => TagRuleAssetCollection,
        "atlas_collection" => TagRuleAtlasCollection,
        "atlas_entry" => TagRuleAtlasEntry,
        "boolean" => TagRuleBoolean,
        "delve_site" => TagRuleDelveSite,
        "delve_site_domain" => TagRuleDelveSiteDomain,
        "delve_site_theme" => TagRuleDelveSiteTheme,
        "enum" => TagRuleEnum,
        "integer" => TagRuleInteger,
        "move" => TagRuleMove,
        "move_category" => TagRuleMoveCategory,
        "npc" => TagRuleNpc,
        "npc_collection" => TagRuleNpcCollection,
        "oracle_collection" => TagRuleOracleCollection,
        "oracle_rollable" => TagRuleOracleRollable,
        "rarity" => TagRuleRarity,
        "truth" => TagRuleTruth,
      }[data["value_type"]].from_json_data(data)
    end
  end

  class TagRuleAsset < TagRule
    attr_accessor :applies_to
    attr_accessor :description
    attr_accessor :wildcard

    def self.from_json_data(data)
      out = TagRuleAsset.new
      out.value_type = "asset"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.wildcard = Datasworn::from_json_data(TrueClass, data["wildcard"])
      out
    end

    def to_json_data
      data = { "value_type" => "asset" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["description"] = Datasworn::to_json_data(description)
      data["wildcard"] = Datasworn::to_json_data(wildcard)
      data
    end
  end

  class TagRuleAssetCollection < TagRule
    attr_accessor :applies_to
    attr_accessor :description
    attr_accessor :wildcard

    def self.from_json_data(data)
      out = TagRuleAssetCollection.new
      out.value_type = "asset_collection"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.wildcard = Datasworn::from_json_data(TrueClass, data["wildcard"])
      out
    end

    def to_json_data
      data = { "value_type" => "asset_collection" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["description"] = Datasworn::to_json_data(description)
      data["wildcard"] = Datasworn::to_json_data(wildcard)
      data
    end
  end

  class TagRuleAtlasCollection < TagRule
    attr_accessor :applies_to
    attr_accessor :description
    attr_accessor :wildcard

    def self.from_json_data(data)
      out = TagRuleAtlasCollection.new
      out.value_type = "atlas_collection"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.wildcard = Datasworn::from_json_data(TrueClass, data["wildcard"])
      out
    end

    def to_json_data
      data = { "value_type" => "atlas_collection" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["description"] = Datasworn::to_json_data(description)
      data["wildcard"] = Datasworn::to_json_data(wildcard)
      data
    end
  end

  class TagRuleAtlasEntry < TagRule
    attr_accessor :applies_to
    attr_accessor :description
    attr_accessor :wildcard

    def self.from_json_data(data)
      out = TagRuleAtlasEntry.new
      out.value_type = "atlas_entry"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.wildcard = Datasworn::from_json_data(TrueClass, data["wildcard"])
      out
    end

    def to_json_data
      data = { "value_type" => "atlas_entry" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["description"] = Datasworn::to_json_data(description)
      data["wildcard"] = Datasworn::to_json_data(wildcard)
      data
    end
  end

  class TagRuleBoolean < TagRule
    attr_accessor :applies_to
    attr_accessor :array
    attr_accessor :description

    def self.from_json_data(data)
      out = TagRuleBoolean.new
      out.value_type = "boolean"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.array = Datasworn::from_json_data(TrueClass, data["array"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out
    end

    def to_json_data
      data = { "value_type" => "boolean" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["array"] = Datasworn::to_json_data(array)
      data["description"] = Datasworn::to_json_data(description)
      data
    end
  end

  class TagRuleDelveSite < TagRule
    attr_accessor :applies_to
    attr_accessor :description
    attr_accessor :wildcard

    def self.from_json_data(data)
      out = TagRuleDelveSite.new
      out.value_type = "delve_site"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.wildcard = Datasworn::from_json_data(TrueClass, data["wildcard"])
      out
    end

    def to_json_data
      data = { "value_type" => "delve_site" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["description"] = Datasworn::to_json_data(description)
      data["wildcard"] = Datasworn::to_json_data(wildcard)
      data
    end
  end

  class TagRuleDelveSiteDomain < TagRule
    attr_accessor :applies_to
    attr_accessor :description
    attr_accessor :wildcard

    def self.from_json_data(data)
      out = TagRuleDelveSiteDomain.new
      out.value_type = "delve_site_domain"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.wildcard = Datasworn::from_json_data(TrueClass, data["wildcard"])
      out
    end

    def to_json_data
      data = { "value_type" => "delve_site_domain" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["description"] = Datasworn::to_json_data(description)
      data["wildcard"] = Datasworn::to_json_data(wildcard)
      data
    end
  end

  class TagRuleDelveSiteTheme < TagRule
    attr_accessor :applies_to
    attr_accessor :description
    attr_accessor :wildcard

    def self.from_json_data(data)
      out = TagRuleDelveSiteTheme.new
      out.value_type = "delve_site_theme"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.wildcard = Datasworn::from_json_data(TrueClass, data["wildcard"])
      out
    end

    def to_json_data
      data = { "value_type" => "delve_site_theme" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["description"] = Datasworn::to_json_data(description)
      data["wildcard"] = Datasworn::to_json_data(wildcard)
      data
    end
  end

  class TagRuleEnum < TagRule
    attr_accessor :applies_to
    attr_accessor :array
    attr_accessor :description
    attr_accessor :enum

    def self.from_json_data(data)
      out = TagRuleEnum.new
      out.value_type = "enum"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.array = Datasworn::from_json_data(TrueClass, data["array"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.enum = Datasworn::from_json_data(Array[DictKey], data["enum"])
      out
    end

    def to_json_data
      data = { "value_type" => "enum" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["array"] = Datasworn::to_json_data(array)
      data["description"] = Datasworn::to_json_data(description)
      data["enum"] = Datasworn::to_json_data(enum)
      data
    end
  end

  class TagRuleInteger < TagRule
    attr_accessor :applies_to
    attr_accessor :array
    attr_accessor :description

    def self.from_json_data(data)
      out = TagRuleInteger.new
      out.value_type = "integer"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.array = Datasworn::from_json_data(TrueClass, data["array"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out
    end

    def to_json_data
      data = { "value_type" => "integer" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["array"] = Datasworn::to_json_data(array)
      data["description"] = Datasworn::to_json_data(description)
      data
    end
  end

  class TagRuleMove < TagRule
    attr_accessor :applies_to
    attr_accessor :description
    attr_accessor :wildcard

    def self.from_json_data(data)
      out = TagRuleMove.new
      out.value_type = "move"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.wildcard = Datasworn::from_json_data(TrueClass, data["wildcard"])
      out
    end

    def to_json_data
      data = { "value_type" => "move" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["description"] = Datasworn::to_json_data(description)
      data["wildcard"] = Datasworn::to_json_data(wildcard)
      data
    end
  end

  class TagRuleMoveCategory < TagRule
    attr_accessor :applies_to
    attr_accessor :description
    attr_accessor :wildcard

    def self.from_json_data(data)
      out = TagRuleMoveCategory.new
      out.value_type = "move_category"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.wildcard = Datasworn::from_json_data(TrueClass, data["wildcard"])
      out
    end

    def to_json_data
      data = { "value_type" => "move_category" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["description"] = Datasworn::to_json_data(description)
      data["wildcard"] = Datasworn::to_json_data(wildcard)
      data
    end
  end

  class TagRuleNpc < TagRule
    attr_accessor :applies_to
    attr_accessor :description
    attr_accessor :wildcard

    def self.from_json_data(data)
      out = TagRuleNpc.new
      out.value_type = "npc"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.wildcard = Datasworn::from_json_data(TrueClass, data["wildcard"])
      out
    end

    def to_json_data
      data = { "value_type" => "npc" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["description"] = Datasworn::to_json_data(description)
      data["wildcard"] = Datasworn::to_json_data(wildcard)
      data
    end
  end

  class TagRuleNpcCollection < TagRule
    attr_accessor :applies_to
    attr_accessor :description
    attr_accessor :wildcard

    def self.from_json_data(data)
      out = TagRuleNpcCollection.new
      out.value_type = "npc_collection"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.wildcard = Datasworn::from_json_data(TrueClass, data["wildcard"])
      out
    end

    def to_json_data
      data = { "value_type" => "npc_collection" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["description"] = Datasworn::to_json_data(description)
      data["wildcard"] = Datasworn::to_json_data(wildcard)
      data
    end
  end

  class TagRuleOracleCollection < TagRule
    attr_accessor :applies_to
    attr_accessor :description
    attr_accessor :wildcard

    def self.from_json_data(data)
      out = TagRuleOracleCollection.new
      out.value_type = "oracle_collection"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.wildcard = Datasworn::from_json_data(TrueClass, data["wildcard"])
      out
    end

    def to_json_data
      data = { "value_type" => "oracle_collection" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["description"] = Datasworn::to_json_data(description)
      data["wildcard"] = Datasworn::to_json_data(wildcard)
      data
    end
  end

  class TagRuleOracleRollable < TagRule
    attr_accessor :applies_to
    attr_accessor :description
    attr_accessor :wildcard

    def self.from_json_data(data)
      out = TagRuleOracleRollable.new
      out.value_type = "oracle_rollable"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.wildcard = Datasworn::from_json_data(TrueClass, data["wildcard"])
      out
    end

    def to_json_data
      data = { "value_type" => "oracle_rollable" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["description"] = Datasworn::to_json_data(description)
      data["wildcard"] = Datasworn::to_json_data(wildcard)
      data
    end
  end

  class TagRuleRarity < TagRule
    attr_accessor :applies_to
    attr_accessor :description
    attr_accessor :wildcard

    def self.from_json_data(data)
      out = TagRuleRarity.new
      out.value_type = "rarity"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.wildcard = Datasworn::from_json_data(TrueClass, data["wildcard"])
      out
    end

    def to_json_data
      data = { "value_type" => "rarity" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["description"] = Datasworn::to_json_data(description)
      data["wildcard"] = Datasworn::to_json_data(wildcard)
      data
    end
  end

  class TagRuleTruth < TagRule
    attr_accessor :applies_to
    attr_accessor :description
    attr_accessor :wildcard

    def self.from_json_data(data)
      out = TagRuleTruth.new
      out.value_type = "truth"
      out.applies_to = Datasworn::from_json_data(Array[ObjectType], data["applies_to"])
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.wildcard = Datasworn::from_json_data(TrueClass, data["wildcard"])
      out
    end

    def to_json_data
      data = { "value_type" => "truth" }
      data["applies_to"] = Datasworn::to_json_data(applies_to)
      data["description"] = Datasworn::to_json_data(description)
      data["wildcard"] = Datasworn::to_json_data(wildcard)
      data
    end
  end

  # A rich text string in Markdown with replaced values from oracle roll
  # results.
  # 
  # The custom syntax `{{some_row_key:some_oracle_table_id}}` should be replaced
  # by the `some_row_key` string of a rolled oracle table. This is usually the
  # `result` key, for example `{{result:starforged/oracles/core/action}}`
  class TemplateString
    attr_accessor :value

    def self.from_json_data(data)
      out = TemplateString.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # Describes trigger conditions for a move that makes an action roll.
  class TriggerActionRoll
    # Specific conditions that qualify for this trigger.
    attr_accessor :conditions

    # A markdown string containing the primary trigger text for this move.
    # 
    # Secondary trigger text (for specific stats or uses of an asset ability)
    # may be described in individual trigger conditions.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerActionRoll.new
      out.conditions = Datasworn::from_json_data(Array[TriggerActionRollCondition], data["conditions"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class TriggerActionRollCondition
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerActionRollCondition.new
      out.method = Datasworn::from_json_data(ActionRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[RollableValue], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  class TriggerActionRollConditionEnhancement
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerActionRollConditionEnhancement.new
      out.method = Datasworn::from_json_data(ActionRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[RollableValue], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  # Describes changes/additions made to the enhanced move's trigger conditions.
  class TriggerActionRollEnhancement
    # Trigger conditions added to the enhanced move.
    attr_accessor :conditions

    def self.from_json_data(data)
      out = TriggerActionRollEnhancement.new
      out.conditions = Datasworn::from_json_data(Array[TriggerActionRollConditionEnhancement], data["conditions"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data
    end
  end

  # Information on who can activate this trigger condition. Usually this is just
  # the player, but some asset abilities can trigger from an ally's move.
  class TriggerBy
    # Can this trigger be activated by one of the player's allies?
    attr_accessor :ally

    # Can this trigger be activated by the player who owns this?
    attr_accessor :player

    def self.from_json_data(data)
      out = TriggerBy.new
      out.ally = Datasworn::from_json_data(TrueClass, data["ally"])
      out.player = Datasworn::from_json_data(TrueClass, data["player"])
      out
    end

    def to_json_data
      data = {}
      data["ally"] = Datasworn::to_json_data(ally)
      data["player"] = Datasworn::to_json_data(player)
      data
    end
  end

  # Describes trigger conditions for a move that makes no rolls.
  class TriggerNoRoll
    attr_accessor :conditions

    # A markdown string containing the primary trigger text for this move.
    # 
    # Secondary trigger text (for specific stats or uses of an asset ability)
    # may be described in individual trigger conditions.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerNoRoll.new
      out.conditions = Datasworn::from_json_data(Array[TriggerNoRollCondition], data["conditions"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class TriggerNoRollCondition
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerNoRollCondition.new
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  # Describes changes/additions made to the enhanced move's trigger conditions.
  class TriggerNoRollEnhancement
    # Trigger conditions added to the enhanced move.
    attr_accessor :conditions

    def self.from_json_data(data)
      out = TriggerNoRollEnhancement.new
      out.conditions = Datasworn::from_json_data(Array[TriggerNoRollCondition], data["conditions"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data
    end
  end

  class TriggerProgressRoll
    # Specific conditions that qualify for this trigger.
    attr_accessor :conditions

    # A markdown string containing the primary trigger text for this move.
    # 
    # Secondary trigger text (for specific stats or uses of an asset ability)
    # may be described in individual trigger conditions.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerProgressRoll.new
      out.conditions = Datasworn::from_json_data(Array[TriggerProgressRollCondition], data["conditions"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class TriggerProgressRollCondition
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerProgressRollCondition.new
      out.method = Datasworn::from_json_data(ProgressRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[ProgressRollOption], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  class TriggerProgressRollConditionEnhancement
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerProgressRollConditionEnhancement.new
      out.method = Datasworn::from_json_data(ProgressRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[ProgressRollOption], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  # Describes changes/additions made to the enhanced move's trigger conditions.
  class TriggerProgressRollEnhancement
    # Trigger conditions added to the enhanced move.
    attr_accessor :conditions

    def self.from_json_data(data)
      out = TriggerProgressRollEnhancement.new
      out.conditions = Datasworn::from_json_data(Array[TriggerProgressRollConditionEnhancement], data["conditions"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data
    end
  end

  class TriggerSpecialTrack
    # Specific conditions that qualify for this trigger.
    attr_accessor :conditions

    # A markdown string containing the primary trigger text for this move.
    # 
    # Secondary trigger text (for specific stats or uses of an asset ability)
    # may be described in individual trigger conditions.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerSpecialTrack.new
      out.conditions = Datasworn::from_json_data(Array[TriggerSpecialTrackCondition], data["conditions"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data["text"] = Datasworn::to_json_data(text)
      data
    end
  end

  class TriggerSpecialTrackCondition
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerSpecialTrackCondition.new
      out.method = Datasworn::from_json_data(SpecialTrackRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[TriggerSpecialTrackConditionOption], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  # A progress move that rolls on one or more special tracks, like Bonds
  # (classic Ironsworn), Failure (Delve), or Legacy (Starforged).
  class TriggerSpecialTrackConditionEnhancement
    attr_accessor :method

    # The options available when rolling with this trigger condition.
    attr_accessor :roll_options
    attr_accessor :by

    # A markdown string of any trigger text specific to this trigger condition.
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerSpecialTrackConditionEnhancement.new
      out.method = Datasworn::from_json_data(SpecialTrackRollMethod, data["method"])
      out.roll_options = Datasworn::from_json_data(Array[TriggerSpecialTrackConditionOption], data["roll_options"])
      out.by = Datasworn::from_json_data(TriggerBy, data["by"])
      out.text = Datasworn::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Datasworn::to_json_data(method)
      data["roll_options"] = Datasworn::to_json_data(roll_options)
      data["by"] = Datasworn::to_json_data(by) unless by.nil?
      data["text"] = Datasworn::to_json_data(text) unless text.nil?
      data
    end
  end

  class TriggerSpecialTrackConditionOption
    attr_accessor :using

    def self.from_json_data(data)
      out = TriggerSpecialTrackConditionOption.new
      out.using = Datasworn::from_json_data(SpecialTrackType, data["using"])
      out
    end

    def to_json_data
      data = {}
      data["using"] = Datasworn::to_json_data(using)
      data
    end
  end

  # Describes changes/additions made to the enhanced move's trigger conditions.
  class TriggerSpecialTrackEnhancement
    # Trigger conditions added to the enhanced move.
    attr_accessor :conditions

    def self.from_json_data(data)
      out = TriggerSpecialTrackEnhancement.new
      out.conditions = Datasworn::from_json_data(Array[TriggerSpecialTrackConditionEnhancement], data["conditions"])
      out
    end

    def to_json_data
      data = {}
      data["conditions"] = Datasworn::to_json_data(conditions)
      data
    end
  end

  # A setting truth category.
  class Truth
    # The unique Datasworn ID for this item.
    attr_accessor :id

    # Attribution for the original source (such as a book or website) of this
    # item, including the author and licensing information.
    attr_accessor :source
    attr_accessor :dice

    # The primary name/label for this item.
    attr_accessor :name
    attr_accessor :options

    # Any implementation hints or other developer-facing comments on this
    # object. These should be omitted when presenting the object for gameplay.
    attr_accessor :comment

    # The name of this item as it appears on the page in the book, if it's
    # different from `name`.
    attr_accessor :canonical_name
    attr_accessor :icon
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :tags
    attr_accessor :your_character

    def self.from_json_data(data)
      out = Truth.new
      out.id = Datasworn::from_json_data(TruthID, data["_id"])
      out.source = Datasworn::from_json_data(SourceInfo, data["_source"])
      out.dice = Datasworn::from_json_data(DiceExpression, data["dice"])
      out.name = Datasworn::from_json_data(Label, data["name"])
      out.options = Datasworn::from_json_data(Array[TruthOption], data["options"])
      out.comment = Datasworn::from_json_data(String, data["_comment"])
      out.canonical_name = Datasworn::from_json_data(Label, data["canonical_name"])
      out.icon = Datasworn::from_json_data(SvgImageURL, data["icon"])
      out.suggestions = Datasworn::from_json_data(Suggestions, data["suggestions"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.tags = Datasworn::from_json_data(Hash[String, Hash[String, Tag]], data["tags"])
      out.your_character = Datasworn::from_json_data(MarkdownString, data["your_character"])
      out
    end

    def to_json_data
      data = {}
      data["_id"] = Datasworn::to_json_data(id)
      data["_source"] = Datasworn::to_json_data(source)
      data["dice"] = Datasworn::to_json_data(dice)
      data["name"] = Datasworn::to_json_data(name)
      data["options"] = Datasworn::to_json_data(options)
      data["_comment"] = Datasworn::to_json_data(comment) unless comment.nil?
      data["canonical_name"] = Datasworn::to_json_data(canonical_name) unless canonical_name.nil?
      data["icon"] = Datasworn::to_json_data(icon) unless icon.nil?
      data["suggestions"] = Datasworn::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["tags"] = Datasworn::to_json_data(tags) unless tags.nil?
      data["your_character"] = Datasworn::to_json_data(your_character) unless your_character.nil?
      data
    end
  end

  # A unique ID for a Truth.
  class TruthID
    attr_accessor :value

    def self.from_json_data(data)
      out = TruthID.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  class TruthOption
    attr_accessor :description
    attr_accessor :quest_starter
    attr_accessor :max
    attr_accessor :min
    attr_accessor :summary
    attr_accessor :table

    def self.from_json_data(data)
      out = TruthOption.new
      out.description = Datasworn::from_json_data(MarkdownString, data["description"])
      out.quest_starter = Datasworn::from_json_data(MarkdownString, data["quest_starter"])
      out.max = Datasworn::from_json_data(Integer, data["max"])
      out.min = Datasworn::from_json_data(Integer, data["min"])
      out.summary = Datasworn::from_json_data(MarkdownString, data["summary"])
      out.table = Datasworn::from_json_data(Array[OracleTableRowText], data["table"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Datasworn::to_json_data(description)
      data["quest_starter"] = Datasworn::to_json_data(quest_starter)
      data["max"] = Datasworn::to_json_data(max) unless max.nil?
      data["min"] = Datasworn::to_json_data(min) unless min.nil?
      data["summary"] = Datasworn::to_json_data(summary) unless summary.nil?
      data["table"] = Datasworn::to_json_data(table) unless table.nil?
      data
    end
  end

  # An absolute URL pointing to a website.
  class WebURL
    attr_accessor :value

    def self.from_json_data(data)
      out = WebURL.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  # A relative (local) URL pointing to a raster image in the WEBP format.
  class WebpImageURL
    attr_accessor :value

    def self.from_json_data(data)
      out = WebpImageURL.new
      out.value = Datasworn.from_json_data(String, data)
      out
    end

    def to_json_data
      Datasworn.to_json_data(value)
    end
  end

  private

  def self.from_json_data(type, data)
    if data.nil? || [Object, TrueClass, Integer, Float, String].include?(type)
      data
    elsif type == DateTime
      DateTime.rfc3339(data)
    elsif type.is_a?(Array)
      data.map { |elem| from_json_data(type.first, elem) }
    elsif type.is_a?(Hash)
      data.transform_values { |elem| from_json_data(type.values.first, elem) }
    else
      type.from_json_data(data)
    end
  end

  def self.to_json_data(data)
    if data.nil? || [TrueClass, FalseClass, Integer, Float, String].include?(data.class)
      data
    elsif data.is_a?(DateTime)
      data.rfc3339
    elsif data.is_a?(Array)
      data.map { |elem| to_json_data(elem) }
    elsif data.is_a?(Hash)
      data.transform_values { |elem| to_json_data(elem) }
    else
      data.to_json_data
    end
  end
end
