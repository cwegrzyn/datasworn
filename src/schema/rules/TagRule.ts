import { Type, type Static } from '@sinclair/typebox'
import { keyBy, snakeCase } from 'lodash-es'
import { type Join, type SnakeCase } from 'type-fest'
import { JsonTypeDef } from '../Symbols.js'
import JtdType from '../../scripts/json-typedef/typedef.js'
import * as Utils from '../Utils.js'
import Id, { RulesPackageId, RulesetId } from '../common/Id.js'
import * as Localize from '../common/Localize.js'
import * as Rolls from '../common/Rolls.js'
import { pascalCase, type PascalCase } from '../utils/string.js'
import { Dictionary } from '../Generic.js'
import { canonicalTags } from '../tags/canonicalTags.js'
import TypeId from '../../pkg-core/IdElements/TypeId.js'
import type { Split } from '../../pkg-core/Utils/String.js'

type NodeSchemaName<T extends string> = PascalCase<T>
type EmbeddedNodeSchemaName<T extends string> = `Embedded${PascalCase<T>}`
type IdSchemaName<T extends string> = `${PascalCase<T>}Id`
type WildcardIdSchemaName<T extends string> = `${PascalCase<T>}IdWildcard`

function getNodeSchemaName<T extends string>(typeId: T) {
	return pascalCase(typeId) as NodeSchemaName<T>
}

function getEmbeddedNodeSchemaName<T extends string>(typeId: T) {
	return ('Embedded' + pascalCase(typeId)) as EmbeddedNodeSchemaName<T>
}

function getIdSchemaName<T extends string>(typeId: T) {
	return (pascalCase(typeId) + 'Id') as IdSchemaName<T>
}
function getWildcardIdSchemaName<T extends string>(typeId: T) {
	return (pascalCase(typeId) + 'IdWildcard') as WildcardIdSchemaName<T>
}

const AnyPrimary = TypeId.AnyPrimary.map(getNodeSchemaName)

const EmbedOnly = TypeId.EmbedOnlyType.map(getNodeSchemaName)
const EmbeddedPrimary = TypeId.EmbeddablePrimaryType.map(
	getEmbeddedNodeSchemaName
)

const NonIdentifiable = ['OracleTableRow'] as const
// TODO: could this be generated by iterating over objects and picking the ones with `tags` properties?
const AnyPrimaryId = AnyPrimary.map(getIdSchemaName)
const AnyPrimaryIdWildcard = AnyPrimary.map(getWildcardIdSchemaName)

const objectSchemata = [
	...AnyPrimary,
	...EmbedOnly,
	...NonIdentifiable,
	...EmbeddedPrimary
]

export const CollectionType = Utils.UnionEnum(TypeId.Collection, {
	$id: 'CollectionType'
})
export type CollectionType = Static<typeof CollectionType>

export const CollectableType = Utils.UnionEnum(TypeId.Collectable, {
	$id: 'CollectableType'
})
export type CollectableType = Static<typeof CollectableType>

export const NonCollectableType = Utils.UnionEnum(TypeId.NonCollectable, {
	$id: 'NonCollectableType'
})
export type NonCollectableType = Static<typeof NonCollectableType>

export const NonIdentifiableType = Utils.UnionEnum(
	NonIdentifiable.map(snakeCase) as [
		...SnakeCase<(typeof NonIdentifiable)[number]>[]
	],
	{
		$id: 'NonIdentifiableType'
	}
)
export type NonIdentifiableType = Static<typeof NonIdentifiableType>

export const TaggableNodeType = Type.Union(
	[
		Type.Ref(CollectableType),
		Type.Ref(NonCollectableType),
		Type.Ref(CollectionType),
		Type.Ref(NonIdentifiableType)
	],
	{
		[JsonTypeDef]: {
			schema: JtdType.Enum([
				...TypeId.AnyPrimary,
				...TypeId.EmbedOnlyType,
				'oracle_table_row' as const
			])
		},
		$id: 'TaggableNodeType'
	}
)
export type TaggableNodeType = Static<typeof TaggableNodeType>

// these are all pretty close to JSON schema already. is it worth taking them all the way?

// or should we favor abstraction to a limited set of datasworn constructs instead?

const TagRuleBase = Type.Object({
	applies_to: Utils.Nullable(Type.Array(Type.Ref(TaggableNodeType)), {
		description:
			'Types of object that can receive this tag, or `null` if any type of object accepts it.'
	}),
	description: Type.Ref(Localize.MarkdownString)
})

const typedTags = keyBy(
	[
		...(['boolean', 'integer'] as const).map((type) =>
			Utils.Assign([
				TagRuleBase,
				Type.Object({
					array: Type.Boolean({ default: false }),
					value_type: Type.Literal(type)
				})
			])
		),
		...TypeId.AnyPrimary.map((type) =>
			Utils.Assign([
				TagRuleBase,
				Type.Object({
					wildcard: Type.Boolean({
						default: false,
						description:
							'If `true`, this field accepts an array of wildcard ID strings. If `false`, this field accepts a single non-wildcard ID string.'
					}),
					value_type: Type.Literal(type)
				})
			])
		),
		Utils.Assign([
			TagRuleBase,
			Type.Object({
				array: Type.Boolean({ default: false }),
				value_type: Type.Literal('enum'),
				enum: Type.Array(Type.Ref(Id.DictKey))
			})
		])
	].map((tag) => ({
		...tag,
		title: 'TagRule' + pascalCase(tag.properties.value_type.const)
	})),
	(tag) => tag.properties.value_type.const
)

export const TagRule = Utils.DiscriminatedUnion(typedTags, 'value_type', {
	$id: 'TagRule'
})
export type TagRule = Static<typeof TagRule>

const TagValueNonId = [
	Type.Boolean(),
	Type.Integer(),
	Type.Ref(Id.DictKey), // from enums
	Type.Ref(Rolls.DiceExpression)
]

export const Tag = Type.Union(
	[
		...TagValueNonId,
		...AnyPrimaryId.map((type) => Type.Ref(type)),
		Type.Array(
			Type.Union([
				// Type.Ref(Id.DictKey), // from enums
				// Type.Ref(Rolls.DiceExpression),
				...AnyPrimaryIdWildcard.map((type) => Type.Ref(type))
			])
		)
	],
	{ $id: 'Tag', [JsonTypeDef]: { schema: JtdType.Any() } }
)

export const TagsCore = canonicalTags(
	{
		supernatural: Type.Boolean({
			description:
				'This object is supernatural in nature, and is ideal for settings that feature supernatural or mythic powers.'
		}),
		technological: Type.Boolean({
			description:
				'This object is technological in nature, and is ideal for settings that feature remarkable technologies.'
		}),
		requires_allies: Type.Boolean({
			description:
				'This object requires allies to function, and is intended for co-op play, or guided play with allies. It is not appropriate for solo play.'
		})
	},
	{ $id: 'TagsCore' }
)

export const Tags = Type.Record(
	RulesetId,
	Dictionary(Type.Ref<typeof Tag>('Tag'), { title: 'RulesPackageTags' }),
	{
		releaseStage: 'experimental',
		$id: 'Tags',
		key: Id.RulesetId.pattern,
		description:
			'A dictionary of tags, keyed by the RulesPackageId that the tags are from.'
	}
)
