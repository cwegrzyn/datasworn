# Code generated by jtd-codegen for Python v0.3.1

import re
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import Any, Dict, List, Optional, Type, Union, get_args, get_origin


@dataclass
class Dataforged:
    value: 'Any'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Dataforged':
        return cls(_from_json_data(Any, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Asset:
    abilities: 'List[AssetAbility]'
    id: 'AssetID'
    name: 'Label'
    source: 'Source'
    attachments: 'Optional[AssetAttachment]'
    controls: 'Optional[Dict[str, AssetControlField]]'
    count_as_impact: 'Optional[bool]'
    """
    If `true`, this asset counts as an impact (Starforged) or a debility
    (classic Ironsworn).
    """

    options: 'Optional[Dict[str, AssetOptionField]]'
    requirement: 'Optional[MarkdownString]'
    shared: 'Optional[bool]'
    """
    Most assets only benefit to their owner, but certain assets (like
    Starforged's module and command vehicle assets) are shared amongst the
    player's allies, too.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'Asset':
        return cls(
            _from_json_data(List[AssetAbility], data.get("abilities")),
            _from_json_data(AssetID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(Optional[AssetAttachment], data.get("attachments")),
            _from_json_data(Optional[Dict[str, AssetControlField]], data.get("controls")),
            _from_json_data(Optional[bool], data.get("count_as_impact")),
            _from_json_data(Optional[Dict[str, AssetOptionField]], data.get("options")),
            _from_json_data(Optional[MarkdownString], data.get("requirement")),
            _from_json_data(Optional[bool], data.get("shared")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["abilities"] = _to_json_data(self.abilities)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        if self.attachments is not None:
             data["attachments"] = _to_json_data(self.attachments)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        if self.count_as_impact is not None:
             data["count_as_impact"] = _to_json_data(self.count_as_impact)
        if self.options is not None:
             data["options"] = _to_json_data(self.options)
        if self.requirement is not None:
             data["requirement"] = _to_json_data(self.requirement)
        if self.shared is not None:
             data["shared"] = _to_json_data(self.shared)
        return data

@dataclass
class AssetAbility:
    enabled: 'bool'
    id: 'AssetAbilityID'
    text: 'MarkdownString'
    controls: 'Optional[Dict[str, AssetAbilityControlField]]'
    extend_asset: 'Optional[AssetExtension]'
    extend_moves: 'Optional[List[MoveExtension]]'
    moves: 'Optional[Dict[str, Move]]'
    name: 'Optional[Label]'
    options: 'Optional[Dict[str, AssetOptionField]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbility':
        return cls(
            _from_json_data(bool, data.get("enabled")),
            _from_json_data(AssetAbilityID, data.get("id")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Optional[Dict[str, AssetAbilityControlField]], data.get("controls")),
            _from_json_data(Optional[AssetExtension], data.get("extend_asset")),
            _from_json_data(Optional[List[MoveExtension]], data.get("extend_moves")),
            _from_json_data(Optional[Dict[str, Move]], data.get("moves")),
            _from_json_data(Optional[Label], data.get("name")),
            _from_json_data(Optional[Dict[str, AssetOptionField]], data.get("options")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["enabled"] = _to_json_data(self.enabled)
        data["id"] = _to_json_data(self.id)
        data["text"] = _to_json_data(self.text)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        if self.extend_asset is not None:
             data["extend_asset"] = _to_json_data(self.extend_asset)
        if self.extend_moves is not None:
             data["extend_moves"] = _to_json_data(self.extend_moves)
        if self.moves is not None:
             data["moves"] = _to_json_data(self.moves)
        if self.name is not None:
             data["name"] = _to_json_data(self.name)
        if self.options is not None:
             data["options"] = _to_json_data(self.options)
        return data

@dataclass
class AssetAbilityControlField:
    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlField':
        variants: Dict[str, Type[AssetAbilityControlField]] = {
            "checkbox": AssetAbilityControlFieldCheckbox,
            "clock": AssetAbilityControlFieldClock,
            "counter": AssetAbilityControlFieldCounter,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetAbilityControlFieldCheckbox(AssetAbilityControlField):
    id: 'AssetAbilityControlFieldID'
    label: 'Label'
    value: 'Optional[bool]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldCheckbox':
        return cls(
            "checkbox",
            _from_json_data(AssetAbilityControlFieldID, data.get("id")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(Optional[bool], data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "checkbox" }
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class AssetAbilityControlFieldClock(AssetAbilityControlField):
    id: 'AssetAbilityControlFieldID'
    label: 'Label'
    max: 'int'
    min: 'int'
    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldClock':
        return cls(
            "clock",
            _from_json_data(AssetAbilityControlFieldID, data.get("id")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(int, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "clock" }
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class AssetAbilityControlFieldCounter(AssetAbilityControlField):
    id: 'AssetAbilityControlFieldID'
    label: 'Label'
    max: 'Optional[int]'
    min: 'int'
    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldCounter':
        return cls(
            "counter",
            _from_json_data(AssetAbilityControlFieldID, data.get("id")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(Optional[int], data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(int, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "counter" }
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class AssetAbilityControlFieldID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityControlFieldID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetAbilityID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetAbilityOptionFieldID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAbilityOptionFieldID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetAttachment:
    """
    Describes which assets can be attached to this asset. The "canonical"
    example for this are Starforged's Module assets, which can be equipped by
    Command Vehicle assets. See p. 55 of Starforged for more info.
    """

    patterns: 'List[RegularExpression]'
    """
    Regular expressions matching the IDs of assets that can be attached to this
    asset.
    """

    max: 'Optional[int]'
    """
    The maximum number of attached assets. Omitted if there's no upper limit to
    the number of attached assets.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetAttachment':
        return cls(
            _from_json_data(List[RegularExpression], data.get("patterns")),
            _from_json_data(Optional[int], data.get("max")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["patterns"] = _to_json_data(self.patterns)
        if self.max is not None:
             data["max"] = _to_json_data(self.max)
        return data

@dataclass
class AssetControlField:
    """
    Asset controls are fields that are expected to change throughout the
    asset's lifespan. The most common example are the condition meters on
    certain assets. A more complex example is the distinct mechanical modes on
    Ironsworn's 'Armored'.
    """

    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlField':
        variants: Dict[str, Type[AssetControlField]] = {
            "checkbox": AssetControlFieldCheckbox,
            "condition_meter": AssetControlFieldConditionMeter,
            "select_asset_extension": AssetControlFieldSelectAssetExtension,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetControlFieldCheckbox(AssetControlField):
    id: 'AssetAbilityControlFieldID'
    label: 'Label'
    value: 'Optional[bool]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldCheckbox':
        return cls(
            "checkbox",
            _from_json_data(AssetAbilityControlFieldID, data.get("id")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(Optional[bool], data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "checkbox" }
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class AssetControlFieldConditionMeter(AssetControlField):
    id: 'AssetAbilityControlFieldID'
    label: 'Label'
    max: 'int'
    min: 'int'
    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldConditionMeter':
        return cls(
            "condition_meter",
            _from_json_data(AssetAbilityControlFieldID, data.get("id")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(int, data.get("max")),
            _from_json_data(int, data.get("min")),
            _from_json_data(int, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "condition_meter" }
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        data["max"] = _to_json_data(self.max)
        data["min"] = _to_json_data(self.min)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class AssetControlFieldSelectAssetExtensionChoice:
    label: 'Label'
    value: 'AssetExtension'
    selected: 'Optional[bool]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldSelectAssetExtensionChoice':
        return cls(
            _from_json_data(Label, data.get("label")),
            _from_json_data(AssetExtension, data.get("value")),
            _from_json_data(Optional[bool], data.get("selected")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.selected is not None:
             data["selected"] = _to_json_data(self.selected)
        return data

@dataclass
class AssetControlFieldSelectAssetExtension(AssetControlField):
    choices: 'Dict[str, AssetControlFieldSelectAssetExtensionChoice]'
    id: 'AssetAbilityControlFieldID'
    label: 'Label'
    value: 'Optional[AssetExtension]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetControlFieldSelectAssetExtension':
        return cls(
            "select_asset_extension",
            _from_json_data(Dict[str, AssetControlFieldSelectAssetExtensionChoice], data.get("choices")),
            _from_json_data(AssetAbilityControlFieldID, data.get("id")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(Optional[AssetExtension], data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "select_asset_extension" }
        data["choices"] = _to_json_data(self.choices)
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        if self.value is not None:
             data["value"] = _to_json_data(self.value)
        return data

@dataclass
class AssetExtensionAttachments:
    max: 'Optional[int]'
    patterns: 'Optional[List[RegularExpression]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetExtensionAttachments':
        return cls(
            _from_json_data(Optional[int], data.get("max")),
            _from_json_data(Optional[List[RegularExpression]], data.get("patterns")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.max is not None:
             data["max"] = _to_json_data(self.max)
        if self.patterns is not None:
             data["patterns"] = _to_json_data(self.patterns)
        return data

@dataclass
class AssetExtensionControl:
    max: 'Optional[int]'
    min: 'Optional[int]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetExtensionControl':
        return cls(
            _from_json_data(Optional[int], data.get("max")),
            _from_json_data(Optional[int], data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.max is not None:
             data["max"] = _to_json_data(self.max)
        if self.min is not None:
             data["min"] = _to_json_data(self.min)
        return data

@dataclass
class AssetExtension:
    """
    Describes changes applied to an asset by its own abilities or controls.
    Unchanged properties are omitted.
    """

    attachments: 'Optional[AssetExtensionAttachments]'
    controls: 'Optional[Dict[str, AssetExtensionControl]]'
    """
    Use the same key as the original control. Currently, only condition meters
    may be extended in this way.
    """

    count_as_impact: 'Optional[bool]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetExtension':
        return cls(
            _from_json_data(Optional[AssetExtensionAttachments], data.get("attachments")),
            _from_json_data(Optional[Dict[str, AssetExtensionControl]], data.get("controls")),
            _from_json_data(Optional[bool], data.get("count_as_impact")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.attachments is not None:
             data["attachments"] = _to_json_data(self.attachments)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        if self.count_as_impact is not None:
             data["count_as_impact"] = _to_json_data(self.count_as_impact)
        return data

@dataclass
class AssetExtensionChoice:
    label: 'Label'
    value: 'AssetExtension'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetExtensionChoice':
        return cls(
            _from_json_data(Label, data.get("label")),
            _from_json_data(AssetExtension, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class AssetExtensionForeignAttachments:
    max: 'Optional[int]'
    patterns: 'Optional[List[RegularExpression]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetExtensionForeignAttachments':
        return cls(
            _from_json_data(Optional[int], data.get("max")),
            _from_json_data(Optional[List[RegularExpression]], data.get("patterns")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.max is not None:
             data["max"] = _to_json_data(self.max)
        if self.patterns is not None:
             data["patterns"] = _to_json_data(self.patterns)
        return data

@dataclass
class AssetExtensionForeignControl:
    max: 'Optional[int]'
    min: 'Optional[int]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetExtensionForeignControl':
        return cls(
            _from_json_data(Optional[int], data.get("max")),
            _from_json_data(Optional[int], data.get("min")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.max is not None:
             data["max"] = _to_json_data(self.max)
        if self.min is not None:
             data["min"] = _to_json_data(self.min)
        return data

@dataclass
class AssetExtensionForeign:
    """
    Describes changes applied to an asset, usually by another asset. Unchanged
    properties are omitted.
    """

    extends: 'AssetID'
    id: 'AssetAbilityControlFieldID'
    attachments: 'Optional[AssetExtensionForeignAttachments]'
    controls: 'Optional[Dict[str, AssetExtensionForeignControl]]'
    """
    Use the same key as the original control. Currently, only condition meters
    may be extended in this way.
    """

    count_as_impact: 'Optional[bool]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetExtensionForeign':
        return cls(
            _from_json_data(AssetID, data.get("extends")),
            _from_json_data(AssetAbilityControlFieldID, data.get("id")),
            _from_json_data(Optional[AssetExtensionForeignAttachments], data.get("attachments")),
            _from_json_data(Optional[Dict[str, AssetExtensionForeignControl]], data.get("controls")),
            _from_json_data(Optional[bool], data.get("count_as_impact")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["extends"] = _to_json_data(self.extends)
        data["id"] = _to_json_data(self.id)
        if self.attachments is not None:
             data["attachments"] = _to_json_data(self.attachments)
        if self.controls is not None:
             data["controls"] = _to_json_data(self.controls)
        if self.count_as_impact is not None:
             data["count_as_impact"] = _to_json_data(self.count_as_impact)
        return data

@dataclass
class AssetID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class AssetOptionField:
    """
    Asset options are fields that are usually only set once, typically when the
    player purchases the asset. The most common examples are the "Name" fields
    on companion assets. A more complex example is the choice of stats on the
    Devotant asset.
    """

    field_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionField':
        variants: Dict[str, Type[AssetOptionField]] = {
            "select_asset_extension": AssetOptionFieldSelectAssetExtension,
            "select_number": AssetOptionFieldSelectNumber,
            "select_stat": AssetOptionFieldSelectStat,
            "text": AssetOptionFieldText,
        }

        return variants[data["field_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class AssetOptionFieldSelectAssetExtensionChoice:
    label: 'Label'
    value: 'AssetExtension'
    selected: 'Optional[bool]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectAssetExtensionChoice':
        return cls(
            _from_json_data(Label, data.get("label")),
            _from_json_data(AssetExtension, data.get("value")),
            _from_json_data(Optional[bool], data.get("selected")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.selected is not None:
             data["selected"] = _to_json_data(self.selected)
        return data

@dataclass
class AssetOptionFieldSelectAssetExtension(AssetOptionField):
    choices: 'Dict[str, AssetOptionFieldSelectAssetExtensionChoice]'
    id: 'AssetAbilityControlFieldID'
    label: 'Label'
    value: 'Optional[AssetExtension]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectAssetExtension':
        return cls(
            "select_asset_extension",
            _from_json_data(Dict[str, AssetOptionFieldSelectAssetExtensionChoice], data.get("choices")),
            _from_json_data(AssetAbilityControlFieldID, data.get("id")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(Optional[AssetExtension], data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "select_asset_extension" }
        data["choices"] = _to_json_data(self.choices)
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        if self.value is not None:
             data["value"] = _to_json_data(self.value)
        return data

@dataclass
class AssetOptionFieldSelectNumberChoice:
    label: 'Label'
    value: 'int'
    selected: 'Optional[bool]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectNumberChoice':
        return cls(
            _from_json_data(Label, data.get("label")),
            _from_json_data(int, data.get("value")),
            _from_json_data(Optional[bool], data.get("selected")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.selected is not None:
             data["selected"] = _to_json_data(self.selected)
        return data

@dataclass
class AssetOptionFieldSelectNumber(AssetOptionField):
    choices: 'Dict[str, AssetOptionFieldSelectNumberChoice]'
    id: 'AssetAbilityOptionFieldID'
    label: 'Label'
    value: 'Optional[int]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectNumber':
        return cls(
            "select_number",
            _from_json_data(Dict[str, AssetOptionFieldSelectNumberChoice], data.get("choices")),
            _from_json_data(AssetAbilityOptionFieldID, data.get("id")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(Optional[int], data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "select_number" }
        data["choices"] = _to_json_data(self.choices)
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        if self.value is not None:
             data["value"] = _to_json_data(self.value)
        return data

@dataclass
class AssetOptionFieldSelectStatChoice:
    label: 'Label'
    value: 'PlayerStat'
    selected: 'Optional[bool]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectStatChoice':
        return cls(
            _from_json_data(Label, data.get("label")),
            _from_json_data(PlayerStat, data.get("value")),
            _from_json_data(Optional[bool], data.get("selected")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        if self.selected is not None:
             data["selected"] = _to_json_data(self.selected)
        return data

@dataclass
class AssetOptionFieldSelectStat(AssetOptionField):
    choices: 'Dict[str, AssetOptionFieldSelectStatChoice]'
    id: 'AssetAbilityOptionFieldID'
    label: 'Label'
    value: 'Optional[PlayerStat]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldSelectStat':
        return cls(
            "select_stat",
            _from_json_data(Dict[str, AssetOptionFieldSelectStatChoice], data.get("choices")),
            _from_json_data(AssetAbilityOptionFieldID, data.get("id")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(Optional[PlayerStat], data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "select_stat" }
        data["choices"] = _to_json_data(self.choices)
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        if self.value is not None:
             data["value"] = _to_json_data(self.value)
        return data

@dataclass
class AssetOptionFieldText(AssetOptionField):
    id: 'AssetAbilityOptionFieldID'
    label: 'Label'
    value: 'Optional[str]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'AssetOptionFieldText':
        return cls(
            "text",
            _from_json_data(AssetAbilityOptionFieldID, data.get("id")),
            _from_json_data(Label, data.get("label")),
            _from_json_data(Optional[str], data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "field_type": "text" }
        data["id"] = _to_json_data(self.id)
        data["label"] = _to_json_data(self.label)
        if self.value is not None:
             data["value"] = _to_json_data(self.value)
        return data

@dataclass
class ChallengeRank:
    """
    Challenge rank represented as a number from 1 (troublesome) to 5 (epic)
    """

    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ChallengeRank':
        return cls(_from_json_data(int, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Color:
    """
    A valid CSS color.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Color':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class DelveSiteDenizenFrequency(Enum):
    COMMON = "common"
    RARE = "rare"
    UNCOMMON = "uncommon"
    UNFORESEEN = "unforeseen"
    VERY_COMMON = "very_common"
    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDenizenFrequency':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class DelveSiteDenizen:
    frequency: 'DelveSiteDenizenFrequency'
    high: 'int'
    low: 'int'
    encounter: 'Optional[ID]'
    name: 'Optional[Label]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDenizen':
        return cls(
            _from_json_data(DelveSiteDenizenFrequency, data.get("frequency")),
            _from_json_data(int, data.get("high")),
            _from_json_data(int, data.get("low")),
            _from_json_data(Optional[ID], data.get("encounter")),
            _from_json_data(Optional[Label], data.get("name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["frequency"] = _to_json_data(self.frequency)
        data["high"] = _to_json_data(self.high)
        data["low"] = _to_json_data(self.low)
        if self.encounter is not None:
             data["encounter"] = _to_json_data(self.encounter)
        if self.name is not None:
             data["name"] = _to_json_data(self.name)
        return data

class DelveSiteDomainCardType(Enum):
    DOMAIN = "domain"
    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainCardType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class DelveSiteDomain:
    card_type: 'DelveSiteDomainCardType'
    dangers: 'List[FeatureOrDanger]'
    features: 'List[FeatureOrDanger]'
    id: 'DelveSiteDomainID'
    name: 'Label'
    source: 'Source'
    summary: 'MarkdownString'
    description: 'Optional[MarkdownString]'
    icon: 'Optional[SvgImageURL]'
    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomain':
        return cls(
            _from_json_data(DelveSiteDomainCardType, data.get("card_type")),
            _from_json_data(List[FeatureOrDanger], data.get("dangers")),
            _from_json_data(List[FeatureOrDanger], data.get("features")),
            _from_json_data(DelveSiteDomainID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(MarkdownString, data.get("summary")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["card_type"] = _to_json_data(self.card_type)
        data["dangers"] = _to_json_data(self.dangers)
        data["features"] = _to_json_data(self.features)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        data["summary"] = _to_json_data(self.summary)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class DelveSiteDomainID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteDomainID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class DelveSiteThemeCardType(Enum):
    THEME = "theme"
    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeCardType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class DelveSiteTheme:
    card_type: 'DelveSiteThemeCardType'
    dangers: 'List[FeatureOrDanger]'
    features: 'List[FeatureOrDanger]'
    id: 'DelveSiteThemeID'
    name: 'Label'
    source: 'Source'
    summary: 'MarkdownString'
    description: 'Optional[MarkdownString]'
    icon: 'Optional[SvgImageURL]'
    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteTheme':
        return cls(
            _from_json_data(DelveSiteThemeCardType, data.get("card_type")),
            _from_json_data(List[FeatureOrDanger], data.get("dangers")),
            _from_json_data(List[FeatureOrDanger], data.get("features")),
            _from_json_data(DelveSiteThemeID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(MarkdownString, data.get("summary")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["card_type"] = _to_json_data(self.card_type)
        data["dangers"] = _to_json_data(self.dangers)
        data["features"] = _to_json_data(self.features)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        data["summary"] = _to_json_data(self.summary)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class DelveSiteThemeID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'DelveSiteThemeID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class EncounterNatureClassic:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EncounterNatureClassic':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class EncounterNatureStarforged:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EncounterNatureStarforged':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class EncounterStarforged:
    description: 'MarkdownString'
    drives: 'List[MarkdownString]'
    features: 'List[MarkdownString]'
    id: 'ID'
    name: 'Label'
    nature: 'EncounterNatureStarforged'
    quest_starter: 'MarkdownString'
    rank: 'ChallengeRank'
    source: 'Source'
    summary: 'MarkdownString'
    tactics: 'List[MarkdownString]'
    suggestions: 'Optional[Suggestions]'
    variants: 'Optional[Dict[str, EncounterVariantStarforged]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EncounterStarforged':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(List[MarkdownString], data.get("drives")),
            _from_json_data(List[MarkdownString], data.get("features")),
            _from_json_data(ID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(EncounterNatureStarforged, data.get("nature")),
            _from_json_data(MarkdownString, data.get("quest_starter")),
            _from_json_data(ChallengeRank, data.get("rank")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(MarkdownString, data.get("summary")),
            _from_json_data(List[MarkdownString], data.get("tactics")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[Dict[str, EncounterVariantStarforged]], data.get("variants")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["drives"] = _to_json_data(self.drives)
        data["features"] = _to_json_data(self.features)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["nature"] = _to_json_data(self.nature)
        data["quest_starter"] = _to_json_data(self.quest_starter)
        data["rank"] = _to_json_data(self.rank)
        data["source"] = _to_json_data(self.source)
        data["summary"] = _to_json_data(self.summary)
        data["tactics"] = _to_json_data(self.tactics)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.variants is not None:
             data["variants"] = _to_json_data(self.variants)
        return data

@dataclass
class EncounterVariantStarforged:
    description: 'MarkdownString'
    id: 'ID'
    name: 'Label'
    nature: 'EncounterNatureStarforged'
    rank: 'ChallengeRank'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EncounterVariantStarforged':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(ID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(EncounterNatureStarforged, data.get("nature")),
            _from_json_data(ChallengeRank, data.get("rank")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["nature"] = _to_json_data(self.nature)
        data["rank"] = _to_json_data(self.rank)
        return data

@dataclass
class FeatureOrDanger:
    high: 'int'
    id: 'ID'
    low: 'int'
    result: 'MarkdownString'
    description: 'Optional[MarkdownString]'
    embed_table: 'Optional[ID]'
    icon: 'Optional[SvgImageURL]'
    rolls: 'Optional[List[OracleTableRoll]]'
    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'FeatureOrDanger':
        return cls(
            _from_json_data(int, data.get("high")),
            _from_json_data(ID, data.get("id")),
            _from_json_data(int, data.get("low")),
            _from_json_data(MarkdownString, data.get("result")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[ID], data.get("embed_table")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleTableRoll]], data.get("rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["high"] = _to_json_data(self.high)
        data["id"] = _to_json_data(self.id)
        data["low"] = _to_json_data(self.low)
        data["result"] = _to_json_data(self.result)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.rolls is not None:
             data["rolls"] = _to_json_data(self.rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class ID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Label:
    """
    A user-facing text label or name.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Label':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MarkdownString:
    """
    A rich text string in Markdown. Usually this is a direct excerpt from the
    rules text.
    
          The custom syntax `{{table:some_oracle_table_id}}` represents a
    markdown table rendered from oracle data.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MarkdownString':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Move:
    id: 'MoveID'
    name: 'Label'
    outcomes: 'MoveOutcomes'
    source: 'Source'
    text: 'MarkdownString'
    trigger: 'Trigger'
    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Move':
        return cls(
            _from_json_data(MoveID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MoveOutcomes, data.get("outcomes")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Trigger, data.get("trigger")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["outcomes"] = _to_json_data(self.outcomes)
        data["source"] = _to_json_data(self.source)
        data["text"] = _to_json_data(self.text)
        data["trigger"] = _to_json_data(self.trigger)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class MoveCategory:
    color: 'Color'
    contents: 'Dict[str, Move]'
    id: 'MoveCategoryID'
    name: 'Label'
    source: 'Source'
    summary: 'MarkdownString'
    canonical_name: 'Optional[Label]'
    description: 'Optional[MarkdownString]'
    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveCategory':
        return cls(
            _from_json_data(Color, data.get("color")),
            _from_json_data(Dict[str, Move], data.get("contents")),
            _from_json_data(MoveCategoryID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(MarkdownString, data.get("summary")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["color"] = _to_json_data(self.color)
        data["contents"] = _to_json_data(self.contents)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        data["summary"] = _to_json_data(self.summary)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class MoveCategoryID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveCategoryID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MoveExtension:
    extends: 'Optional[List[MoveID]]'
    trigger: 'TriggerExtension'
    outcomes: 'Optional[MoveOutcomesExtension]'
    text: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveExtension':
        return cls(
            _from_json_data(Optional[List[MoveID]], data.get("extends")),
            _from_json_data(TriggerExtension, data.get("trigger")),
            _from_json_data(Optional[MoveOutcomesExtension], data.get("outcomes")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["extends"] = _to_json_data(self.extends)
        data["trigger"] = _to_json_data(self.trigger)
        if self.outcomes is not None:
             data["outcomes"] = _to_json_data(self.outcomes)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class MoveID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class MoveOutcome:
    text: 'MarkdownString'
    count_as: 'Optional[MoveOutcomeType]'
    reroll: 'Optional[MoveReroll]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOutcome':
        return cls(
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Optional[MoveOutcomeType], data.get("count_as")),
            _from_json_data(Optional[MoveReroll], data.get("reroll")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        if self.count_as is not None:
             data["count_as"] = _to_json_data(self.count_as)
        if self.reroll is not None:
             data["reroll"] = _to_json_data(self.reroll)
        return data

@dataclass
class MoveOutcomeExtensionReroll:
    method: 'Optional[MoveRerollMethod]'
    text: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOutcomeExtensionReroll':
        return cls(
            _from_json_data(Optional[MoveRerollMethod], data.get("method")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.method is not None:
             data["method"] = _to_json_data(self.method)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class MoveOutcomeExtension:
    """
    Extends or upgrades an outcome from an existing move.
    """

    count_as: 'Optional[MoveOutcomeType]'
    reroll: 'Optional[MoveOutcomeExtensionReroll]'
    text: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOutcomeExtension':
        return cls(
            _from_json_data(Optional[MoveOutcomeType], data.get("count_as")),
            _from_json_data(Optional[MoveOutcomeExtensionReroll], data.get("reroll")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.count_as is not None:
             data["count_as"] = _to_json_data(self.count_as)
        if self.reroll is not None:
             data["reroll"] = _to_json_data(self.reroll)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class MoveOutcomeMatchable:
    text: 'MarkdownString'
    count_as: 'Optional[MoveOutcomeType]'
    match: 'Optional[MoveOutcome]'
    reroll: 'Optional[MoveReroll]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOutcomeMatchable':
        return cls(
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Optional[MoveOutcomeType], data.get("count_as")),
            _from_json_data(Optional[MoveOutcome], data.get("match")),
            _from_json_data(Optional[MoveReroll], data.get("reroll")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        if self.count_as is not None:
             data["count_as"] = _to_json_data(self.count_as)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.reroll is not None:
             data["reroll"] = _to_json_data(self.reroll)
        return data

@dataclass
class MoveOutcomeMatchableExtensionReroll:
    method: 'Optional[MoveRerollMethod]'
    text: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOutcomeMatchableExtensionReroll':
        return cls(
            _from_json_data(Optional[MoveRerollMethod], data.get("method")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.method is not None:
             data["method"] = _to_json_data(self.method)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class MoveOutcomeMatchableExtension:
    """
    Extends or upgrades an outcome from an existing move.
    """

    count_as: 'Optional[MoveOutcomeType]'
    match: 'Optional[MoveOutcomeExtension]'
    reroll: 'Optional[MoveOutcomeMatchableExtensionReroll]'
    text: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOutcomeMatchableExtension':
        return cls(
            _from_json_data(Optional[MoveOutcomeType], data.get("count_as")),
            _from_json_data(Optional[MoveOutcomeExtension], data.get("match")),
            _from_json_data(Optional[MoveOutcomeMatchableExtensionReroll], data.get("reroll")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.count_as is not None:
             data["count_as"] = _to_json_data(self.count_as)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.reroll is not None:
             data["reroll"] = _to_json_data(self.reroll)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

class MoveOutcomeType(Enum):
    MISS = "miss"
    """
    The player's score doesn't beat any challenge dice.
    """

    STRONG_HIT = "strong_hit"
    """
    The player's score beats both of the challenge dice.
    """

    WEAK_HIT = "weak_hit"
    """
    The player's score beats one of the challenge dice.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOutcomeType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class MoveOutcomes:
    miss: 'MoveOutcomeMatchable'
    strong_hit: 'MoveOutcomeMatchable'
    weak_hit: 'MoveOutcome'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOutcomes':
        return cls(
            _from_json_data(MoveOutcomeMatchable, data.get("miss")),
            _from_json_data(MoveOutcomeMatchable, data.get("strong_hit")),
            _from_json_data(MoveOutcome, data.get("weak_hit")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["miss"] = _to_json_data(self.miss)
        data["strong_hit"] = _to_json_data(self.strong_hit)
        data["weak_hit"] = _to_json_data(self.weak_hit)
        return data

@dataclass
class MoveOutcomesExtension:
    """
    Extends or upgrades one or more outcomes of an existing move.
    """

    miss: 'Optional[MoveOutcomeMatchableExtension]'
    strong_hit: 'Optional[MoveOutcomeMatchableExtension]'
    weak_hit: 'Optional[MoveOutcomeExtension]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveOutcomesExtension':
        return cls(
            _from_json_data(Optional[MoveOutcomeMatchableExtension], data.get("miss")),
            _from_json_data(Optional[MoveOutcomeMatchableExtension], data.get("strong_hit")),
            _from_json_data(Optional[MoveOutcomeExtension], data.get("weak_hit")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.miss is not None:
             data["miss"] = _to_json_data(self.miss)
        if self.strong_hit is not None:
             data["strong_hit"] = _to_json_data(self.strong_hit)
        if self.weak_hit is not None:
             data["weak_hit"] = _to_json_data(self.weak_hit)
        return data

@dataclass
class MoveReroll:
    method: 'MoveRerollMethod'
    text: 'Optional[MarkdownString]'
    """
    Describes the trigger condition for the reroll, if any.
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveReroll':
        return cls(
            _from_json_data(MoveRerollMethod, data.get("method")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

class MoveRerollMethod(Enum):
    ACTION_DIE = "action_die"
    """
    Reroll the action die
    """

    ALL = "all"
    """
    Reroll all dice
    """

    ANY = "any"
    """
    Reroll any number of dice
    """

    CHALLENGE_DICE = "challenge_dice"
    """
    Reroll any number of challenge dice
    """

    CHALLENGE_DIE = "challenge_die"
    """
    Reroll one of the challenge dice
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveRerollMethod':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class MoveRollMethod(Enum):
    ALL = "all"
    """
    When rolling with this move trigger option, *every* stat or progress track
    of the `using` key is rolled
    """

    ANY = "any"
    """
    When rolling with this move trigger option, the player picks which stat
    to use.
    """

    HIGHEST = "highest"
    """
    When rolling with this move trigger option, use the highest/best option from
    the `using` key.
    """

    LOWEST = "lowest"
    """
    When rolling with this move trigger option, use the lowest/worst option from
    the `using` key.
    """

    MISS = "miss"
    """
    Take an automatic miss instead of rolling.
    """

    STRONG_HIT = "strong_hit"
    """
    Take an automatic strong hit instead of rolling.
    """

    WEAK_HIT = "weak_hit"
    """
    Take an automatic weak hit instead of rolling.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'MoveRollMethod':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleCollection:
    contents: 'Dict[str, OracleTable]'
    id: 'OracleCollectionID'
    name: 'Label'
    source: 'Source'
    summary: 'MarkdownString'
    canonical_name: 'Optional[Label]'
    collections: 'Optional[Dict[str, OracleCollection]]'
    color: 'Optional[Color]'
    description: 'Optional[MarkdownString]'
    rendering: 'Optional[OracleCollectionRendering]'
    sample_names: 'Optional[List[Label]]'
    suggestions: 'Optional[Suggestions]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollection':
        return cls(
            _from_json_data(Dict[str, OracleTable], data.get("contents")),
            _from_json_data(OracleCollectionID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(MarkdownString, data.get("summary")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[Dict[str, OracleCollection]], data.get("collections")),
            _from_json_data(Optional[Color], data.get("color")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[OracleCollectionRendering], data.get("rendering")),
            _from_json_data(Optional[List[Label]], data.get("sample_names")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["contents"] = _to_json_data(self.contents)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        data["summary"] = _to_json_data(self.summary)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.collections is not None:
             data["collections"] = _to_json_data(self.collections)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.rendering is not None:
             data["rendering"] = _to_json_data(self.rendering)
        if self.sample_names is not None:
             data["sample_names"] = _to_json_data(self.sample_names)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class OracleCollectionColumn:
    content_type: 'OracleColumnContentType'
    table_key: 'str'
    color: 'Optional[Color]'
    label: 'Optional[Label]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionColumn':
        return cls(
            _from_json_data(OracleColumnContentType, data.get("content_type")),
            _from_json_data(str, data.get("table_key")),
            _from_json_data(Optional[Color], data.get("color")),
            _from_json_data(Optional[Label], data.get("label")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["content_type"] = _to_json_data(self.content_type)
        data["table_key"] = _to_json_data(self.table_key)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.label is not None:
             data["label"] = _to_json_data(self.label)
        return data

@dataclass
class OracleCollectionID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class OracleCollectionRendering:
    columns: 'Dict[str, OracleCollectionColumn]'
    color: 'Optional[Color]'
    style: 'Optional[OracleCollectionStyle]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionRendering':
        return cls(
            _from_json_data(Dict[str, OracleCollectionColumn], data.get("columns")),
            _from_json_data(Optional[Color], data.get("color")),
            _from_json_data(Optional[OracleCollectionStyle], data.get("style")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["columns"] = _to_json_data(self.columns)
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.style is not None:
             data["style"] = _to_json_data(self.style)
        return data

class OracleCollectionStyle(Enum):
    MULTI_TABLE = "multi_table"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleCollectionStyle':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class OracleColumnContentType(Enum):
    DESCRIPTION = "description"
    RANGE = "range"
    RESULT = "result"
    SUMMARY = "summary"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleColumnContentType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleRollTemplate:
    description: 'Optional[TemplateString]'
    result: 'Optional[TemplateString]'
    summary: 'Optional[TemplateString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleRollTemplate':
        return cls(
            _from_json_data(Optional[TemplateString], data.get("description")),
            _from_json_data(Optional[TemplateString], data.get("result")),
            _from_json_data(Optional[TemplateString], data.get("summary")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.result is not None:
             data["result"] = _to_json_data(self.result)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        return data

@dataclass
class OracleTable:
    id: 'OracleTableID'
    name: 'Label'
    source: 'Source'
    table: 'List[OracleTableRow]'
    canonical_name: 'Optional[Label]'
    description: 'Optional[MarkdownString]'
    match: 'Optional[OracleTableMatchBehavior]'
    rendering: 'Optional[OracleTableRendering]'
    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTable':
        return cls(
            _from_json_data(OracleTableID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(List[OracleTableRow], data.get("table")),
            _from_json_data(Optional[Label], data.get("canonical_name")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[OracleTableMatchBehavior], data.get("match")),
            _from_json_data(Optional[OracleTableRendering], data.get("rendering")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        data["table"] = _to_json_data(self.table)
        if self.canonical_name is not None:
             data["canonical_name"] = _to_json_data(self.canonical_name)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.match is not None:
             data["match"] = _to_json_data(self.match)
        if self.rendering is not None:
             data["rendering"] = _to_json_data(self.rendering)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        return data

@dataclass
class OracleTableColumn:
    content_type: 'OracleColumnContentType'
    label: 'Optional[Label]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableColumn':
        return cls(
            _from_json_data(OracleColumnContentType, data.get("content_type")),
            _from_json_data(Optional[Label], data.get("label")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["content_type"] = _to_json_data(self.content_type)
        if self.label is not None:
             data["label"] = _to_json_data(self.label)
        return data

@dataclass
class OracleTableID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class OracleTableMatchBehavior:
    text: 'MarkdownString'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableMatchBehavior':
        return cls(
            _from_json_data(MarkdownString, data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["text"] = _to_json_data(self.text)
        return data

@dataclass
class OracleTableRendering:
    color: 'Optional[Color]'
    columns: 'Optional[Dict[str, OracleTableColumn]]'
    icon: 'Optional[SvgImageURL]'
    style: 'Optional[OracleTableStyle]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRendering':
        return cls(
            _from_json_data(Optional[Color], data.get("color")),
            _from_json_data(Optional[Dict[str, OracleTableColumn]], data.get("columns")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[OracleTableStyle], data.get("style")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.color is not None:
             data["color"] = _to_json_data(self.color)
        if self.columns is not None:
             data["columns"] = _to_json_data(self.columns)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.style is not None:
             data["style"] = _to_json_data(self.style)
        return data

@dataclass
class OracleTableRoll:
    oracle: 'OracleTableID'
    method: 'Optional[OracleTableRollMethod]'
    times: 'Optional[int]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRoll':
        return cls(
            _from_json_data(OracleTableID, data.get("oracle")),
            _from_json_data(Optional[OracleTableRollMethod], data.get("method")),
            _from_json_data(Optional[int], data.get("times")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["oracle"] = _to_json_data(self.oracle)
        if self.method is not None:
             data["method"] = _to_json_data(self.method)
        if self.times is not None:
             data["times"] = _to_json_data(self.times)
        return data

class OracleTableRollMethod(Enum):
    KEEP_DUPLICATES = "keep_duplicates"
    MAKE_IT_WORSE = "make_it_worse"
    NO_DUPLICATES = "no_duplicates"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRollMethod':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class OracleTableRow:
    high: 'Optional[int]'
    id: 'OracleTableRowID'
    low: 'Optional[int]'
    result: 'MarkdownString'
    description: 'Optional[MarkdownString]'
    embed_table: 'Optional[OracleTableID]'
    icon: 'Optional[SvgImageURL]'
    rolls: 'Optional[List[OracleTableRoll]]'
    suggestions: 'Optional[Suggestions]'
    summary: 'Optional[MarkdownString]'
    template: 'Optional[OracleRollTemplate]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRow':
        return cls(
            _from_json_data(Optional[int], data.get("high")),
            _from_json_data(OracleTableRowID, data.get("id")),
            _from_json_data(Optional[int], data.get("low")),
            _from_json_data(MarkdownString, data.get("result")),
            _from_json_data(Optional[MarkdownString], data.get("description")),
            _from_json_data(Optional[OracleTableID], data.get("embed_table")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[List[OracleTableRoll]], data.get("rolls")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
            _from_json_data(Optional[MarkdownString], data.get("summary")),
            _from_json_data(Optional[OracleRollTemplate], data.get("template")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["high"] = _to_json_data(self.high)
        data["id"] = _to_json_data(self.id)
        data["low"] = _to_json_data(self.low)
        data["result"] = _to_json_data(self.result)
        if self.description is not None:
             data["description"] = _to_json_data(self.description)
        if self.embed_table is not None:
             data["embed_table"] = _to_json_data(self.embed_table)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.rolls is not None:
             data["rolls"] = _to_json_data(self.rolls)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        if self.summary is not None:
             data["summary"] = _to_json_data(self.summary)
        if self.template is not None:
             data["template"] = _to_json_data(self.template)
        return data

@dataclass
class OracleTableRowID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableRowID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

class OracleTableStyle(Enum):
    EMBED_AS_COLUMN = "embed_as_column"
    EMBED_IN_ROW = "embed_in_row"
    TABLE = "table"
    @classmethod
    def from_json_data(cls, data: Any) -> 'OracleTableStyle':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class PlayerAttributeRollable(Enum):
    """
    A standard player stat, or a condition meter that can be used as a stat in
    an action roll.
    """

    EDGE = "edge"
    HEALTH = "health"
    HEART = "heart"
    IRON = "iron"
    SHADOW = "shadow"
    SPIRIT = "spirit"
    SUPPLY = "supply"
    WITS = "wits"
    @classmethod
    def from_json_data(cls, data: Any) -> 'PlayerAttributeRollable':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class PlayerConditionMeter(Enum):
    """
    A standard player character condition meter.
    """

    HEALTH = "health"
    SPIRIT = "spirit"
    SUPPLY = "supply"
    @classmethod
    def from_json_data(cls, data: Any) -> 'PlayerConditionMeter':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class PlayerStat(Enum):
    """
    A standard player character stat.
    """

    EDGE = "edge"
    HEART = "heart"
    IRON = "iron"
    SHADOW = "shadow"
    WITS = "wits"
    @classmethod
    def from_json_data(cls, data: Any) -> 'PlayerStat':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class ProgressType(Enum):
    BONDS_LEGACY = "bonds_legacy"
    """
    A player's Bonds legacy track(Starforged ruleset only)
    """

    BONDS_PROGRESS = "bonds_progress"
    """
    A player's bonds progress track (Ironsworn ruleset only)
    """

    COMBAT_PROGRESS = "combat_progress"
    """
    A combat progress track, started with Enter the Fray.
    """

    CONNECTION_PROGRESS = "connection_progress"
    """
    A connection progress track, started with Make a Connection (Starforged
    ruleset only)
    """

    DELVE_PROGRESS = "delve_progress"
    """
    A delve site progress track, started with Discover a Site (Ironsworn ruleset
    only)
    """

    DISCOVERIES_LEGACY = "discoveries_legacy"
    """
    A player's Discoveries legacy track(Starforged ruleset only)
    """

    EXPEDITION_PROGRESS = "expedition_progress"
    """
    An expedition progress track, started with Undertake an Expedition
    (Starforged ruleset only)
    """

    JOURNEY_PROGRESS = "journey_progress"
    """
    A journey progress track, started with Undertake a Journey (Ironsworn
    ruleset only)
    """

    QUESTS_LEGACY = "quests_legacy"
    """
    A player's Quests legacy track (Starforged ruleset only)
    """

    SCENE_CHALLENGE_PROGRESS = "scene_challenge_progress"
    """
    A scene challenge progress track.
    """

    VOW_PROGRESS = "vow_progress"
    """
    A vow progress track, started with Swear an Iron Vow.
    """

    @classmethod
    def from_json_data(cls, data: Any) -> 'ProgressType':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Rarity:
    asset: 'AssetID'
    description: 'MarkdownString'
    id: 'RarityID'
    name: 'Label'
    source: 'Source'
    xp_cost: 'int'
    icon: 'Optional[SvgImageURL]'
    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Rarity':
        return cls(
            _from_json_data(AssetID, data.get("asset")),
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(RarityID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(int, data.get("xp_cost")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["asset"] = _to_json_data(self.asset)
        data["description"] = _to_json_data(self.description)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["source"] = _to_json_data(self.source)
        data["xp_cost"] = _to_json_data(self.xp_cost)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class RarityID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RarityID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class RegionEntry:
    description: 'MarkdownString'
    features: 'List[MarkdownString]'
    id: 'RegionEntryID'
    name: 'Label'
    quest_starter: 'MarkdownString'
    source: 'Source'
    summary: 'MarkdownString'
    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RegionEntry':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(List[MarkdownString], data.get("features")),
            _from_json_data(RegionEntryID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(MarkdownString, data.get("quest_starter")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(MarkdownString, data.get("summary")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["features"] = _to_json_data(self.features)
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["quest_starter"] = _to_json_data(self.quest_starter)
        data["source"] = _to_json_data(self.source)
        data["summary"] = _to_json_data(self.summary)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class RegionEntryID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RegionEntryID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class RegularExpression:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RegularExpression':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class SettingTruth:
    id: 'SettingTruthID'
    name: 'Label'
    options: 'List[SettingTruthOption]'
    source: 'Source'
    icon: 'Optional[SvgImageURL]'
    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SettingTruth':
        return cls(
            _from_json_data(SettingTruthID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[SettingTruthOption], data.get("options")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["options"] = _to_json_data(self.options)
        data["source"] = _to_json_data(self.source)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class SettingTruthID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SettingTruthID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class SettingTruthOption:
    description: 'MarkdownString'
    id: 'SettingTruthOptionID'
    quest_starter: 'MarkdownString'
    summary: 'MarkdownString'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SettingTruthOption':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(SettingTruthOptionID, data.get("id")),
            _from_json_data(MarkdownString, data.get("quest_starter")),
            _from_json_data(MarkdownString, data.get("summary")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["id"] = _to_json_data(self.id)
        data["quest_starter"] = _to_json_data(self.quest_starter)
        data["summary"] = _to_json_data(self.summary)
        return data

@dataclass
class SettingTruthOptionID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SettingTruthOptionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Source:
    authors: 'List[str]'
    date: 'datetime'
    license: 'URL'
    title: 'str'
    url: 'URL'
    page: 'Optional[int]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Source':
        return cls(
            _from_json_data(List[str], data.get("authors")),
            _from_json_data(datetime, data.get("date")),
            _from_json_data(URL, data.get("license")),
            _from_json_data(str, data.get("title")),
            _from_json_data(URL, data.get("url")),
            _from_json_data(Optional[int], data.get("page")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["authors"] = _to_json_data(self.authors)
        data["date"] = _to_json_data(self.date)
        data["license"] = _to_json_data(self.license)
        data["title"] = _to_json_data(self.title)
        data["url"] = _to_json_data(self.url)
        if self.page is not None:
             data["page"] = _to_json_data(self.page)
        return data

@dataclass
class StatID:
    """
    A player stat (e.g. `player/stats/edge`), a player condition meter (e.g.
    `player/meters/health`), or an ID pointing to an asset option or asset
    control whose value is to be used.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'StatID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Suggestions:
    assets: 'Optional[List[AssetID]]'
    moves: 'Optional[List[MoveID]]'
    oracles: 'Optional[List[OracleTableID]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Suggestions':
        return cls(
            _from_json_data(Optional[List[AssetID]], data.get("assets")),
            _from_json_data(Optional[List[MoveID]], data.get("moves")),
            _from_json_data(Optional[List[OracleTableID]], data.get("oracles")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        if self.assets is not None:
             data["assets"] = _to_json_data(self.assets)
        if self.moves is not None:
             data["moves"] = _to_json_data(self.moves)
        if self.oracles is not None:
             data["oracles"] = _to_json_data(self.oracles)
        return data

@dataclass
class SvgImageURL:
    """
    A relative URL pointing to an SVG image.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SvgImageURL':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class TemplateString:
    """
    A rich text string in Markdown with replaced values from oracle roll
    results.
    
          The custom syntax `{{some_row_key:some_oracle_table_id}}`
    should be replaced by the `some_row_key` string of a rolled
    oracle table. This is usually the `result` key, for example
    `{{result:starforged/oracles/core/action}}`
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TemplateString':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class Trigger:
    """
    Describes a move's trigger condition(s) and any rolls associated with them.
    """

    roll_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Trigger':
        variants: Dict[str, Type[Trigger]] = {
            "action_roll": TriggerActionRoll,
            "progress_roll": TriggerProgressRoll,
        }

        return variants[data["roll_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class TriggerActionRoll(Trigger):
    text: 'MarkdownString'
    """
    Text describing the primary trigger condition of the move. Any trigger
    options are assumed to meet this condition in addition to their own trigger
    conditions.
    """

    roll_options: 'Optional[List[TriggerRollOptionAction]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerActionRoll':
        return cls(
            "action_roll",
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Optional[List[TriggerRollOptionAction]], data.get("roll_options")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "action_roll" }
        data["text"] = _to_json_data(self.text)
        if self.roll_options is not None:
             data["roll_options"] = _to_json_data(self.roll_options)
        return data

@dataclass
class TriggerProgressRoll(Trigger):
    text: 'MarkdownString'
    """
    Text describing the primary trigger condition of the move. Any trigger
    options are assumed to meet this condition in addition to their own trigger
    conditions.
    """

    roll_options: 'Optional[List[TriggerRollOptionProgress]]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerProgressRoll':
        return cls(
            "progress_roll",
            _from_json_data(MarkdownString, data.get("text")),
            _from_json_data(Optional[List[TriggerRollOptionProgress]], data.get("roll_options")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "progress_roll" }
        data["text"] = _to_json_data(self.text)
        if self.roll_options is not None:
             data["roll_options"] = _to_json_data(self.roll_options)
        return data

@dataclass
class TriggerBy:
    """
    Information on who can trigger this trigger option. Usually this is just the
    player, but some asset abilities can trigger from an ally's move.
    """

    ally: 'bool'
    player: 'bool'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerBy':
        return cls(
            _from_json_data(bool, data.get("ally")),
            _from_json_data(bool, data.get("player")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["ally"] = _to_json_data(self.ally)
        data["player"] = _to_json_data(self.player)
        return data

@dataclass
class TriggerExtension:
    """
    Extends or upgrades an existing move trigger.
    """

    roll_type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerExtension':
        variants: Dict[str, Type[TriggerExtension]] = {
            "action_roll": TriggerExtensionActionRoll,
            "progress_roll": TriggerExtensionProgressRoll,
        }

        return variants[data["roll_type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class TriggerExtensionActionRoll(TriggerExtension):
    """
    Extends or upgrades an existing action roll trigger.
    """

    roll_options: 'List[TriggerRollOptionAction]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerExtensionActionRoll':
        return cls(
            "action_roll",
            _from_json_data(List[TriggerRollOptionAction], data.get("roll_options")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "action_roll" }
        data["roll_options"] = _to_json_data(self.roll_options)
        return data

@dataclass
class TriggerExtensionProgressRoll(TriggerExtension):
    """
    Extends or upgrades an existing action roll trigger.
    """

    roll_options: 'List[TriggerRollOptionProgress]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerExtensionProgressRoll':
        return cls(
            "progress_roll",
            _from_json_data(List[TriggerRollOptionProgress], data.get("roll_options")),
        )

    def to_json_data(self) -> Any:
        data = { "roll_type": "progress_roll" }
        data["roll_options"] = _to_json_data(self.roll_options)
        return data

@dataclass
class TriggerRollOptionAction:
    method: 'Optional[MoveRollMethod]'
    by: 'Optional[TriggerBy]'
    choices: 'Optional[List[TriggerRollOptionActionChoice]]'
    text: 'Optional[MarkdownString]'
    """
    Describes any additional trigger conditions for this trigger option
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerRollOptionAction':
        return cls(
            _from_json_data(Optional[MoveRollMethod], data.get("method")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[List[TriggerRollOptionActionChoice]], data.get("choices")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.choices is not None:
             data["choices"] = _to_json_data(self.choices)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerRollOptionActionChoice:
    using: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerRollOptionActionChoice':
        variants: Dict[str, Type[TriggerRollOptionActionChoice]] = {
            "custom_value": TriggerRollOptionActionChoiceCustomValue,
            "edge": TriggerRollOptionActionChoiceEdge,
            "health": TriggerRollOptionActionChoiceHealth,
            "heart": TriggerRollOptionActionChoiceHeart,
            "iron": TriggerRollOptionActionChoiceIron,
            "ref": TriggerRollOptionActionChoiceRef,
            "shadow": TriggerRollOptionActionChoiceShadow,
            "spirit": TriggerRollOptionActionChoiceSpirit,
            "supply": TriggerRollOptionActionChoiceSupply,
            "wits": TriggerRollOptionActionChoiceWits,
        }

        return variants[data["using"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class TriggerRollOptionActionChoiceCustomValue(TriggerRollOptionActionChoice):
    label: 'Label'
    value: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerRollOptionActionChoiceCustomValue':
        return cls(
            "custom_value",
            _from_json_data(Label, data.get("label")),
            _from_json_data(int, data.get("value")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "custom_value" }
        data["label"] = _to_json_data(self.label)
        data["value"] = _to_json_data(self.value)
        return data

@dataclass
class TriggerRollOptionActionChoiceEdge(TriggerRollOptionActionChoice):

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerRollOptionActionChoiceEdge':
        return cls(
            "edge",
        )

    def to_json_data(self) -> Any:
        data = { "using": "edge" }
        return data

@dataclass
class TriggerRollOptionActionChoiceHealth(TriggerRollOptionActionChoice):

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerRollOptionActionChoiceHealth':
        return cls(
            "health",
        )

    def to_json_data(self) -> Any:
        data = { "using": "health" }
        return data

@dataclass
class TriggerRollOptionActionChoiceHeart(TriggerRollOptionActionChoice):

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerRollOptionActionChoiceHeart':
        return cls(
            "heart",
        )

    def to_json_data(self) -> Any:
        data = { "using": "heart" }
        return data

@dataclass
class TriggerRollOptionActionChoiceIron(TriggerRollOptionActionChoice):

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerRollOptionActionChoiceIron':
        return cls(
            "iron",
        )

    def to_json_data(self) -> Any:
        data = { "using": "iron" }
        return data

@dataclass
class TriggerRollOptionActionChoiceRef(TriggerRollOptionActionChoice):
    ref: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerRollOptionActionChoiceRef':
        return cls(
            "ref",
            _from_json_data(str, data.get("ref")),
        )

    def to_json_data(self) -> Any:
        data = { "using": "ref" }
        data["ref"] = _to_json_data(self.ref)
        return data

@dataclass
class TriggerRollOptionActionChoiceShadow(TriggerRollOptionActionChoice):

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerRollOptionActionChoiceShadow':
        return cls(
            "shadow",
        )

    def to_json_data(self) -> Any:
        data = { "using": "shadow" }
        return data

@dataclass
class TriggerRollOptionActionChoiceSpirit(TriggerRollOptionActionChoice):

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerRollOptionActionChoiceSpirit':
        return cls(
            "spirit",
        )

    def to_json_data(self) -> Any:
        data = { "using": "spirit" }
        return data

@dataclass
class TriggerRollOptionActionChoiceSupply(TriggerRollOptionActionChoice):

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerRollOptionActionChoiceSupply':
        return cls(
            "supply",
        )

    def to_json_data(self) -> Any:
        data = { "using": "supply" }
        return data

@dataclass
class TriggerRollOptionActionChoiceWits(TriggerRollOptionActionChoice):

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerRollOptionActionChoiceWits':
        return cls(
            "wits",
        )

    def to_json_data(self) -> Any:
        data = { "using": "wits" }
        return data

@dataclass
class TriggerRollOptionProgress:
    method: 'Optional[MoveRollMethod]'
    by: 'Optional[TriggerBy]'
    choices: 'Optional[List[TriggerRollOptionProgressChoice]]'
    text: 'Optional[MarkdownString]'
    """
    Describes any additional trigger conditions for this trigger option
    """


    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerRollOptionProgress':
        return cls(
            _from_json_data(Optional[MoveRollMethod], data.get("method")),
            _from_json_data(Optional[TriggerBy], data.get("by")),
            _from_json_data(Optional[List[TriggerRollOptionProgressChoice]], data.get("choices")),
            _from_json_data(Optional[MarkdownString], data.get("text")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["method"] = _to_json_data(self.method)
        if self.by is not None:
             data["by"] = _to_json_data(self.by)
        if self.choices is not None:
             data["choices"] = _to_json_data(self.choices)
        if self.text is not None:
             data["text"] = _to_json_data(self.text)
        return data

@dataclass
class TriggerRollOptionProgressChoice:
    using: 'ProgressType'

    @classmethod
    def from_json_data(cls, data: Any) -> 'TriggerRollOptionProgressChoice':
        return cls(
            _from_json_data(ProgressType, data.get("using")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["using"] = _to_json_data(self.using)
        return data

@dataclass
class URL:
    """
    An absolute URL pointing to a web site.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'URL':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class WebpImageURL:
    """
    A relative URL pointing to a WEBP image.
    """

    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WebpImageURL':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class WorldTruth:
    id: 'WorldTruthID'
    name: 'Label'
    options: 'List[WorldTruthOption]'
    source: 'Source'
    icon: 'Optional[SvgImageURL]'
    suggestions: 'Optional[Suggestions]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WorldTruth':
        return cls(
            _from_json_data(WorldTruthID, data.get("id")),
            _from_json_data(Label, data.get("name")),
            _from_json_data(List[WorldTruthOption], data.get("options")),
            _from_json_data(Source, data.get("source")),
            _from_json_data(Optional[SvgImageURL], data.get("icon")),
            _from_json_data(Optional[Suggestions], data.get("suggestions")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["id"] = _to_json_data(self.id)
        data["name"] = _to_json_data(self.name)
        data["options"] = _to_json_data(self.options)
        data["source"] = _to_json_data(self.source)
        if self.icon is not None:
             data["icon"] = _to_json_data(self.icon)
        if self.suggestions is not None:
             data["suggestions"] = _to_json_data(self.suggestions)
        return data

@dataclass
class WorldTruthID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WorldTruthID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

@dataclass
class WorldTruthOption:
    description: 'MarkdownString'
    id: 'WorldTruthOptionID'
    quest_starter: 'MarkdownString'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WorldTruthOption':
        return cls(
            _from_json_data(MarkdownString, data.get("description")),
            _from_json_data(WorldTruthOptionID, data.get("id")),
            _from_json_data(MarkdownString, data.get("quest_starter")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["description"] = _to_json_data(self.description)
        data["id"] = _to_json_data(self.id)
        data["quest_starter"] = _to_json_data(self.quest_starter)
        return data

@dataclass
class WorldTruthOptionID:
    value: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'WorldTruthOptionID':
        return cls(_from_json_data(str, data))

    def to_json_data(self) -> Any:
        return _to_json_data(self.value)

def _from_json_data(cls: Any, data: Any) -> Any:
    if data is None or cls in [bool, int, float, str, object] or cls is Any:
        return data
    if cls is datetime:
        return _parse_rfc3339(data)
    if get_origin(cls) is Union:
        return _from_json_data(get_args(cls)[0], data)
    if get_origin(cls) is list:
        return [_from_json_data(get_args(cls)[0], d) for d in data]
    if get_origin(cls) is dict:
        return { k: _from_json_data(get_args(cls)[1], v) for k, v in data.items() }
    return cls.from_json_data(data)

def _to_json_data(data: Any) -> Any:
    if data is None or type(data) in [bool, int, float, str, object]:
        return data
    if type(data) is datetime:
        return data.isoformat()
    if type(data) is list:
        return [_to_json_data(d) for d in data]
    if type(data) is dict:
        return { k: _to_json_data(v) for k, v in data.items() }
    return data.to_json_data()

def _parse_rfc3339(s: str) -> datetime:
    datetime_re = '^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(\.\d+)?([zZ]|((\+|-)(\d{2}):(\d{2})))$'
    match = re.match(datetime_re, s)
    if not match:
        raise ValueError('Invalid RFC3339 date/time', s)

    (year, month, day, hour, minute, second, frac_seconds, offset,
     *tz) = match.groups()

    frac_seconds_parsed = None
    if frac_seconds:
        frac_seconds_parsed = int(float(frac_seconds) * 1_000_000)
    else:
        frac_seconds_parsed = 0

    tzinfo = None
    if offset == 'Z':
        tzinfo = timezone.utc
    else:
        hours = int(tz[2])
        minutes = int(tz[3])
        sign = 1 if tz[1] == '+' else -1

        if minutes not in range(60):
            raise ValueError('minute offset must be in 0..59')

        tzinfo = timezone(timedelta(minutes=sign * (60 * hours + minutes)))

    second_parsed = int(second)
    if second_parsed == 60:
        second_parsed = 59

    return datetime(int(year), int(month), int(day), int(hour), int(minute),
                    second_parsed, frac_seconds_parsed, tzinfo)            
