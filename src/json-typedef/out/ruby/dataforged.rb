# Code generated by jtd-codegen for Ruby v0.1.1

require 'json'
require 'time'

module Dataforged

  class Dataforged
    attr_accessor :value

    def self.from_json_data(data)
      out = Dataforged.new
      out.value = Dataforged.from_json_data(Object, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class Asset
    attr_accessor :abilities
    attr_accessor :id
    attr_accessor :name
    attr_accessor :source
    attr_accessor :attachments
    attr_accessor :controls

    # If `true`, this asset counts as an impact (Starforged) or a debility
    # (classic Ironsworn).
    attr_accessor :count_as_impact
    attr_accessor :options
    attr_accessor :requirement

    # Most assets only benefit to their owner, but certain assets (like
    # Starforged's module and command vehicle assets) are shared amongst the
    # player's allies, too.
    attr_accessor :shared

    def self.from_json_data(data)
      out = Asset.new
      out.abilities = Dataforged::from_json_data(Array[AssetAbility], data["abilities"])
      out.id = Dataforged::from_json_data(AssetID, data["id"])
      out.name = Dataforged::from_json_data(Label, data["name"])
      out.source = Dataforged::from_json_data(Source, data["source"])
      out.attachments = Dataforged::from_json_data(AssetAttachment, data["attachments"])
      out.controls = Dataforged::from_json_data(Hash[String, AssetControlField], data["controls"])
      out.count_as_impact = Dataforged::from_json_data(TrueClass, data["count_as_impact"])
      out.options = Dataforged::from_json_data(Hash[String, AssetOptionField], data["options"])
      out.requirement = Dataforged::from_json_data(MarkdownString, data["requirement"])
      out.shared = Dataforged::from_json_data(TrueClass, data["shared"])
      out
    end

    def to_json_data
      data = {}
      data["abilities"] = Dataforged::to_json_data(abilities)
      data["id"] = Dataforged::to_json_data(id)
      data["name"] = Dataforged::to_json_data(name)
      data["source"] = Dataforged::to_json_data(source)
      data["attachments"] = Dataforged::to_json_data(attachments) unless attachments.nil?
      data["controls"] = Dataforged::to_json_data(controls) unless controls.nil?
      data["count_as_impact"] = Dataforged::to_json_data(count_as_impact) unless count_as_impact.nil?
      data["options"] = Dataforged::to_json_data(options) unless options.nil?
      data["requirement"] = Dataforged::to_json_data(requirement) unless requirement.nil?
      data["shared"] = Dataforged::to_json_data(shared) unless shared.nil?
      data
    end
  end

  class AssetAbility
    attr_accessor :enabled
    attr_accessor :id
    attr_accessor :text
    attr_accessor :controls
    attr_accessor :extend_asset
    attr_accessor :extend_moves
    attr_accessor :moves
    attr_accessor :name
    attr_accessor :options

    def self.from_json_data(data)
      out = AssetAbility.new
      out.enabled = Dataforged::from_json_data(TrueClass, data["enabled"])
      out.id = Dataforged::from_json_data(AssetAbilityID, data["id"])
      out.text = Dataforged::from_json_data(MarkdownString, data["text"])
      out.controls = Dataforged::from_json_data(Hash[String, AssetAbilityControlField], data["controls"])
      out.extend_asset = Dataforged::from_json_data(AssetExtension, data["extend_asset"])
      out.extend_moves = Dataforged::from_json_data(Array[MoveExtension], data["extend_moves"])
      out.moves = Dataforged::from_json_data(Hash[String, Move], data["moves"])
      out.name = Dataforged::from_json_data(Label, data["name"])
      out.options = Dataforged::from_json_data(Hash[String, AssetOptionField], data["options"])
      out
    end

    def to_json_data
      data = {}
      data["enabled"] = Dataforged::to_json_data(enabled)
      data["id"] = Dataforged::to_json_data(id)
      data["text"] = Dataforged::to_json_data(text)
      data["controls"] = Dataforged::to_json_data(controls) unless controls.nil?
      data["extend_asset"] = Dataforged::to_json_data(extend_asset) unless extend_asset.nil?
      data["extend_moves"] = Dataforged::to_json_data(extend_moves) unless extend_moves.nil?
      data["moves"] = Dataforged::to_json_data(moves) unless moves.nil?
      data["name"] = Dataforged::to_json_data(name) unless name.nil?
      data["options"] = Dataforged::to_json_data(options) unless options.nil?
      data
    end
  end

  class AssetAbilityControlField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "checkbox" => AssetAbilityControlFieldCheckbox,
        "clock" => AssetAbilityControlFieldClock,
        "counter" => AssetAbilityControlFieldCounter,
      }[data["field_type"]].from_json_data(data)
    end
  end

  class AssetAbilityControlFieldCheckbox < AssetAbilityControlField
    attr_accessor :id
    attr_accessor :label
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityControlFieldCheckbox.new
      out.field_type = "checkbox"
      out.id = Dataforged::from_json_data(AssetAbilityControlFieldID, data["id"])
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.value = Dataforged::from_json_data(TrueClass, data["value"])
      out
    end

    def to_json_data
      data = { "field_type" => "checkbox" }
      data["id"] = Dataforged::to_json_data(id)
      data["label"] = Dataforged::to_json_data(label)
      data["value"] = Dataforged::to_json_data(value)
      data
    end
  end

  class AssetAbilityControlFieldClock < AssetAbilityControlField
    attr_accessor :id
    attr_accessor :label
    attr_accessor :max
    attr_accessor :min
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityControlFieldClock.new
      out.field_type = "clock"
      out.id = Dataforged::from_json_data(AssetAbilityControlFieldID, data["id"])
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.max = Dataforged::from_json_data(Integer, data["max"])
      out.min = Dataforged::from_json_data(Integer, data["min"])
      out.value = Dataforged::from_json_data(Integer, data["value"])
      out
    end

    def to_json_data
      data = { "field_type" => "clock" }
      data["id"] = Dataforged::to_json_data(id)
      data["label"] = Dataforged::to_json_data(label)
      data["max"] = Dataforged::to_json_data(max)
      data["min"] = Dataforged::to_json_data(min)
      data["value"] = Dataforged::to_json_data(value)
      data
    end
  end

  class AssetAbilityControlFieldCounter < AssetAbilityControlField
    attr_accessor :id
    attr_accessor :label
    attr_accessor :max
    attr_accessor :min
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityControlFieldCounter.new
      out.field_type = "counter"
      out.id = Dataforged::from_json_data(AssetAbilityControlFieldID, data["id"])
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.max = Dataforged::from_json_data(Integer, data["max"])
      out.min = Dataforged::from_json_data(Integer, data["min"])
      out.value = Dataforged::from_json_data(Integer, data["value"])
      out
    end

    def to_json_data
      data = { "field_type" => "counter" }
      data["id"] = Dataforged::to_json_data(id)
      data["label"] = Dataforged::to_json_data(label)
      data["max"] = Dataforged::to_json_data(max)
      data["min"] = Dataforged::to_json_data(min)
      data["value"] = Dataforged::to_json_data(value)
      data
    end
  end

  class AssetAbilityControlFieldID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityControlFieldID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class AssetAbilityID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class AssetAbilityOptionFieldID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetAbilityOptionFieldID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  # Describes which assets can be attached to this asset. The "canonical"
  # example for this are Starforged's Module assets, which can be equipped by
  # Command Vehicle assets. See p. 55 of Starforged for more info.
  class AssetAttachment
    # Regular expressions matching the IDs of assets that can be attached to
    # this asset.
    attr_accessor :patterns

    # The maximum number of attached assets. Omitted if there's no upper limit
    # to the number of attached assets.
    attr_accessor :max

    def self.from_json_data(data)
      out = AssetAttachment.new
      out.patterns = Dataforged::from_json_data(Array[RegularExpression], data["patterns"])
      out.max = Dataforged::from_json_data(Integer, data["max"])
      out
    end

    def to_json_data
      data = {}
      data["patterns"] = Dataforged::to_json_data(patterns)
      data["max"] = Dataforged::to_json_data(max) unless max.nil?
      data
    end
  end

  # Asset controls are fields that are expected to change throughout the
  # asset's lifespan. The most common example are the condition meters on
  # certain assets. A more complex example is the distinct mechanical modes on
  # Ironsworn's 'Armored'.
  class AssetControlField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "checkbox" => AssetControlFieldCheckbox,
        "condition_meter" => AssetControlFieldConditionMeter,
        "select_asset_extension" => AssetControlFieldSelectAssetExtension,
      }[data["field_type"]].from_json_data(data)
    end
  end

  class AssetControlFieldCheckbox < AssetControlField
    attr_accessor :id
    attr_accessor :label
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetControlFieldCheckbox.new
      out.field_type = "checkbox"
      out.id = Dataforged::from_json_data(AssetAbilityControlFieldID, data["id"])
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.value = Dataforged::from_json_data(TrueClass, data["value"])
      out
    end

    def to_json_data
      data = { "field_type" => "checkbox" }
      data["id"] = Dataforged::to_json_data(id)
      data["label"] = Dataforged::to_json_data(label)
      data["value"] = Dataforged::to_json_data(value)
      data
    end
  end

  class AssetControlFieldConditionMeter < AssetControlField
    attr_accessor :id
    attr_accessor :label
    attr_accessor :max
    attr_accessor :min
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetControlFieldConditionMeter.new
      out.field_type = "condition_meter"
      out.id = Dataforged::from_json_data(AssetAbilityControlFieldID, data["id"])
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.max = Dataforged::from_json_data(Integer, data["max"])
      out.min = Dataforged::from_json_data(Integer, data["min"])
      out.value = Dataforged::from_json_data(Integer, data["value"])
      out
    end

    def to_json_data
      data = { "field_type" => "condition_meter" }
      data["id"] = Dataforged::to_json_data(id)
      data["label"] = Dataforged::to_json_data(label)
      data["max"] = Dataforged::to_json_data(max)
      data["min"] = Dataforged::to_json_data(min)
      data["value"] = Dataforged::to_json_data(value)
      data
    end
  end

  class AssetControlFieldSelectAssetExtensionChoice
    attr_accessor :label
    attr_accessor :value
    attr_accessor :selected

    def self.from_json_data(data)
      out = AssetControlFieldSelectAssetExtensionChoice.new
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.value = Dataforged::from_json_data(AssetExtension, data["value"])
      out.selected = Dataforged::from_json_data(TrueClass, data["selected"])
      out
    end

    def to_json_data
      data = {}
      data["label"] = Dataforged::to_json_data(label)
      data["value"] = Dataforged::to_json_data(value)
      data["selected"] = Dataforged::to_json_data(selected) unless selected.nil?
      data
    end
  end

  class AssetControlFieldSelectAssetExtension < AssetControlField
    attr_accessor :choices
    attr_accessor :id
    attr_accessor :label
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetControlFieldSelectAssetExtension.new
      out.field_type = "select_asset_extension"
      out.choices = Dataforged::from_json_data(Hash[String, AssetControlFieldSelectAssetExtensionChoice], data["choices"])
      out.id = Dataforged::from_json_data(AssetAbilityControlFieldID, data["id"])
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.value = Dataforged::from_json_data(AssetExtension, data["value"])
      out
    end

    def to_json_data
      data = { "field_type" => "select_asset_extension" }
      data["choices"] = Dataforged::to_json_data(choices)
      data["id"] = Dataforged::to_json_data(id)
      data["label"] = Dataforged::to_json_data(label)
      data["value"] = Dataforged::to_json_data(value) unless value.nil?
      data
    end
  end

  class AssetExtensionAttachments
    attr_accessor :max
    attr_accessor :patterns

    def self.from_json_data(data)
      out = AssetExtensionAttachments.new
      out.max = Dataforged::from_json_data(Integer, data["max"])
      out.patterns = Dataforged::from_json_data(Array[RegularExpression], data["patterns"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Dataforged::to_json_data(max) unless max.nil?
      data["patterns"] = Dataforged::to_json_data(patterns) unless patterns.nil?
      data
    end
  end

  class AssetExtensionControl
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = AssetExtensionControl.new
      out.max = Dataforged::from_json_data(Integer, data["max"])
      out.min = Dataforged::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Dataforged::to_json_data(max) unless max.nil?
      data["min"] = Dataforged::to_json_data(min) unless min.nil?
      data
    end
  end

  # Describes changes applied to an asset by its own abilities or controls.
  # Unchanged properties are omitted.
  class AssetExtension
    attr_accessor :attachments

    # Use the same key as the original control. Currently, only condition meters
    # may be extended in this way.
    attr_accessor :controls
    attr_accessor :count_as_impact

    def self.from_json_data(data)
      out = AssetExtension.new
      out.attachments = Dataforged::from_json_data(AssetExtensionAttachments, data["attachments"])
      out.controls = Dataforged::from_json_data(Hash[String, AssetExtensionControl], data["controls"])
      out.count_as_impact = Dataforged::from_json_data(TrueClass, data["count_as_impact"])
      out
    end

    def to_json_data
      data = {}
      data["attachments"] = Dataforged::to_json_data(attachments) unless attachments.nil?
      data["controls"] = Dataforged::to_json_data(controls) unless controls.nil?
      data["count_as_impact"] = Dataforged::to_json_data(count_as_impact) unless count_as_impact.nil?
      data
    end
  end

  class AssetExtensionChoice
    attr_accessor :label
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetExtensionChoice.new
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.value = Dataforged::from_json_data(AssetExtension, data["value"])
      out
    end

    def to_json_data
      data = {}
      data["label"] = Dataforged::to_json_data(label)
      data["value"] = Dataforged::to_json_data(value)
      data
    end
  end

  class AssetExtensionForeignAttachments
    attr_accessor :max
    attr_accessor :patterns

    def self.from_json_data(data)
      out = AssetExtensionForeignAttachments.new
      out.max = Dataforged::from_json_data(Integer, data["max"])
      out.patterns = Dataforged::from_json_data(Array[RegularExpression], data["patterns"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Dataforged::to_json_data(max) unless max.nil?
      data["patterns"] = Dataforged::to_json_data(patterns) unless patterns.nil?
      data
    end
  end

  class AssetExtensionForeignControl
    attr_accessor :max
    attr_accessor :min

    def self.from_json_data(data)
      out = AssetExtensionForeignControl.new
      out.max = Dataforged::from_json_data(Integer, data["max"])
      out.min = Dataforged::from_json_data(Integer, data["min"])
      out
    end

    def to_json_data
      data = {}
      data["max"] = Dataforged::to_json_data(max) unless max.nil?
      data["min"] = Dataforged::to_json_data(min) unless min.nil?
      data
    end
  end

  # Describes changes applied to an asset, usually by another asset. Unchanged
  # properties are omitted.
  class AssetExtensionForeign
    attr_accessor :extends
    attr_accessor :id
    attr_accessor :attachments

    # Use the same key as the original control. Currently, only condition meters
    # may be extended in this way.
    attr_accessor :controls
    attr_accessor :count_as_impact

    def self.from_json_data(data)
      out = AssetExtensionForeign.new
      out.extends = Dataforged::from_json_data(AssetID, data["extends"])
      out.id = Dataforged::from_json_data(AssetAbilityControlFieldID, data["id"])
      out.attachments = Dataforged::from_json_data(AssetExtensionForeignAttachments, data["attachments"])
      out.controls = Dataforged::from_json_data(Hash[String, AssetExtensionForeignControl], data["controls"])
      out.count_as_impact = Dataforged::from_json_data(TrueClass, data["count_as_impact"])
      out
    end

    def to_json_data
      data = {}
      data["extends"] = Dataforged::to_json_data(extends)
      data["id"] = Dataforged::to_json_data(id)
      data["attachments"] = Dataforged::to_json_data(attachments) unless attachments.nil?
      data["controls"] = Dataforged::to_json_data(controls) unless controls.nil?
      data["count_as_impact"] = Dataforged::to_json_data(count_as_impact) unless count_as_impact.nil?
      data
    end
  end

  class AssetID
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  # Asset options are fields that are usually only set once, typically when the
  # player purchases the asset. The most common examples are the "Name" fields
  # on companion assets. A more complex example is the choice of stats on the
  # Devotant asset.
  class AssetOptionField
    attr_accessor :field_type

    def self.from_json_data(data)
      {
        "select_asset_extension" => AssetOptionFieldSelectAssetExtension,
        "select_number" => AssetOptionFieldSelectNumber,
        "select_stat" => AssetOptionFieldSelectStat,
        "text" => AssetOptionFieldText,
      }[data["field_type"]].from_json_data(data)
    end
  end

  class AssetOptionFieldSelectAssetExtensionChoice
    attr_accessor :label
    attr_accessor :value
    attr_accessor :selected

    def self.from_json_data(data)
      out = AssetOptionFieldSelectAssetExtensionChoice.new
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.value = Dataforged::from_json_data(AssetExtension, data["value"])
      out.selected = Dataforged::from_json_data(TrueClass, data["selected"])
      out
    end

    def to_json_data
      data = {}
      data["label"] = Dataforged::to_json_data(label)
      data["value"] = Dataforged::to_json_data(value)
      data["selected"] = Dataforged::to_json_data(selected) unless selected.nil?
      data
    end
  end

  class AssetOptionFieldSelectAssetExtension < AssetOptionField
    attr_accessor :choices
    attr_accessor :id
    attr_accessor :label
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetOptionFieldSelectAssetExtension.new
      out.field_type = "select_asset_extension"
      out.choices = Dataforged::from_json_data(Hash[String, AssetOptionFieldSelectAssetExtensionChoice], data["choices"])
      out.id = Dataforged::from_json_data(AssetAbilityControlFieldID, data["id"])
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.value = Dataforged::from_json_data(AssetExtension, data["value"])
      out
    end

    def to_json_data
      data = { "field_type" => "select_asset_extension" }
      data["choices"] = Dataforged::to_json_data(choices)
      data["id"] = Dataforged::to_json_data(id)
      data["label"] = Dataforged::to_json_data(label)
      data["value"] = Dataforged::to_json_data(value) unless value.nil?
      data
    end
  end

  class AssetOptionFieldSelectNumberChoice
    attr_accessor :label
    attr_accessor :value
    attr_accessor :selected

    def self.from_json_data(data)
      out = AssetOptionFieldSelectNumberChoice.new
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.value = Dataforged::from_json_data(Integer, data["value"])
      out.selected = Dataforged::from_json_data(TrueClass, data["selected"])
      out
    end

    def to_json_data
      data = {}
      data["label"] = Dataforged::to_json_data(label)
      data["value"] = Dataforged::to_json_data(value)
      data["selected"] = Dataforged::to_json_data(selected) unless selected.nil?
      data
    end
  end

  class AssetOptionFieldSelectNumber < AssetOptionField
    attr_accessor :choices
    attr_accessor :id
    attr_accessor :label
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetOptionFieldSelectNumber.new
      out.field_type = "select_number"
      out.choices = Dataforged::from_json_data(Hash[String, AssetOptionFieldSelectNumberChoice], data["choices"])
      out.id = Dataforged::from_json_data(AssetAbilityOptionFieldID, data["id"])
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.value = Dataforged::from_json_data(Integer, data["value"])
      out
    end

    def to_json_data
      data = { "field_type" => "select_number" }
      data["choices"] = Dataforged::to_json_data(choices)
      data["id"] = Dataforged::to_json_data(id)
      data["label"] = Dataforged::to_json_data(label)
      data["value"] = Dataforged::to_json_data(value) unless value.nil?
      data
    end
  end

  class AssetOptionFieldSelectStatChoice
    attr_accessor :label
    attr_accessor :value
    attr_accessor :selected

    def self.from_json_data(data)
      out = AssetOptionFieldSelectStatChoice.new
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.value = Dataforged::from_json_data(PlayerStat, data["value"])
      out.selected = Dataforged::from_json_data(TrueClass, data["selected"])
      out
    end

    def to_json_data
      data = {}
      data["label"] = Dataforged::to_json_data(label)
      data["value"] = Dataforged::to_json_data(value)
      data["selected"] = Dataforged::to_json_data(selected) unless selected.nil?
      data
    end
  end

  class AssetOptionFieldSelectStat < AssetOptionField
    attr_accessor :choices
    attr_accessor :id
    attr_accessor :label
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetOptionFieldSelectStat.new
      out.field_type = "select_stat"
      out.choices = Dataforged::from_json_data(Hash[String, AssetOptionFieldSelectStatChoice], data["choices"])
      out.id = Dataforged::from_json_data(AssetAbilityOptionFieldID, data["id"])
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.value = Dataforged::from_json_data(PlayerStat, data["value"])
      out
    end

    def to_json_data
      data = { "field_type" => "select_stat" }
      data["choices"] = Dataforged::to_json_data(choices)
      data["id"] = Dataforged::to_json_data(id)
      data["label"] = Dataforged::to_json_data(label)
      data["value"] = Dataforged::to_json_data(value) unless value.nil?
      data
    end
  end

  class AssetOptionFieldText < AssetOptionField
    attr_accessor :id
    attr_accessor :label
    attr_accessor :value

    def self.from_json_data(data)
      out = AssetOptionFieldText.new
      out.field_type = "text"
      out.id = Dataforged::from_json_data(AssetAbilityOptionFieldID, data["id"])
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.value = Dataforged::from_json_data(String, data["value"])
      out
    end

    def to_json_data
      data = { "field_type" => "text" }
      data["id"] = Dataforged::to_json_data(id)
      data["label"] = Dataforged::to_json_data(label)
      data["value"] = Dataforged::to_json_data(value) unless value.nil?
      data
    end
  end

  # Challenge rank represented as a number from 1 (troublesome) to 5 (epic)
  class ChallengeRank
    attr_accessor :value

    def self.from_json_data(data)
      out = ChallengeRank.new
      out.value = Dataforged.from_json_data(Integer, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  # A valid CSS color.
  class Color
    attr_accessor :value

    def self.from_json_data(data)
      out = Color.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class DelveSiteDenizenFrequency
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    COMMON = new("common")
    RARE = new("rare")
    UNCOMMON = new("uncommon")
    UNFORESEEN = new("unforeseen")
    VERY_COMMON = new("very_common")

    def self.from_json_data(data)
      {
        "common" => COMMON,
        "rare" => RARE,
        "uncommon" => UNCOMMON,
        "unforeseen" => UNFORESEEN,
        "very_common" => VERY_COMMON,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class DelveSiteDenizen
    attr_accessor :frequency
    attr_accessor :high
    attr_accessor :low
    attr_accessor :encounter
    attr_accessor :name

    def self.from_json_data(data)
      out = DelveSiteDenizen.new
      out.frequency = Dataforged::from_json_data(DelveSiteDenizenFrequency, data["frequency"])
      out.high = Dataforged::from_json_data(Integer, data["high"])
      out.low = Dataforged::from_json_data(Integer, data["low"])
      out.encounter = Dataforged::from_json_data(ID, data["encounter"])
      out.name = Dataforged::from_json_data(Label, data["name"])
      out
    end

    def to_json_data
      data = {}
      data["frequency"] = Dataforged::to_json_data(frequency)
      data["high"] = Dataforged::to_json_data(high)
      data["low"] = Dataforged::to_json_data(low)
      data["encounter"] = Dataforged::to_json_data(encounter) unless encounter.nil?
      data["name"] = Dataforged::to_json_data(name) unless name.nil?
      data
    end
  end

  class DelveSiteDomainCardType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    DOMAIN = new("domain")

    def self.from_json_data(data)
      {
        "domain" => DOMAIN,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class DelveSiteDomain
    attr_accessor :card_type
    attr_accessor :dangers
    attr_accessor :features
    attr_accessor :id
    attr_accessor :name
    attr_accessor :source
    attr_accessor :summary
    attr_accessor :description
    attr_accessor :icon
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = DelveSiteDomain.new
      out.card_type = Dataforged::from_json_data(DelveSiteDomainCardType, data["card_type"])
      out.dangers = Dataforged::from_json_data(Array[FeatureOrDanger], data["dangers"])
      out.features = Dataforged::from_json_data(Array[FeatureOrDanger], data["features"])
      out.id = Dataforged::from_json_data(DelveSiteDomainID, data["id"])
      out.name = Dataforged::from_json_data(Label, data["name"])
      out.source = Dataforged::from_json_data(Source, data["source"])
      out.summary = Dataforged::from_json_data(MarkdownString, data["summary"])
      out.description = Dataforged::from_json_data(MarkdownString, data["description"])
      out.icon = Dataforged::from_json_data(SvgImageURL, data["icon"])
      out.suggestions = Dataforged::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["card_type"] = Dataforged::to_json_data(card_type)
      data["dangers"] = Dataforged::to_json_data(dangers)
      data["features"] = Dataforged::to_json_data(features)
      data["id"] = Dataforged::to_json_data(id)
      data["name"] = Dataforged::to_json_data(name)
      data["source"] = Dataforged::to_json_data(source)
      data["summary"] = Dataforged::to_json_data(summary)
      data["description"] = Dataforged::to_json_data(description) unless description.nil?
      data["icon"] = Dataforged::to_json_data(icon) unless icon.nil?
      data["suggestions"] = Dataforged::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  class DelveSiteDomainID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteDomainID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class DelveSiteThemeCardType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    THEME = new("theme")

    def self.from_json_data(data)
      {
        "theme" => THEME,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class DelveSiteTheme
    attr_accessor :card_type
    attr_accessor :dangers
    attr_accessor :features
    attr_accessor :id
    attr_accessor :name
    attr_accessor :source
    attr_accessor :summary
    attr_accessor :description
    attr_accessor :icon
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = DelveSiteTheme.new
      out.card_type = Dataforged::from_json_data(DelveSiteThemeCardType, data["card_type"])
      out.dangers = Dataforged::from_json_data(Array[FeatureOrDanger], data["dangers"])
      out.features = Dataforged::from_json_data(Array[FeatureOrDanger], data["features"])
      out.id = Dataforged::from_json_data(DelveSiteThemeID, data["id"])
      out.name = Dataforged::from_json_data(Label, data["name"])
      out.source = Dataforged::from_json_data(Source, data["source"])
      out.summary = Dataforged::from_json_data(MarkdownString, data["summary"])
      out.description = Dataforged::from_json_data(MarkdownString, data["description"])
      out.icon = Dataforged::from_json_data(SvgImageURL, data["icon"])
      out.suggestions = Dataforged::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["card_type"] = Dataforged::to_json_data(card_type)
      data["dangers"] = Dataforged::to_json_data(dangers)
      data["features"] = Dataforged::to_json_data(features)
      data["id"] = Dataforged::to_json_data(id)
      data["name"] = Dataforged::to_json_data(name)
      data["source"] = Dataforged::to_json_data(source)
      data["summary"] = Dataforged::to_json_data(summary)
      data["description"] = Dataforged::to_json_data(description) unless description.nil?
      data["icon"] = Dataforged::to_json_data(icon) unless icon.nil?
      data["suggestions"] = Dataforged::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  class DelveSiteThemeID
    attr_accessor :value

    def self.from_json_data(data)
      out = DelveSiteThemeID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class EncounterNatureClassic
    attr_accessor :value

    def self.from_json_data(data)
      out = EncounterNatureClassic.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class EncounterNatureStarforged
    attr_accessor :value

    def self.from_json_data(data)
      out = EncounterNatureStarforged.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class EncounterStarforged
    attr_accessor :description
    attr_accessor :drives
    attr_accessor :features
    attr_accessor :id
    attr_accessor :name
    attr_accessor :nature
    attr_accessor :quest_starter
    attr_accessor :rank
    attr_accessor :source
    attr_accessor :summary
    attr_accessor :tactics
    attr_accessor :suggestions
    attr_accessor :variants

    def self.from_json_data(data)
      out = EncounterStarforged.new
      out.description = Dataforged::from_json_data(MarkdownString, data["description"])
      out.drives = Dataforged::from_json_data(Array[MarkdownString], data["drives"])
      out.features = Dataforged::from_json_data(Array[MarkdownString], data["features"])
      out.id = Dataforged::from_json_data(ID, data["id"])
      out.name = Dataforged::from_json_data(Label, data["name"])
      out.nature = Dataforged::from_json_data(EncounterNatureStarforged, data["nature"])
      out.quest_starter = Dataforged::from_json_data(MarkdownString, data["quest_starter"])
      out.rank = Dataforged::from_json_data(ChallengeRank, data["rank"])
      out.source = Dataforged::from_json_data(Source, data["source"])
      out.summary = Dataforged::from_json_data(MarkdownString, data["summary"])
      out.tactics = Dataforged::from_json_data(Array[MarkdownString], data["tactics"])
      out.suggestions = Dataforged::from_json_data(Suggestions, data["suggestions"])
      out.variants = Dataforged::from_json_data(Hash[String, EncounterVariantStarforged], data["variants"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Dataforged::to_json_data(description)
      data["drives"] = Dataforged::to_json_data(drives)
      data["features"] = Dataforged::to_json_data(features)
      data["id"] = Dataforged::to_json_data(id)
      data["name"] = Dataforged::to_json_data(name)
      data["nature"] = Dataforged::to_json_data(nature)
      data["quest_starter"] = Dataforged::to_json_data(quest_starter)
      data["rank"] = Dataforged::to_json_data(rank)
      data["source"] = Dataforged::to_json_data(source)
      data["summary"] = Dataforged::to_json_data(summary)
      data["tactics"] = Dataforged::to_json_data(tactics)
      data["suggestions"] = Dataforged::to_json_data(suggestions) unless suggestions.nil?
      data["variants"] = Dataforged::to_json_data(variants) unless variants.nil?
      data
    end
  end

  class EncounterVariantStarforged
    attr_accessor :description
    attr_accessor :id
    attr_accessor :name
    attr_accessor :nature
    attr_accessor :rank

    def self.from_json_data(data)
      out = EncounterVariantStarforged.new
      out.description = Dataforged::from_json_data(MarkdownString, data["description"])
      out.id = Dataforged::from_json_data(ID, data["id"])
      out.name = Dataforged::from_json_data(Label, data["name"])
      out.nature = Dataforged::from_json_data(EncounterNatureStarforged, data["nature"])
      out.rank = Dataforged::from_json_data(ChallengeRank, data["rank"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Dataforged::to_json_data(description)
      data["id"] = Dataforged::to_json_data(id)
      data["name"] = Dataforged::to_json_data(name)
      data["nature"] = Dataforged::to_json_data(nature)
      data["rank"] = Dataforged::to_json_data(rank)
      data
    end
  end

  class FeatureOrDanger
    attr_accessor :high
    attr_accessor :id
    attr_accessor :low
    attr_accessor :result
    attr_accessor :description
    attr_accessor :embed_table
    attr_accessor :icon
    attr_accessor :rolls
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :template

    def self.from_json_data(data)
      out = FeatureOrDanger.new
      out.high = Dataforged::from_json_data(Integer, data["high"])
      out.id = Dataforged::from_json_data(ID, data["id"])
      out.low = Dataforged::from_json_data(Integer, data["low"])
      out.result = Dataforged::from_json_data(MarkdownString, data["result"])
      out.description = Dataforged::from_json_data(MarkdownString, data["description"])
      out.embed_table = Dataforged::from_json_data(ID, data["embed_table"])
      out.icon = Dataforged::from_json_data(SvgImageURL, data["icon"])
      out.rolls = Dataforged::from_json_data(Array[OracleTableRoll], data["rolls"])
      out.suggestions = Dataforged::from_json_data(Suggestions, data["suggestions"])
      out.summary = Dataforged::from_json_data(MarkdownString, data["summary"])
      out.template = Dataforged::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["high"] = Dataforged::to_json_data(high)
      data["id"] = Dataforged::to_json_data(id)
      data["low"] = Dataforged::to_json_data(low)
      data["result"] = Dataforged::to_json_data(result)
      data["description"] = Dataforged::to_json_data(description) unless description.nil?
      data["embed_table"] = Dataforged::to_json_data(embed_table) unless embed_table.nil?
      data["icon"] = Dataforged::to_json_data(icon) unless icon.nil?
      data["rolls"] = Dataforged::to_json_data(rolls) unless rolls.nil?
      data["suggestions"] = Dataforged::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Dataforged::to_json_data(summary) unless summary.nil?
      data["template"] = Dataforged::to_json_data(template) unless template.nil?
      data
    end
  end

  class ID
    attr_accessor :value

    def self.from_json_data(data)
      out = ID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  # A user-facing text label or name.
  class Label
    attr_accessor :value

    def self.from_json_data(data)
      out = Label.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  # A rich text string in Markdown. Usually this is a direct excerpt from the
  # rules text.
  # 
  #       The custom syntax `{{table:some_oracle_table_id}}` represents a
  # markdown table rendered from oracle data.
  class MarkdownString
    attr_accessor :value

    def self.from_json_data(data)
      out = MarkdownString.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class Move
    attr_accessor :id
    attr_accessor :name
    attr_accessor :outcomes
    attr_accessor :source
    attr_accessor :text
    attr_accessor :trigger
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = Move.new
      out.id = Dataforged::from_json_data(MoveID, data["id"])
      out.name = Dataforged::from_json_data(Label, data["name"])
      out.outcomes = Dataforged::from_json_data(MoveOutcomes, data["outcomes"])
      out.source = Dataforged::from_json_data(Source, data["source"])
      out.text = Dataforged::from_json_data(MarkdownString, data["text"])
      out.trigger = Dataforged::from_json_data(Trigger, data["trigger"])
      out.suggestions = Dataforged::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["id"] = Dataforged::to_json_data(id)
      data["name"] = Dataforged::to_json_data(name)
      data["outcomes"] = Dataforged::to_json_data(outcomes)
      data["source"] = Dataforged::to_json_data(source)
      data["text"] = Dataforged::to_json_data(text)
      data["trigger"] = Dataforged::to_json_data(trigger)
      data["suggestions"] = Dataforged::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  class MoveCategory
    attr_accessor :canonical_name
    attr_accessor :color
    attr_accessor :contents
    attr_accessor :id
    attr_accessor :name
    attr_accessor :source
    attr_accessor :summary
    attr_accessor :description
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = MoveCategory.new
      out.canonical_name = Dataforged::from_json_data(Label, data["canonical_name"])
      out.color = Dataforged::from_json_data(Color, data["color"])
      out.contents = Dataforged::from_json_data(Hash[String, Move], data["contents"])
      out.id = Dataforged::from_json_data(MoveCategoryID, data["id"])
      out.name = Dataforged::from_json_data(Label, data["name"])
      out.source = Dataforged::from_json_data(Source, data["source"])
      out.summary = Dataforged::from_json_data(MarkdownString, data["summary"])
      out.description = Dataforged::from_json_data(MarkdownString, data["description"])
      out.suggestions = Dataforged::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["canonical_name"] = Dataforged::to_json_data(canonical_name)
      data["color"] = Dataforged::to_json_data(color)
      data["contents"] = Dataforged::to_json_data(contents)
      data["id"] = Dataforged::to_json_data(id)
      data["name"] = Dataforged::to_json_data(name)
      data["source"] = Dataforged::to_json_data(source)
      data["summary"] = Dataforged::to_json_data(summary)
      data["description"] = Dataforged::to_json_data(description) unless description.nil?
      data["suggestions"] = Dataforged::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  class MoveCategoryID
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveCategoryID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class MoveExtension
    attr_accessor :extends
    attr_accessor :trigger
    attr_accessor :outcomes
    attr_accessor :text

    def self.from_json_data(data)
      out = MoveExtension.new
      out.extends = Dataforged::from_json_data(Array[MoveID], data["extends"])
      out.trigger = Dataforged::from_json_data(TriggerExtension, data["trigger"])
      out.outcomes = Dataforged::from_json_data(MoveOutcomesExtension, data["outcomes"])
      out.text = Dataforged::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["extends"] = Dataforged::to_json_data(extends)
      data["trigger"] = Dataforged::to_json_data(trigger)
      data["outcomes"] = Dataforged::to_json_data(outcomes) unless outcomes.nil?
      data["text"] = Dataforged::to_json_data(text) unless text.nil?
      data
    end
  end

  class MoveID
    attr_accessor :value

    def self.from_json_data(data)
      out = MoveID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class MoveOutcome
    attr_accessor :text
    attr_accessor :count_as
    attr_accessor :reroll

    def self.from_json_data(data)
      out = MoveOutcome.new
      out.text = Dataforged::from_json_data(MarkdownString, data["text"])
      out.count_as = Dataforged::from_json_data(MoveOutcomeType, data["count_as"])
      out.reroll = Dataforged::from_json_data(MoveReroll, data["reroll"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Dataforged::to_json_data(text)
      data["count_as"] = Dataforged::to_json_data(count_as) unless count_as.nil?
      data["reroll"] = Dataforged::to_json_data(reroll) unless reroll.nil?
      data
    end
  end

  class MoveOutcomeExtensionReroll
    attr_accessor :method
    attr_accessor :text

    def self.from_json_data(data)
      out = MoveOutcomeExtensionReroll.new
      out.method = Dataforged::from_json_data(MoveRerollMethod, data["method"])
      out.text = Dataforged::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Dataforged::to_json_data(method) unless method.nil?
      data["text"] = Dataforged::to_json_data(text) unless text.nil?
      data
    end
  end

  # Extends or upgrades an outcome from an existing move.
  class MoveOutcomeExtension
    attr_accessor :count_as
    attr_accessor :reroll
    attr_accessor :text

    def self.from_json_data(data)
      out = MoveOutcomeExtension.new
      out.count_as = Dataforged::from_json_data(MoveOutcomeType, data["count_as"])
      out.reroll = Dataforged::from_json_data(MoveOutcomeExtensionReroll, data["reroll"])
      out.text = Dataforged::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["count_as"] = Dataforged::to_json_data(count_as) unless count_as.nil?
      data["reroll"] = Dataforged::to_json_data(reroll) unless reroll.nil?
      data["text"] = Dataforged::to_json_data(text) unless text.nil?
      data
    end
  end

  class MoveOutcomeMatchable
    attr_accessor :text
    attr_accessor :count_as
    attr_accessor :match
    attr_accessor :reroll

    def self.from_json_data(data)
      out = MoveOutcomeMatchable.new
      out.text = Dataforged::from_json_data(MarkdownString, data["text"])
      out.count_as = Dataforged::from_json_data(MoveOutcomeType, data["count_as"])
      out.match = Dataforged::from_json_data(MoveOutcome, data["match"])
      out.reroll = Dataforged::from_json_data(MoveReroll, data["reroll"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Dataforged::to_json_data(text)
      data["count_as"] = Dataforged::to_json_data(count_as) unless count_as.nil?
      data["match"] = Dataforged::to_json_data(match) unless match.nil?
      data["reroll"] = Dataforged::to_json_data(reroll) unless reroll.nil?
      data
    end
  end

  class MoveOutcomeMatchableExtensionReroll
    attr_accessor :method
    attr_accessor :text

    def self.from_json_data(data)
      out = MoveOutcomeMatchableExtensionReroll.new
      out.method = Dataforged::from_json_data(MoveRerollMethod, data["method"])
      out.text = Dataforged::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Dataforged::to_json_data(method) unless method.nil?
      data["text"] = Dataforged::to_json_data(text) unless text.nil?
      data
    end
  end

  # Extends or upgrades an outcome from an existing move.
  class MoveOutcomeMatchableExtension
    attr_accessor :count_as
    attr_accessor :match
    attr_accessor :reroll
    attr_accessor :text

    def self.from_json_data(data)
      out = MoveOutcomeMatchableExtension.new
      out.count_as = Dataforged::from_json_data(MoveOutcomeType, data["count_as"])
      out.match = Dataforged::from_json_data(MoveOutcomeExtension, data["match"])
      out.reroll = Dataforged::from_json_data(MoveOutcomeMatchableExtensionReroll, data["reroll"])
      out.text = Dataforged::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["count_as"] = Dataforged::to_json_data(count_as) unless count_as.nil?
      data["match"] = Dataforged::to_json_data(match) unless match.nil?
      data["reroll"] = Dataforged::to_json_data(reroll) unless reroll.nil?
      data["text"] = Dataforged::to_json_data(text) unless text.nil?
      data
    end
  end

  class MoveOutcomeType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # The player's score doesn't beat any challenge dice.
    MISS = new("miss")

    # The player's score beats both of the challenge dice.
    STRONG_HIT = new("strong_hit")

    # The player's score beats one of the challenge dice.
    WEAK_HIT = new("weak_hit")

    def self.from_json_data(data)
      {
        "miss" => MISS,
        "strong_hit" => STRONG_HIT,
        "weak_hit" => WEAK_HIT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class MoveOutcomes
    attr_accessor :miss
    attr_accessor :strong_hit
    attr_accessor :weak_hit

    def self.from_json_data(data)
      out = MoveOutcomes.new
      out.miss = Dataforged::from_json_data(MoveOutcomeMatchable, data["miss"])
      out.strong_hit = Dataforged::from_json_data(MoveOutcomeMatchable, data["strong_hit"])
      out.weak_hit = Dataforged::from_json_data(MoveOutcome, data["weak_hit"])
      out
    end

    def to_json_data
      data = {}
      data["miss"] = Dataforged::to_json_data(miss)
      data["strong_hit"] = Dataforged::to_json_data(strong_hit)
      data["weak_hit"] = Dataforged::to_json_data(weak_hit)
      data
    end
  end

  # Extends or upgrades one or more outcomes of an existing move.
  class MoveOutcomesExtension
    attr_accessor :miss
    attr_accessor :strong_hit
    attr_accessor :weak_hit

    def self.from_json_data(data)
      out = MoveOutcomesExtension.new
      out.miss = Dataforged::from_json_data(MoveOutcomeMatchableExtension, data["miss"])
      out.strong_hit = Dataforged::from_json_data(MoveOutcomeMatchableExtension, data["strong_hit"])
      out.weak_hit = Dataforged::from_json_data(MoveOutcomeExtension, data["weak_hit"])
      out
    end

    def to_json_data
      data = {}
      data["miss"] = Dataforged::to_json_data(miss) unless miss.nil?
      data["strong_hit"] = Dataforged::to_json_data(strong_hit) unless strong_hit.nil?
      data["weak_hit"] = Dataforged::to_json_data(weak_hit) unless weak_hit.nil?
      data
    end
  end

  class MoveReroll
    attr_accessor :method

    # Describes the trigger condition for the reroll, if any.
    attr_accessor :text

    def self.from_json_data(data)
      out = MoveReroll.new
      out.method = Dataforged::from_json_data(MoveRerollMethod, data["method"])
      out.text = Dataforged::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Dataforged::to_json_data(method)
      data["text"] = Dataforged::to_json_data(text) unless text.nil?
      data
    end
  end

  class MoveRerollMethod
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # Reroll the action die
    ACTION_DIE = new("action_die")

    # Reroll all dice
    ALL = new("all")

    # Reroll any number of dice
    ANY = new("any")

    # Reroll any number of challenge dice
    CHALLENGE_DICE = new("challenge_dice")

    # Reroll one of the challenge dice
    CHALLENGE_DIE = new("challenge_die")

    def self.from_json_data(data)
      {
        "action_die" => ACTION_DIE,
        "all" => ALL,
        "any" => ANY,
        "challenge_dice" => CHALLENGE_DICE,
        "challenge_die" => CHALLENGE_DIE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class MoveRollMethod
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # When rolling with this move trigger option, *every* stat or progress track
    # of the `using` key is rolled
    ALL = new("all")

    # When rolling with this move trigger option, the player picks which stat
    # to use.
    ANY = new("any")

    # When rolling with this move trigger option, use the highest/best option
    # from the `using` key.
    HIGHEST = new("highest")

    # When rolling with this move trigger option, use the lowest/worst option
    # from the `using` key.
    LOWEST = new("lowest")

    # Take an automatic miss instead of rolling.
    MISS = new("miss")

    # Take an automatic strong hit instead of rolling.
    STRONG_HIT = new("strong_hit")

    # Take an automatic weak hit instead of rolling.
    WEAK_HIT = new("weak_hit")

    def self.from_json_data(data)
      {
        "all" => ALL,
        "any" => ANY,
        "highest" => HIGHEST,
        "lowest" => LOWEST,
        "miss" => MISS,
        "strong_hit" => STRONG_HIT,
        "weak_hit" => WEAK_HIT,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleCollection
    attr_accessor :canonical_name
    attr_accessor :contents
    attr_accessor :id
    attr_accessor :name
    attr_accessor :source
    attr_accessor :summary
    attr_accessor :collections
    attr_accessor :color
    attr_accessor :description
    attr_accessor :rendering
    attr_accessor :sample_names
    attr_accessor :suggestions
    attr_accessor :template

    def self.from_json_data(data)
      out = OracleCollection.new
      out.canonical_name = Dataforged::from_json_data(Label, data["canonical_name"])
      out.contents = Dataforged::from_json_data(Hash[String, OracleTable], data["contents"])
      out.id = Dataforged::from_json_data(OracleCollectionID, data["id"])
      out.name = Dataforged::from_json_data(Label, data["name"])
      out.source = Dataforged::from_json_data(Source, data["source"])
      out.summary = Dataforged::from_json_data(MarkdownString, data["summary"])
      out.collections = Dataforged::from_json_data(Hash[String, OracleCollection], data["collections"])
      out.color = Dataforged::from_json_data(Color, data["color"])
      out.description = Dataforged::from_json_data(MarkdownString, data["description"])
      out.rendering = Dataforged::from_json_data(OracleCollectionRendering, data["rendering"])
      out.sample_names = Dataforged::from_json_data(Array[Label], data["sample_names"])
      out.suggestions = Dataforged::from_json_data(Suggestions, data["suggestions"])
      out.template = Dataforged::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["canonical_name"] = Dataforged::to_json_data(canonical_name)
      data["contents"] = Dataforged::to_json_data(contents)
      data["id"] = Dataforged::to_json_data(id)
      data["name"] = Dataforged::to_json_data(name)
      data["source"] = Dataforged::to_json_data(source)
      data["summary"] = Dataforged::to_json_data(summary)
      data["collections"] = Dataforged::to_json_data(collections) unless collections.nil?
      data["color"] = Dataforged::to_json_data(color) unless color.nil?
      data["description"] = Dataforged::to_json_data(description) unless description.nil?
      data["rendering"] = Dataforged::to_json_data(rendering) unless rendering.nil?
      data["sample_names"] = Dataforged::to_json_data(sample_names) unless sample_names.nil?
      data["suggestions"] = Dataforged::to_json_data(suggestions) unless suggestions.nil?
      data["template"] = Dataforged::to_json_data(template) unless template.nil?
      data
    end
  end

  class OracleCollectionColumn
    attr_accessor :content_type
    attr_accessor :table_key
    attr_accessor :color
    attr_accessor :label

    def self.from_json_data(data)
      out = OracleCollectionColumn.new
      out.content_type = Dataforged::from_json_data(OracleColumnContentType, data["content_type"])
      out.table_key = Dataforged::from_json_data(String, data["table_key"])
      out.color = Dataforged::from_json_data(Color, data["color"])
      out.label = Dataforged::from_json_data(Label, data["label"])
      out
    end

    def to_json_data
      data = {}
      data["content_type"] = Dataforged::to_json_data(content_type)
      data["table_key"] = Dataforged::to_json_data(table_key)
      data["color"] = Dataforged::to_json_data(color) unless color.nil?
      data["label"] = Dataforged::to_json_data(label) unless label.nil?
      data
    end
  end

  class OracleCollectionID
    attr_accessor :value

    def self.from_json_data(data)
      out = OracleCollectionID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class OracleCollectionRendering
    attr_accessor :columns
    attr_accessor :color
    attr_accessor :style

    def self.from_json_data(data)
      out = OracleCollectionRendering.new
      out.columns = Dataforged::from_json_data(Hash[String, OracleCollectionColumn], data["columns"])
      out.color = Dataforged::from_json_data(Color, data["color"])
      out.style = Dataforged::from_json_data(OracleCollectionStyle, data["style"])
      out
    end

    def to_json_data
      data = {}
      data["columns"] = Dataforged::to_json_data(columns)
      data["color"] = Dataforged::to_json_data(color) unless color.nil?
      data["style"] = Dataforged::to_json_data(style) unless style.nil?
      data
    end
  end

  class OracleCollectionStyle
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    MULTI_TABLE = new("multi_table")

    def self.from_json_data(data)
      {
        "multi_table" => MULTI_TABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleColumnContentType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    DESCRIPTION = new("description")
    RANGE = new("range")
    RESULT = new("result")
    SUMMARY = new("summary")

    def self.from_json_data(data)
      {
        "description" => DESCRIPTION,
        "range" => RANGE,
        "result" => RESULT,
        "summary" => SUMMARY,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleRollTemplate
    attr_accessor :description
    attr_accessor :result
    attr_accessor :summary

    def self.from_json_data(data)
      out = OracleRollTemplate.new
      out.description = Dataforged::from_json_data(TemplateString, data["description"])
      out.result = Dataforged::from_json_data(TemplateString, data["result"])
      out.summary = Dataforged::from_json_data(TemplateString, data["summary"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Dataforged::to_json_data(description) unless description.nil?
      data["result"] = Dataforged::to_json_data(result) unless result.nil?
      data["summary"] = Dataforged::to_json_data(summary) unless summary.nil?
      data
    end
  end

  class OracleTable
    attr_accessor :canonical_name
    attr_accessor :id
    attr_accessor :name
    attr_accessor :source
    attr_accessor :table
    attr_accessor :description
    attr_accessor :match
    attr_accessor :rendering
    attr_accessor :suggestions
    attr_accessor :summary

    def self.from_json_data(data)
      out = OracleTable.new
      out.canonical_name = Dataforged::from_json_data(Label, data["canonical_name"])
      out.id = Dataforged::from_json_data(OracleTableID, data["id"])
      out.name = Dataforged::from_json_data(Label, data["name"])
      out.source = Dataforged::from_json_data(Source, data["source"])
      out.table = Dataforged::from_json_data(Array[OracleTableRow], data["table"])
      out.description = Dataforged::from_json_data(MarkdownString, data["description"])
      out.match = Dataforged::from_json_data(OracleTableMatchBehavior, data["match"])
      out.rendering = Dataforged::from_json_data(OracleTableRendering, data["rendering"])
      out.suggestions = Dataforged::from_json_data(Suggestions, data["suggestions"])
      out.summary = Dataforged::from_json_data(MarkdownString, data["summary"])
      out
    end

    def to_json_data
      data = {}
      data["canonical_name"] = Dataforged::to_json_data(canonical_name)
      data["id"] = Dataforged::to_json_data(id)
      data["name"] = Dataforged::to_json_data(name)
      data["source"] = Dataforged::to_json_data(source)
      data["table"] = Dataforged::to_json_data(table)
      data["description"] = Dataforged::to_json_data(description) unless description.nil?
      data["match"] = Dataforged::to_json_data(match) unless match.nil?
      data["rendering"] = Dataforged::to_json_data(rendering) unless rendering.nil?
      data["suggestions"] = Dataforged::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Dataforged::to_json_data(summary) unless summary.nil?
      data
    end
  end

  class OracleTableColumn
    attr_accessor :content_type
    attr_accessor :label

    def self.from_json_data(data)
      out = OracleTableColumn.new
      out.content_type = Dataforged::from_json_data(OracleColumnContentType, data["content_type"])
      out.label = Dataforged::from_json_data(Label, data["label"])
      out
    end

    def to_json_data
      data = {}
      data["content_type"] = Dataforged::to_json_data(content_type)
      data["label"] = Dataforged::to_json_data(label) unless label.nil?
      data
    end
  end

  class OracleTableID
    attr_accessor :value

    def self.from_json_data(data)
      out = OracleTableID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class OracleTableMatchBehavior
    attr_accessor :text

    def self.from_json_data(data)
      out = OracleTableMatchBehavior.new
      out.text = Dataforged::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["text"] = Dataforged::to_json_data(text)
      data
    end
  end

  class OracleTableRendering
    attr_accessor :color
    attr_accessor :columns
    attr_accessor :icon
    attr_accessor :style

    def self.from_json_data(data)
      out = OracleTableRendering.new
      out.color = Dataforged::from_json_data(Color, data["color"])
      out.columns = Dataforged::from_json_data(Hash[String, OracleTableColumn], data["columns"])
      out.icon = Dataforged::from_json_data(SvgImageURL, data["icon"])
      out.style = Dataforged::from_json_data(OracleTableStyle, data["style"])
      out
    end

    def to_json_data
      data = {}
      data["color"] = Dataforged::to_json_data(color) unless color.nil?
      data["columns"] = Dataforged::to_json_data(columns) unless columns.nil?
      data["icon"] = Dataforged::to_json_data(icon) unless icon.nil?
      data["style"] = Dataforged::to_json_data(style) unless style.nil?
      data
    end
  end

  class OracleTableRoll
    attr_accessor :oracle
    attr_accessor :method
    attr_accessor :times

    def self.from_json_data(data)
      out = OracleTableRoll.new
      out.oracle = Dataforged::from_json_data(OracleTableID, data["oracle"])
      out.method = Dataforged::from_json_data(OracleTableRollMethod, data["method"])
      out.times = Dataforged::from_json_data(Integer, data["times"])
      out
    end

    def to_json_data
      data = {}
      data["oracle"] = Dataforged::to_json_data(oracle)
      data["method"] = Dataforged::to_json_data(method) unless method.nil?
      data["times"] = Dataforged::to_json_data(times) unless times.nil?
      data
    end
  end

  class OracleTableRollMethod
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    KEEP_DUPLICATES = new("keep_duplicates")
    MAKE_IT_WORSE = new("make_it_worse")
    NO_DUPLICATES = new("no_duplicates")

    def self.from_json_data(data)
      {
        "keep_duplicates" => KEEP_DUPLICATES,
        "make_it_worse" => MAKE_IT_WORSE,
        "no_duplicates" => NO_DUPLICATES,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class OracleTableRow
    attr_accessor :high
    attr_accessor :id
    attr_accessor :low
    attr_accessor :result
    attr_accessor :description
    attr_accessor :embed_table
    attr_accessor :icon
    attr_accessor :rolls
    attr_accessor :suggestions
    attr_accessor :summary
    attr_accessor :template

    def self.from_json_data(data)
      out = OracleTableRow.new
      out.high = Dataforged::from_json_data(Integer, data["high"])
      out.id = Dataforged::from_json_data(OracleTableRowID, data["id"])
      out.low = Dataforged::from_json_data(Integer, data["low"])
      out.result = Dataforged::from_json_data(MarkdownString, data["result"])
      out.description = Dataforged::from_json_data(MarkdownString, data["description"])
      out.embed_table = Dataforged::from_json_data(OracleTableID, data["embed_table"])
      out.icon = Dataforged::from_json_data(SvgImageURL, data["icon"])
      out.rolls = Dataforged::from_json_data(Array[OracleTableRoll], data["rolls"])
      out.suggestions = Dataforged::from_json_data(Suggestions, data["suggestions"])
      out.summary = Dataforged::from_json_data(MarkdownString, data["summary"])
      out.template = Dataforged::from_json_data(OracleRollTemplate, data["template"])
      out
    end

    def to_json_data
      data = {}
      data["high"] = Dataforged::to_json_data(high)
      data["id"] = Dataforged::to_json_data(id)
      data["low"] = Dataforged::to_json_data(low)
      data["result"] = Dataforged::to_json_data(result)
      data["description"] = Dataforged::to_json_data(description) unless description.nil?
      data["embed_table"] = Dataforged::to_json_data(embed_table) unless embed_table.nil?
      data["icon"] = Dataforged::to_json_data(icon) unless icon.nil?
      data["rolls"] = Dataforged::to_json_data(rolls) unless rolls.nil?
      data["suggestions"] = Dataforged::to_json_data(suggestions) unless suggestions.nil?
      data["summary"] = Dataforged::to_json_data(summary) unless summary.nil?
      data["template"] = Dataforged::to_json_data(template) unless template.nil?
      data
    end
  end

  class OracleTableRowID
    attr_accessor :value

    def self.from_json_data(data)
      out = OracleTableRowID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class OracleTableStyle
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    EMBED_AS_COLUMN = new("embed_as_column")
    EMBED_IN_ROW = new("embed_in_row")
    TABLE = new("table")

    def self.from_json_data(data)
      {
        "embed_as_column" => EMBED_AS_COLUMN,
        "embed_in_row" => EMBED_IN_ROW,
        "table" => TABLE,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A standard player stat, or a condition meter that can be used as a stat in
  # an action roll.
  class PlayerAttributeRollable
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    EDGE = new("edge")
    HEALTH = new("health")
    HEART = new("heart")
    IRON = new("iron")
    SHADOW = new("shadow")
    SPIRIT = new("spirit")
    SUPPLY = new("supply")
    WITS = new("wits")

    def self.from_json_data(data)
      {
        "edge" => EDGE,
        "health" => HEALTH,
        "heart" => HEART,
        "iron" => IRON,
        "shadow" => SHADOW,
        "spirit" => SPIRIT,
        "supply" => SUPPLY,
        "wits" => WITS,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A standard player character condition meter.
  class PlayerConditionMeter
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    HEALTH = new("health")
    SPIRIT = new("spirit")
    SUPPLY = new("supply")

    def self.from_json_data(data)
      {
        "health" => HEALTH,
        "spirit" => SPIRIT,
        "supply" => SUPPLY,
      }[data]
    end

    def to_json_data
      value
    end
  end

  # A standard player character stat.
  class PlayerStat
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    EDGE = new("edge")
    HEART = new("heart")
    IRON = new("iron")
    SHADOW = new("shadow")
    WITS = new("wits")

    def self.from_json_data(data)
      {
        "edge" => EDGE,
        "heart" => HEART,
        "iron" => IRON,
        "shadow" => SHADOW,
        "wits" => WITS,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class ProgressType
    attr_accessor :value

    def initialize(value)
      self.value = value
    end

    private_class_method :new

    # A player's Bonds legacy track(Starforged ruleset only)
    BONDS_LEGACY = new("bonds_legacy")

    # A player's bonds progress track (Ironsworn ruleset only)
    BONDS_PROGRESS = new("bonds_progress")

    # A combat progress track, started with Enter the Fray.
    COMBAT_PROGRESS = new("combat_progress")

    # A connection progress track, started with Make a Connection (Starforged
    # ruleset only)
    CONNECTION_PROGRESS = new("connection_progress")

    # A delve site progress track, started with Discover a Site (Ironsworn
    # ruleset only)
    DELVE_PROGRESS = new("delve_progress")

    # A player's Discoveries legacy track(Starforged ruleset only)
    DISCOVERIES_LEGACY = new("discoveries_legacy")

    # An expedition progress track, started with Undertake an Expedition
    # (Starforged ruleset only)
    EXPEDITION_PROGRESS = new("expedition_progress")

    # A journey progress track, started with Undertake a Journey (Ironsworn
    # ruleset only)
    JOURNEY_PROGRESS = new("journey_progress")

    # A player's Quests legacy track (Starforged ruleset only)
    QUESTS_LEGACY = new("quests_legacy")

    # A scene challenge progress track.
    SCENE_CHALLENGE_PROGRESS = new("scene_challenge_progress")

    # A vow progress track, started with Swear an Iron Vow.
    VOW_PROGRESS = new("vow_progress")

    def self.from_json_data(data)
      {
        "bonds_legacy" => BONDS_LEGACY,
        "bonds_progress" => BONDS_PROGRESS,
        "combat_progress" => COMBAT_PROGRESS,
        "connection_progress" => CONNECTION_PROGRESS,
        "delve_progress" => DELVE_PROGRESS,
        "discoveries_legacy" => DISCOVERIES_LEGACY,
        "expedition_progress" => EXPEDITION_PROGRESS,
        "journey_progress" => JOURNEY_PROGRESS,
        "quests_legacy" => QUESTS_LEGACY,
        "scene_challenge_progress" => SCENE_CHALLENGE_PROGRESS,
        "vow_progress" => VOW_PROGRESS,
      }[data]
    end

    def to_json_data
      value
    end
  end

  class Rarity
    attr_accessor :asset
    attr_accessor :description
    attr_accessor :id
    attr_accessor :name
    attr_accessor :source
    attr_accessor :xp_cost
    attr_accessor :icon
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = Rarity.new
      out.asset = Dataforged::from_json_data(AssetID, data["asset"])
      out.description = Dataforged::from_json_data(MarkdownString, data["description"])
      out.id = Dataforged::from_json_data(RarityID, data["id"])
      out.name = Dataforged::from_json_data(Label, data["name"])
      out.source = Dataforged::from_json_data(Source, data["source"])
      out.xp_cost = Dataforged::from_json_data(Integer, data["xp_cost"])
      out.icon = Dataforged::from_json_data(SvgImageURL, data["icon"])
      out.suggestions = Dataforged::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["asset"] = Dataforged::to_json_data(asset)
      data["description"] = Dataforged::to_json_data(description)
      data["id"] = Dataforged::to_json_data(id)
      data["name"] = Dataforged::to_json_data(name)
      data["source"] = Dataforged::to_json_data(source)
      data["xp_cost"] = Dataforged::to_json_data(xp_cost)
      data["icon"] = Dataforged::to_json_data(icon) unless icon.nil?
      data["suggestions"] = Dataforged::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  class RarityID
    attr_accessor :value

    def self.from_json_data(data)
      out = RarityID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class RegionEntry
    attr_accessor :description
    attr_accessor :features
    attr_accessor :id
    attr_accessor :name
    attr_accessor :quest_starter
    attr_accessor :source
    attr_accessor :summary
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = RegionEntry.new
      out.description = Dataforged::from_json_data(MarkdownString, data["description"])
      out.features = Dataforged::from_json_data(Array[MarkdownString], data["features"])
      out.id = Dataforged::from_json_data(RegionEntryID, data["id"])
      out.name = Dataforged::from_json_data(Label, data["name"])
      out.quest_starter = Dataforged::from_json_data(MarkdownString, data["quest_starter"])
      out.source = Dataforged::from_json_data(Source, data["source"])
      out.summary = Dataforged::from_json_data(MarkdownString, data["summary"])
      out.suggestions = Dataforged::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Dataforged::to_json_data(description)
      data["features"] = Dataforged::to_json_data(features)
      data["id"] = Dataforged::to_json_data(id)
      data["name"] = Dataforged::to_json_data(name)
      data["quest_starter"] = Dataforged::to_json_data(quest_starter)
      data["source"] = Dataforged::to_json_data(source)
      data["summary"] = Dataforged::to_json_data(summary)
      data["suggestions"] = Dataforged::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  class RegionEntryID
    attr_accessor :value

    def self.from_json_data(data)
      out = RegionEntryID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class RegularExpression
    attr_accessor :value

    def self.from_json_data(data)
      out = RegularExpression.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class SettingTruth
    attr_accessor :id
    attr_accessor :name
    attr_accessor :options
    attr_accessor :source
    attr_accessor :icon
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = SettingTruth.new
      out.id = Dataforged::from_json_data(SettingTruthID, data["id"])
      out.name = Dataforged::from_json_data(Label, data["name"])
      out.options = Dataforged::from_json_data(Array[SettingTruthOption], data["options"])
      out.source = Dataforged::from_json_data(Source, data["source"])
      out.icon = Dataforged::from_json_data(SvgImageURL, data["icon"])
      out.suggestions = Dataforged::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["id"] = Dataforged::to_json_data(id)
      data["name"] = Dataforged::to_json_data(name)
      data["options"] = Dataforged::to_json_data(options)
      data["source"] = Dataforged::to_json_data(source)
      data["icon"] = Dataforged::to_json_data(icon) unless icon.nil?
      data["suggestions"] = Dataforged::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  class SettingTruthID
    attr_accessor :value

    def self.from_json_data(data)
      out = SettingTruthID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class SettingTruthOption
    attr_accessor :description
    attr_accessor :id
    attr_accessor :quest_starter
    attr_accessor :summary

    def self.from_json_data(data)
      out = SettingTruthOption.new
      out.description = Dataforged::from_json_data(MarkdownString, data["description"])
      out.id = Dataforged::from_json_data(SettingTruthOptionID, data["id"])
      out.quest_starter = Dataforged::from_json_data(MarkdownString, data["quest_starter"])
      out.summary = Dataforged::from_json_data(MarkdownString, data["summary"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Dataforged::to_json_data(description)
      data["id"] = Dataforged::to_json_data(id)
      data["quest_starter"] = Dataforged::to_json_data(quest_starter)
      data["summary"] = Dataforged::to_json_data(summary)
      data
    end
  end

  class SettingTruthOptionID
    attr_accessor :value

    def self.from_json_data(data)
      out = SettingTruthOptionID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class Source
    attr_accessor :authors
    attr_accessor :date
    attr_accessor :license
    attr_accessor :title
    attr_accessor :url
    attr_accessor :page

    def self.from_json_data(data)
      out = Source.new
      out.authors = Dataforged::from_json_data(Array[String], data["authors"])
      out.date = Dataforged::from_json_data(DateTime, data["date"])
      out.license = Dataforged::from_json_data(URL, data["license"])
      out.title = Dataforged::from_json_data(String, data["title"])
      out.url = Dataforged::from_json_data(URL, data["url"])
      out.page = Dataforged::from_json_data(Integer, data["page"])
      out
    end

    def to_json_data
      data = {}
      data["authors"] = Dataforged::to_json_data(authors)
      data["date"] = Dataforged::to_json_data(date)
      data["license"] = Dataforged::to_json_data(license)
      data["title"] = Dataforged::to_json_data(title)
      data["url"] = Dataforged::to_json_data(url)
      data["page"] = Dataforged::to_json_data(page) unless page.nil?
      data
    end
  end

  # A player stat (e.g. `player/stats/edge`), a player condition meter (e.g.
  # `player/meters/health`), or an ID pointing to an asset option or asset
  # control whose value is to be used.
  class StatID
    attr_accessor :value

    def self.from_json_data(data)
      out = StatID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class Suggestions
    attr_accessor :assets
    attr_accessor :moves
    attr_accessor :oracles

    def self.from_json_data(data)
      out = Suggestions.new
      out.assets = Dataforged::from_json_data(Array[AssetID], data["assets"])
      out.moves = Dataforged::from_json_data(Array[MoveID], data["moves"])
      out.oracles = Dataforged::from_json_data(Array[OracleTableID], data["oracles"])
      out
    end

    def to_json_data
      data = {}
      data["assets"] = Dataforged::to_json_data(assets) unless assets.nil?
      data["moves"] = Dataforged::to_json_data(moves) unless moves.nil?
      data["oracles"] = Dataforged::to_json_data(oracles) unless oracles.nil?
      data
    end
  end

  # A relative URL pointing to an SVG image.
  class SvgImageURL
    attr_accessor :value

    def self.from_json_data(data)
      out = SvgImageURL.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  # A rich text string in Markdown with replaced values from oracle roll
  # results.
  # 
  #       The custom syntax `{{some_row_key:some_oracle_table_id}}`
  # should be replaced by the `some_row_key` string of a rolled
  # oracle table. This is usually the `result` key, for example
  # `{{result:starforged/oracles/core/action}}`
  class TemplateString
    attr_accessor :value

    def self.from_json_data(data)
      out = TemplateString.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  # Describes a move's trigger condition(s) and any rolls associated with them.
  class Trigger
    attr_accessor :roll_type

    def self.from_json_data(data)
      {
        "action_roll" => TriggerActionRoll,
        "progress_roll" => TriggerProgressRoll,
      }[data["roll_type"]].from_json_data(data)
    end
  end

  class TriggerActionRoll < Trigger
    attr_accessor :text
    attr_accessor :options

    def self.from_json_data(data)
      out = TriggerActionRoll.new
      out.roll_type = "action_roll"
      out.text = Dataforged::from_json_data(MarkdownString, data["text"])
      out.options = Dataforged::from_json_data(Array[TriggerOptionAction], data["options"])
      out
    end

    def to_json_data
      data = { "roll_type" => "action_roll" }
      data["text"] = Dataforged::to_json_data(text)
      data["options"] = Dataforged::to_json_data(options) unless options.nil?
      data
    end
  end

  class TriggerProgressRoll < Trigger
    attr_accessor :text
    attr_accessor :options

    def self.from_json_data(data)
      out = TriggerProgressRoll.new
      out.roll_type = "progress_roll"
      out.text = Dataforged::from_json_data(MarkdownString, data["text"])
      out.options = Dataforged::from_json_data(Array[TriggerOptionProgress], data["options"])
      out
    end

    def to_json_data
      data = { "roll_type" => "progress_roll" }
      data["text"] = Dataforged::to_json_data(text)
      data["options"] = Dataforged::to_json_data(options) unless options.nil?
      data
    end
  end

  # Information on who can trigger this trigger option. Usually this is just the
  # player, but some asset abilities can trigger from an ally's move.
  class TriggerBy
    attr_accessor :ally
    attr_accessor :player

    def self.from_json_data(data)
      out = TriggerBy.new
      out.ally = Dataforged::from_json_data(TrueClass, data["ally"])
      out.player = Dataforged::from_json_data(TrueClass, data["player"])
      out
    end

    def to_json_data
      data = {}
      data["ally"] = Dataforged::to_json_data(ally)
      data["player"] = Dataforged::to_json_data(player)
      data
    end
  end

  # Extends or upgrades an existing move trigger.
  class TriggerExtension
    attr_accessor :roll_type

    def self.from_json_data(data)
      {
        "action_roll" => TriggerExtensionActionRoll,
        "progress_roll" => TriggerExtensionProgressRoll,
      }[data["roll_type"]].from_json_data(data)
    end
  end

  # Extends or upgrades an existing action roll trigger.
  class TriggerExtensionActionRoll < TriggerExtension
    attr_accessor :options

    def self.from_json_data(data)
      out = TriggerExtensionActionRoll.new
      out.roll_type = "action_roll"
      out.options = Dataforged::from_json_data(Array[TriggerOptionAction], data["options"])
      out
    end

    def to_json_data
      data = { "roll_type" => "action_roll" }
      data["options"] = Dataforged::to_json_data(options)
      data
    end
  end

  # Extends or upgrades an existing action roll trigger.
  class TriggerExtensionProgressRoll < TriggerExtension
    attr_accessor :options

    def self.from_json_data(data)
      out = TriggerExtensionProgressRoll.new
      out.roll_type = "progress_roll"
      out.options = Dataforged::from_json_data(Array[TriggerOptionProgress], data["options"])
      out
    end

    def to_json_data
      data = { "roll_type" => "progress_roll" }
      data["options"] = Dataforged::to_json_data(options)
      data
    end
  end

  class TriggerOptionAction
    attr_accessor :method
    attr_accessor :by
    attr_accessor :choices

    # Describes any additional trigger conditions for this trigger option
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerOptionAction.new
      out.method = Dataforged::from_json_data(MoveRollMethod, data["method"])
      out.by = Dataforged::from_json_data(TriggerBy, data["by"])
      out.choices = Dataforged::from_json_data(Array[TriggerOptionActionChoice], data["choices"])
      out.text = Dataforged::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Dataforged::to_json_data(method)
      data["by"] = Dataforged::to_json_data(by) unless by.nil?
      data["choices"] = Dataforged::to_json_data(choices) unless choices.nil?
      data["text"] = Dataforged::to_json_data(text) unless text.nil?
      data
    end
  end

  class TriggerOptionActionChoice
    attr_accessor :using

    def self.from_json_data(data)
      {
        "custom_value" => TriggerOptionActionChoiceCustomValue,
        "edge" => TriggerOptionActionChoiceEdge,
        "health" => TriggerOptionActionChoiceHealth,
        "heart" => TriggerOptionActionChoiceHeart,
        "iron" => TriggerOptionActionChoiceIron,
        "ref" => TriggerOptionActionChoiceRef,
        "shadow" => TriggerOptionActionChoiceShadow,
        "spirit" => TriggerOptionActionChoiceSpirit,
        "supply" => TriggerOptionActionChoiceSupply,
        "wits" => TriggerOptionActionChoiceWits,
      }[data["using"]].from_json_data(data)
    end
  end

  class TriggerOptionActionChoiceCustomValue < TriggerOptionActionChoice
    attr_accessor :label
    attr_accessor :value

    def self.from_json_data(data)
      out = TriggerOptionActionChoiceCustomValue.new
      out.using = "custom_value"
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.value = Dataforged::from_json_data(Integer, data["value"])
      out
    end

    def to_json_data
      data = { "using" => "custom_value" }
      data["label"] = Dataforged::to_json_data(label)
      data["value"] = Dataforged::to_json_data(value)
      data
    end
  end

  class TriggerOptionActionChoiceEdge < TriggerOptionActionChoice

    def self.from_json_data(data)
      out = TriggerOptionActionChoiceEdge.new
      out.using = "edge"
      out
    end

    def to_json_data
      data = { "using" => "edge" }
      data
    end
  end

  class TriggerOptionActionChoiceHealth < TriggerOptionActionChoice

    def self.from_json_data(data)
      out = TriggerOptionActionChoiceHealth.new
      out.using = "health"
      out
    end

    def to_json_data
      data = { "using" => "health" }
      data
    end
  end

  class TriggerOptionActionChoiceHeart < TriggerOptionActionChoice

    def self.from_json_data(data)
      out = TriggerOptionActionChoiceHeart.new
      out.using = "heart"
      out
    end

    def to_json_data
      data = { "using" => "heart" }
      data
    end
  end

  class TriggerOptionActionChoiceIron < TriggerOptionActionChoice

    def self.from_json_data(data)
      out = TriggerOptionActionChoiceIron.new
      out.using = "iron"
      out
    end

    def to_json_data
      data = { "using" => "iron" }
      data
    end
  end

  class TriggerOptionActionChoiceRef < TriggerOptionActionChoice
    attr_accessor :label
    attr_accessor :ref

    def self.from_json_data(data)
      out = TriggerOptionActionChoiceRef.new
      out.using = "ref"
      out.label = Dataforged::from_json_data(Label, data["label"])
      out.ref = Dataforged::from_json_data(String, data["ref"])
      out
    end

    def to_json_data
      data = { "using" => "ref" }
      data["label"] = Dataforged::to_json_data(label)
      data["ref"] = Dataforged::to_json_data(ref)
      data
    end
  end

  class TriggerOptionActionChoiceShadow < TriggerOptionActionChoice

    def self.from_json_data(data)
      out = TriggerOptionActionChoiceShadow.new
      out.using = "shadow"
      out
    end

    def to_json_data
      data = { "using" => "shadow" }
      data
    end
  end

  class TriggerOptionActionChoiceSpirit < TriggerOptionActionChoice

    def self.from_json_data(data)
      out = TriggerOptionActionChoiceSpirit.new
      out.using = "spirit"
      out
    end

    def to_json_data
      data = { "using" => "spirit" }
      data
    end
  end

  class TriggerOptionActionChoiceSupply < TriggerOptionActionChoice

    def self.from_json_data(data)
      out = TriggerOptionActionChoiceSupply.new
      out.using = "supply"
      out
    end

    def to_json_data
      data = { "using" => "supply" }
      data
    end
  end

  class TriggerOptionActionChoiceWits < TriggerOptionActionChoice

    def self.from_json_data(data)
      out = TriggerOptionActionChoiceWits.new
      out.using = "wits"
      out
    end

    def to_json_data
      data = { "using" => "wits" }
      data
    end
  end

  class TriggerOptionProgress
    attr_accessor :method
    attr_accessor :by
    attr_accessor :choices

    # Describes any additional trigger conditions for this trigger option
    attr_accessor :text

    def self.from_json_data(data)
      out = TriggerOptionProgress.new
      out.method = Dataforged::from_json_data(MoveRollMethod, data["method"])
      out.by = Dataforged::from_json_data(TriggerBy, data["by"])
      out.choices = Dataforged::from_json_data(Array[TriggerOptionProgressChoice], data["choices"])
      out.text = Dataforged::from_json_data(MarkdownString, data["text"])
      out
    end

    def to_json_data
      data = {}
      data["method"] = Dataforged::to_json_data(method)
      data["by"] = Dataforged::to_json_data(by) unless by.nil?
      data["choices"] = Dataforged::to_json_data(choices) unless choices.nil?
      data["text"] = Dataforged::to_json_data(text) unless text.nil?
      data
    end
  end

  class TriggerOptionProgressChoice
    attr_accessor :using

    def self.from_json_data(data)
      out = TriggerOptionProgressChoice.new
      out.using = Dataforged::from_json_data(ProgressType, data["using"])
      out
    end

    def to_json_data
      data = {}
      data["using"] = Dataforged::to_json_data(using)
      data
    end
  end

  # An absolute URL pointing to a web site.
  class URL
    attr_accessor :value

    def self.from_json_data(data)
      out = URL.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  # A relative URL pointing to a WEBP image.
  class WebpImageURL
    attr_accessor :value

    def self.from_json_data(data)
      out = WebpImageURL.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class WorldTruth
    attr_accessor :id
    attr_accessor :name
    attr_accessor :options
    attr_accessor :source
    attr_accessor :icon
    attr_accessor :suggestions

    def self.from_json_data(data)
      out = WorldTruth.new
      out.id = Dataforged::from_json_data(WorldTruthID, data["id"])
      out.name = Dataforged::from_json_data(Label, data["name"])
      out.options = Dataforged::from_json_data(Array[WorldTruthOption], data["options"])
      out.source = Dataforged::from_json_data(Source, data["source"])
      out.icon = Dataforged::from_json_data(SvgImageURL, data["icon"])
      out.suggestions = Dataforged::from_json_data(Suggestions, data["suggestions"])
      out
    end

    def to_json_data
      data = {}
      data["id"] = Dataforged::to_json_data(id)
      data["name"] = Dataforged::to_json_data(name)
      data["options"] = Dataforged::to_json_data(options)
      data["source"] = Dataforged::to_json_data(source)
      data["icon"] = Dataforged::to_json_data(icon) unless icon.nil?
      data["suggestions"] = Dataforged::to_json_data(suggestions) unless suggestions.nil?
      data
    end
  end

  class WorldTruthID
    attr_accessor :value

    def self.from_json_data(data)
      out = WorldTruthID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  class WorldTruthOption
    attr_accessor :description
    attr_accessor :id
    attr_accessor :quest_starter

    def self.from_json_data(data)
      out = WorldTruthOption.new
      out.description = Dataforged::from_json_data(MarkdownString, data["description"])
      out.id = Dataforged::from_json_data(WorldTruthOptionID, data["id"])
      out.quest_starter = Dataforged::from_json_data(MarkdownString, data["quest_starter"])
      out
    end

    def to_json_data
      data = {}
      data["description"] = Dataforged::to_json_data(description)
      data["id"] = Dataforged::to_json_data(id)
      data["quest_starter"] = Dataforged::to_json_data(quest_starter)
      data
    end
  end

  class WorldTruthOptionID
    attr_accessor :value

    def self.from_json_data(data)
      out = WorldTruthOptionID.new
      out.value = Dataforged.from_json_data(String, data)
      out
    end

    def to_json_data
      Dataforged.to_json_data(value)
    end
  end

  private

  def self.from_json_data(type, data)
    if data.nil? || [Object, TrueClass, Integer, Float, String].include?(type)
      data
    elsif type == DateTime
      DateTime.rfc3339(data)
    elsif type.is_a?(Array)
      data.map { |elem| from_json_data(type.first, elem) }
    elsif type.is_a?(Hash)
      data.transform_values { |elem| from_json_data(type.values.first, elem) }
    else
      type.from_json_data(data)
    end
  end

  def self.to_json_data(data)
    if data.nil? || [TrueClass, FalseClass, Integer, Float, String].include?(data.class)
      data
    elsif data.is_a?(DateTime)
      data.rfc3339
    elsif data.is_a?(Array)
      data.map { |elem| to_json_data(elem) }
    elsif data.is_a?(Hash)
      data.transform_values { |elem| to_json_data(elem) }
    else
      data.to_json_data
    end
  end
end
