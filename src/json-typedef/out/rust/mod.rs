// Code generated by jtd-codegen for Rust v0.2.1

use chrono::{DateTime, FixedOffset};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

pub type Dataforged = Option<Value>;

#[derive(Serialize, Deserialize)]
pub struct Asset {
    #[serde(rename = "abilities")]
    pub abilities: Vec<AssetAbility>,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "attachments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Box<AssetAttachment>>,

    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetControlField>>>,

    /// If `true`, this asset counts as an impact (Starforged) or a debility
    /// (classic Ironsworn).
    #[serde(rename = "count_as_impact")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub countAsImpact: Option<Box<bool>>,

    #[serde(rename = "options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<Box<HashMap<String, AssetOptionField>>>,

    #[serde(rename = "requirement")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requirement: Option<Box<MarkdownString>>,

    /// Most assets only benefit to their owner, but certain assets (like
    /// Starforged's module and command vehicle assets) are shared amongst the
    /// player's allies, too.
    #[serde(rename = "shared")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared: Option<Box<bool>>,
}

#[derive(Serialize, Deserialize)]
pub struct AssetAbility {
    #[serde(rename = "enabled")]
    pub enabled: bool,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetAbilityControlField>>>,

    #[serde(rename = "extend_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extendAsset: Option<Box<AssetExtension>>,

    #[serde(rename = "extend_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extendMoves: Option<Box<Vec<MoveExtension>>>,

    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<HashMap<String, Move>>>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<Box<Label>>,

    #[serde(rename = "options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<Box<HashMap<String, AssetOptionField>>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetAbilityControlField {
    #[serde(rename = "checkbox")]
    Checkbox(AssetAbilityControlFieldCheckbox),

    #[serde(rename = "clock")]
    Clock(AssetAbilityControlFieldClock),

    #[serde(rename = "counter")]
    Counter(AssetAbilityControlFieldCounter),
}

#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldCheckbox {
    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: Option<Box<bool>>,
}

#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldClock {
    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "max")]
    pub max: i8,

    #[serde(rename = "min")]
    pub min: i8,

    #[serde(rename = "value")]
    pub value: i8,
}

#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldCounter {
    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "max")]
    pub max: Option<Box<i8>>,

    #[serde(rename = "min")]
    pub min: i8,

    #[serde(rename = "value")]
    pub value: i8,
}

/// Describes which assets can be attached to this asset. The "canonical"
/// example for this are Starforged's Module assets, which can be equipped by
/// Command Vehicle assets. See p. 55 of Starforged for more info.
#[derive(Serialize, Deserialize)]
pub struct AssetAttachment {
    /// Regular expressions matching the IDs of assets that can be attached to
    /// this asset.
    #[serde(rename = "patterns")]
    pub patterns: Vec<RegularExpression>,

    /// The maximum number of attached assets. Omitted if there's no upper limit
    /// to the number of attached assets.
    #[serde(rename = "max")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max: Option<Box<u8>>,
}

/// Asset controls are fields that are expected to change throughout the
/// asset's lifespan. The most common example are the condition meters on
/// certain assets. A more complex example is the distinct mechanical modes on
/// Ironsworn's 'Armored'.
#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetControlField {
    #[serde(rename = "checkbox")]
    Checkbox(AssetControlFieldCheckbox),

    #[serde(rename = "choices_extend_asset")]
    ChoicesExtendAsset(AssetControlFieldChoicesExtendAsset),

    #[serde(rename = "condition_meter")]
    ConditionMeter(AssetControlFieldConditionMeter),
}

#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldCheckbox {
    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: Option<Box<bool>>,
}

#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldChoicesExtendAssetChoice {
    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: AssetExtension,

    #[serde(rename = "selected")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected: Option<Box<bool>>,
}

#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldChoicesExtendAsset {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetControlFieldChoicesExtendAssetChoice>,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "label")]
    pub label: Label,
}

#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldConditionMeter {
    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "max")]
    pub max: i8,

    #[serde(rename = "min")]
    pub min: i8,

    #[serde(rename = "value")]
    pub value: i8,
}

#[derive(Serialize, Deserialize)]
pub struct AssetExtensionAttachments {
    #[serde(rename = "max")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max: Option<Box<u8>>,

    #[serde(rename = "patterns")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub patterns: Option<Box<Vec<RegularExpression>>>,
}

#[derive(Serialize, Deserialize)]
pub struct AssetExtensionControl {
    #[serde(rename = "max")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max: Option<Box<i8>>,

    #[serde(rename = "min")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub min: Option<Box<i8>>,
}

/// Describes changes applied to an asset, usually by another asset. Assume that
/// unspecified/null properties are unchanged.
#[derive(Serialize, Deserialize)]
pub struct AssetExtension {
    #[serde(rename = "attachments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Box<AssetExtensionAttachments>>,

    /// Use the same key as the original control. Currently, only condition
    /// meters may be extended in this way.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetExtensionControl>>>,

    #[serde(rename = "count_as_impact")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub countAsImpact: Option<Box<bool>>,
}

#[derive(Serialize, Deserialize)]
pub struct AssetExtensionChoice {
    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: AssetExtension,
}

#[derive(Serialize, Deserialize)]
pub struct AssetExtensionForeignAttachments {
    #[serde(rename = "max")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max: Option<Box<u8>>,

    #[serde(rename = "patterns")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub patterns: Option<Box<Vec<RegularExpression>>>,
}

#[derive(Serialize, Deserialize)]
pub struct AssetExtensionForeignControl {
    #[serde(rename = "max")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max: Option<Box<i8>>,

    #[serde(rename = "min")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub min: Option<Box<i8>>,
}

/// Describes changes applied to an asset, usually by another asset. Assume that
/// unspecified/null properties are unchanged.
#[derive(Serialize, Deserialize)]
pub struct AssetExtensionForeign {
    #[serde(rename = "_extends")]
    pub extends: Id,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "attachments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Box<AssetExtensionForeignAttachments>>,

    /// Use the same key as the original control. Currently, only condition
    /// meters may be extended in this way.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetExtensionForeignControl>>>,

    #[serde(rename = "count_as_impact")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub countAsImpact: Option<Box<bool>>,
}

/// Asset options are fields that are usually only set once, typically when the
/// player purchases the asset. The most common examples are the "Name" fields
/// on companion assets. A more complex example is the choice of stats on the
/// Devotant asset.
#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetOptionField {
    #[serde(rename = "choices_extend_asset")]
    ChoicesExtendAsset(AssetOptionFieldChoicesExtendAsset),

    #[serde(rename = "choices_number")]
    ChoicesNumber(AssetOptionFieldChoicesNumber),

    #[serde(rename = "choices_stat_id")]
    ChoicesStatId(AssetOptionFieldChoicesStatId),

    #[serde(rename = "text")]
    Text(AssetOptionFieldText),
}

#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldChoicesExtendAssetChoice {
    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: AssetExtension,

    #[serde(rename = "selected")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected: Option<Box<bool>>,
}

#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldChoicesExtendAsset {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetOptionFieldChoicesExtendAssetChoice>,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "label")]
    pub label: Label,
}

#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldChoicesNumberChoice {
    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: i8,

    #[serde(rename = "selected")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected: Option<Box<bool>>,
}

#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldChoicesNumber {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetOptionFieldChoicesNumberChoice>,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "label")]
    pub label: Label,
}

#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldChoicesStatIdChoice {
    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: StatId,

    #[serde(rename = "selected")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected: Option<Box<bool>>,
}

#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldChoicesStatId {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetOptionFieldChoicesStatIdChoice>,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "label")]
    pub label: Label,
}

#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldText {
    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<Box<String>>,
}

pub type ChallengeRank = u8;

/// A valid CSS color.
pub type Color = String;

#[derive(Serialize, Deserialize)]
pub enum DelveSiteDenizenFrequency {
    #[serde(rename = "common")]
    Common,

    #[serde(rename = "rare")]
    Rare,

    #[serde(rename = "uncommon")]
    Uncommon,

    #[serde(rename = "unforeseen")]
    Unforeseen,

    #[serde(rename = "very_common")]
    VeryCommon,
}

#[derive(Serialize, Deserialize)]
pub struct DelveSiteDenizen {
    #[serde(rename = "frequency")]
    pub frequency: DelveSiteDenizenFrequency,

    #[serde(rename = "high")]
    pub high: u8,

    #[serde(rename = "low")]
    pub low: u8,

    #[serde(rename = "encounter")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encounter: Option<Box<Id>>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<Box<Label>>,
}

#[derive(Serialize, Deserialize)]
pub enum DelveSiteDomainCardType {
    #[serde(rename = "domain")]
    Domain,
}

#[derive(Serialize, Deserialize)]
pub struct DelveSiteDomain {
    #[serde(rename = "card_type")]
    pub cardType: DelveSiteDomainCardType,

    #[serde(rename = "dangers")]
    pub dangers: Vec<FeatureOrDanger>,

    #[serde(rename = "features")]
    pub features: Vec<FeatureOrDanger>,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "summary")]
    pub summary: MarkdownString,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

#[derive(Serialize, Deserialize)]
pub enum DelveSiteThemeCardType {
    #[serde(rename = "theme")]
    Theme,
}

#[derive(Serialize, Deserialize)]
pub struct DelveSiteTheme {
    #[serde(rename = "card_type")]
    pub cardType: DelveSiteThemeCardType,

    #[serde(rename = "dangers")]
    pub dangers: Vec<FeatureOrDanger>,

    #[serde(rename = "features")]
    pub features: Vec<FeatureOrDanger>,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "summary")]
    pub summary: MarkdownString,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

pub type EncounterNatureClassic = String;

pub type EncounterNatureStarforged = String;

#[derive(Serialize, Deserialize)]
pub struct EncounterStarforged {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "drives")]
    pub drives: Vec<MarkdownString>,

    #[serde(rename = "features")]
    pub features: Vec<MarkdownString>,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "nature")]
    pub nature: EncounterNatureStarforged,

    #[serde(rename = "quest_starter")]
    pub questStarter: MarkdownString,

    #[serde(rename = "rank")]
    pub rank: ChallengeRank,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "summary")]
    pub summary: MarkdownString,

    #[serde(rename = "tactics")]
    pub tactics: Vec<MarkdownString>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "variants")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub variants: Option<Box<HashMap<String, EncounterVariantStarforged>>>,
}

#[derive(Serialize, Deserialize)]
pub struct EncounterVariantStarforged {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "nature")]
    pub nature: EncounterNatureStarforged,

    #[serde(rename = "rank")]
    pub rank: ChallengeRank,
}

#[derive(Serialize, Deserialize)]
pub struct FeatureOrDanger {
    #[serde(rename = "high")]
    pub high: u8,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "low")]
    pub low: u8,

    #[serde(rename = "result")]
    pub result: MarkdownString,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<Id>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rolls: Option<Box<Vec<OracleTableRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

pub type Id = String;

/// A user-facing text label or name.
pub type Label = String;

/// A rich text string in Markdown. Usually this is a direct excerpt from the
/// rules text.
/// 
///       The custom syntax `{{table:some_oracle_table_id}}` represents a
/// markdown table rendered from oracle data.
pub type MarkdownString = String;

#[derive(Serialize, Deserialize)]
pub struct Move {
    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "trigger")]
    pub trigger: Trigger,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveCategory {
    #[serde(rename = "canonical_name")]
    pub canonicalName: Label,

    #[serde(rename = "color")]
    pub color: Color,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, Move>,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "summary")]
    pub summary: MarkdownString,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveExtension {
    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "trigger")]
    pub trigger: TriggerExtension,

    #[serde(rename = "_extends")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extends: Option<Box<Vec<Id>>>,

    #[serde(rename = "outcomes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub outcomes: Option<Box<MoveOutcomesExtension>>,

    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveOutcome {
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "count_as")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub countAs: Option<Box<MoveOutcomeType>>,

    #[serde(rename = "reroll")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reroll: Option<Box<MoveReroll>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveOutcomeExtensionReroll {
    #[serde(rename = "method")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub method: Option<Box<MoveRerollMethod>>,

    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveOutcomeExtension {
    #[serde(rename = "count_as")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub countAs: Option<Box<MoveOutcomeType>>,

    #[serde(rename = "reroll")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reroll: Option<Box<MoveOutcomeExtensionReroll>>,

    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveOutcomeMatchable {
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "count_as")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub countAs: Option<Box<MoveOutcomeType>>,

    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<MoveOutcome>>,

    #[serde(rename = "reroll")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reroll: Option<Box<MoveReroll>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveOutcomeMatchableExtensionReroll {
    #[serde(rename = "method")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub method: Option<Box<MoveRerollMethod>>,

    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveOutcomeMatchableExtension {
    #[serde(rename = "count_as")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub countAs: Option<Box<MoveOutcomeType>>,

    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<MoveOutcomeExtension>>,

    #[serde(rename = "reroll")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reroll: Option<Box<MoveOutcomeMatchableExtensionReroll>>,

    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub enum MoveOutcomeType {
    /// The player's score doesn't beat any challenge dice.
    #[serde(rename = "miss")]
    Miss,

    /// The player's score beats both of the challenge dice.
    #[serde(rename = "strong_hit")]
    StrongHit,

    /// The player's score beats one of the challenge dice.
    #[serde(rename = "weak_hit")]
    WeakHit,
}

#[derive(Serialize, Deserialize)]
pub struct MoveOutcomes {
    #[serde(rename = "miss")]
    pub miss: MoveOutcomeMatchable,

    #[serde(rename = "strong_hit")]
    pub strongHit: MoveOutcomeMatchable,

    #[serde(rename = "weak_hit")]
    pub weakHit: MoveOutcome,
}

#[derive(Serialize, Deserialize)]
pub struct MoveOutcomesExtension {
    #[serde(rename = "miss")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub miss: Option<Box<MoveOutcomeMatchableExtension>>,

    #[serde(rename = "strong_hit")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub strongHit: Option<Box<MoveOutcomeMatchableExtension>>,

    #[serde(rename = "weak_hit")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub weakHit: Option<Box<MoveOutcomeExtension>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveReroll {
    #[serde(rename = "method")]
    pub method: MoveRerollMethod,

    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub enum MoveRerollMethod {
    /// Reroll the action die
    #[serde(rename = "action_die")]
    ActionDie,

    /// Reroll all dice
    #[serde(rename = "all")]
    All,

    /// Reroll any dice
    #[serde(rename = "any")]
    Any,

    /// Reroll any challenge dice
    #[serde(rename = "challenge_dice")]
    ChallengeDice,

    /// Reroll one challenge die
    #[serde(rename = "challenge_die")]
    ChallengeDie,
}

#[derive(Serialize, Deserialize)]
pub struct OracleCollection {
    #[serde(rename = "canonical_name")]
    pub canonicalName: Label,

    #[serde(rename = "contents")]
    pub contents: HashMap<String, OracleTable>,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "summary")]
    pub summary: MarkdownString,

    #[serde(rename = "collections")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collections: Option<Box<HashMap<String, OracleCollection>>>,

    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<Color>>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "rendering")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rendering: Option<Box<OracleCollectionRendering>>,

    #[serde(rename = "sample_names")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sampleNames: Option<Box<Vec<Label>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleCollectionColumn {
    #[serde(rename = "content_type")]
    pub contentType: OracleColumnContentType,

    #[serde(rename = "table_key")]
    pub tableKey: String,

    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<Color>>,

    #[serde(rename = "label")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<Box<Label>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleCollectionRendering {
    #[serde(rename = "columns")]
    pub columns: HashMap<String, OracleCollectionColumn>,

    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<Color>>,

    #[serde(rename = "style")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub style: Option<Box<OracleCollectionStyle>>,
}

#[derive(Serialize, Deserialize)]
pub enum OracleCollectionStyle {
    #[serde(rename = "multi_table")]
    MultiTable,
}

#[derive(Serialize, Deserialize)]
pub enum OracleColumnContentType {
    #[serde(rename = "description")]
    Description,

    #[serde(rename = "range")]
    Range,

    #[serde(rename = "result")]
    Result,

    #[serde(rename = "summary")]
    Summary,
}

#[derive(Serialize, Deserialize)]
pub struct OracleRollTemplate {
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<TemplateString>>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<Box<TemplateString>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<TemplateString>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTable {
    #[serde(rename = "canonical_name")]
    pub canonicalName: Label,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "table")]
    pub table: Vec<OracleTableRow>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleTableMatchBehavior>>,

    #[serde(rename = "rendering")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rendering: Option<Box<OracleTableRendering>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableColumn {
    #[serde(rename = "content_type")]
    pub contentType: OracleColumnContentType,

    #[serde(rename = "label")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub label: Option<Box<Label>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableMatchBehavior {
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableRendering {
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<Color>>,

    #[serde(rename = "columns")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub columns: Option<Box<HashMap<String, OracleTableColumn>>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "style")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub style: Option<Box<OracleTableStyle>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableRoll {
    #[serde(rename = "oracle")]
    pub oracle: Id,

    #[serde(rename = "method")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub method: Option<Box<OracleTableRollMethod>>,

    #[serde(rename = "times")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub times: Option<Box<u8>>,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableRollMethod {
    #[serde(rename = "keep_duplicates")]
    KeepDuplicates,

    #[serde(rename = "make_it_worse")]
    MakeItWorse,

    #[serde(rename = "no_duplicates")]
    NoDuplicates,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableRow {
    #[serde(rename = "high")]
    pub high: Option<Box<u8>>,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "low")]
    pub low: Option<Box<u8>>,

    #[serde(rename = "result")]
    pub result: MarkdownString,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<Id>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rolls: Option<Box<Vec<OracleTableRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

#[derive(Serialize, Deserialize)]
pub enum OracleTableStyle {
    #[serde(rename = "embed_as_column")]
    EmbedAsColumn,

    #[serde(rename = "embed_in_row")]
    EmbedInRow,

    #[serde(rename = "table")]
    Table,
}

#[derive(Serialize, Deserialize)]
pub enum ProgressType {
    /// A player's Bonds legacy track(Starforged ruleset only)
    #[serde(rename = "bonds_legacy")]
    BondsLegacy,

    /// A player's bonds progress track (Ironsworn ruleset only)
    #[serde(rename = "bonds_progress")]
    BondsProgress,

    /// A combat progress track, started with Enter the Fray.
    #[serde(rename = "combat_progress")]
    CombatProgress,

    /// A connection progress track, started with Make a Connection (Starforged
    /// ruleset only)
    #[serde(rename = "connection_progress")]
    ConnectionProgress,

    /// A delve site progress track, started with Discover a Site (Ironsworn
    /// ruleset only)
    #[serde(rename = "delve_progress")]
    DelveProgress,

    /// A player's Discoveries legacy track(Starforged ruleset only)
    #[serde(rename = "discoveries_legacy")]
    DiscoveriesLegacy,

    /// An expedition progress track, started with Undertake an Expedition
    /// (Starforged ruleset only)
    #[serde(rename = "expedition_progress")]
    ExpeditionProgress,

    /// A journey progress track, started with Undertake a Journey (Ironsworn
    /// ruleset only)
    #[serde(rename = "journey_progress")]
    JourneyProgress,

    /// A player's Quests legacy track (Starforged ruleset only)
    #[serde(rename = "quests_legacy")]
    QuestsLegacy,

    /// A scene challenge progress track
    #[serde(rename = "scene_challenge_progress")]
    SceneChallengeProgress,

    /// A vow progress track, started with Swear an Iron Vow
    #[serde(rename = "vow_progress")]
    VowProgress,
}

#[derive(Serialize, Deserialize)]
pub struct Rarity {
    #[serde(rename = "asset")]
    pub asset: Id,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "xp_cost")]
    pub xpCost: u8,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

#[derive(Serialize, Deserialize)]
pub struct RegionEntry {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "features")]
    pub features: Vec<MarkdownString>,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "quest_starter")]
    pub questStarter: MarkdownString,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "summary")]
    pub summary: MarkdownString,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

pub type RegularExpression = String;

#[derive(Serialize, Deserialize)]
pub enum RollMethod {
    /// When rolling with this move trigger option, *every* stat or progress
    /// track of the `using` key is rolled
    #[serde(rename = "all")]
    All,

    /// When rolling with this move trigger option, the player picks which stat
    /// to use.
    #[serde(rename = "any")]
    Any,

    /// When rolling with this move trigger option, use the highest/best option
    /// from the `using` key.
    #[serde(rename = "highest")]
    Highest,

    /// When rolling with this move trigger option, use the lowest/worst option
    /// from the `using` key.
    #[serde(rename = "lowest")]
    Lowest,

    /// Take an automatic miss instead of rolling.
    #[serde(rename = "miss")]
    Miss,

    /// Take an automatic strong hit instead of rolling.
    #[serde(rename = "strong_hit")]
    StrongHit,

    /// Take an automatic weak hit instead of rolling.
    #[serde(rename = "weak_hit")]
    WeakHit,
}

#[derive(Serialize, Deserialize)]
pub struct SettingTruth {
    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "options")]
    pub options: Vec<SettingTruthOption>,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

#[derive(Serialize, Deserialize)]
pub struct SettingTruthOption {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "quest_starter")]
    pub questStarter: MarkdownString,

    #[serde(rename = "summary")]
    pub summary: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct Source {
    #[serde(rename = "authors")]
    pub authors: Vec<String>,

    #[serde(rename = "date")]
    pub date: DateTime<FixedOffset>,

    #[serde(rename = "license")]
    pub license: Url,

    #[serde(rename = "title")]
    pub title: String,

    #[serde(rename = "url")]
    pub url: Url,

    #[serde(rename = "page")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page: Option<Box<u16>>,
}

/// A player stat (e.g. `player/stats/edge`), a player condition meter (e.g.
/// `player/meters/health`), or an ID pointing to an asset option or asset
/// control whose value is to be used.
pub type StatId = String;

#[derive(Serialize, Deserialize)]
pub struct Suggestions {
    #[serde(rename = "assets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assets: Option<Box<Vec<Id>>>,

    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<Vec<Id>>>,

    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<Id>>>,
}

/// A relative URL pointing to an SVG image.
pub type SvgImageUrl = String;

/// A rich text string in Markdown with replaced values from oracle roll
/// results.
/// 
///       The custom syntax `{{some_row_key:some_oracle_table_id}}`
/// should be replaced by the `some_row_key` string of a rolled
/// oracle table. This is usually the `result` key, for example
/// `{{result:starforged/oracles/core/action}}`
pub type TemplateString = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "roll_type")]
pub enum Trigger {
    #[serde(rename = "action_roll")]
    ActionRoll(TriggerActionRoll),

    #[serde(rename = "progress_roll")]
    ProgressRoll(TriggerProgressRoll),
}

#[derive(Serialize, Deserialize)]
pub struct TriggerActionRoll {
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<Box<Vec<TriggerOptionAction>>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRoll {
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<Box<Vec<TriggerOptionProgress>>>,
}

/// Information on who can trigger this trigger option. Usually this is just the
/// player, but some asset abilities can trigger from an ally's move.
#[derive(Serialize, Deserialize)]
pub struct TriggerBy {
    #[serde(rename = "ally")]
    pub ally: bool,

    #[serde(rename = "player")]
    pub player: bool,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "roll_type")]
pub enum TriggerExtension {
    #[serde(rename = "action_roll")]
    ActionRoll(TriggerExtensionActionRoll),

    #[serde(rename = "progress_roll")]
    ProgressRoll(TriggerExtensionProgressRoll),
}

#[derive(Serialize, Deserialize)]
pub struct TriggerExtensionActionRoll {
    #[serde(rename = "options")]
    pub options: Vec<TriggerOptionAction>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerExtensionProgressRoll {
    #[serde(rename = "options")]
    pub options: Vec<TriggerOptionProgress>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerOptionAction {
    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    #[serde(rename = "choices")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub choices: Option<Box<Vec<TriggerOptionChoiceAction>>>,

    #[serde(rename = "method")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub method: Option<Box<RollMethod>>,

    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "using")]
pub enum TriggerOptionChoiceAction {
    #[serde(rename = "custom")]
    Custom(TriggerOptionChoiceActionCustom),

    #[serde(rename = "stat")]
    Stat(TriggerOptionChoiceActionStat),
}

#[derive(Serialize, Deserialize)]
pub struct TriggerOptionChoiceActionCustom {
    #[serde(rename = "label")]
    pub label: Label,

    #[serde(rename = "value")]
    pub value: i8,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerOptionChoiceActionStat {
    #[serde(rename = "ref")]
    pub ref_: StatId,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerOptionChoiceProgress {
    #[serde(rename = "using")]
    pub using: ProgressType,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerOptionProgress {
    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    #[serde(rename = "choices")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub choices: Option<Box<Vec<TriggerOptionChoiceProgress>>>,

    #[serde(rename = "method")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub method: Option<Box<RollMethod>>,

    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

/// An absolute URL pointing to a web site.
pub type Url = String;

/// A relative URL pointing to a WEBP image.
pub type WebpImageUrl = String;

#[derive(Serialize, Deserialize)]
pub struct WorldTruth {
    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "options")]
    pub options: Vec<WorldTruthOption>,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgImageUrl>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

#[derive(Serialize, Deserialize)]
pub struct WorldTruthOption {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "id")]
    pub id: Id,

    #[serde(rename = "quest_starter")]
    pub questStarter: MarkdownString,
}
