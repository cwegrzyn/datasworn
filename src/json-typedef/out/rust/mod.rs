// Code generated by jtd-codegen for Rust v0.2.1

use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

pub type Dataforged = Option<Value>;

#[derive(Serialize, Deserialize)]
pub enum ActionRollMethod {
    #[serde(rename = "all")]
    All,

    #[serde(rename = "highest")]
    Highest,

    #[serde(rename = "lowest")]
    Lowest,

    #[serde(rename = "miss")]
    Miss,

    #[serde(rename = "player_choice")]
    PlayerChoice,

    #[serde(rename = "strong_hit")]
    StrongHit,

    #[serde(rename = "weak_hit")]
    WeakHit,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "using")]
pub enum ActionRollOption {
    #[serde(rename = "asset_control")]
    AssetControl(ActionRollOptionAssetControl),

    #[serde(rename = "asset_option")]
    AssetOption(ActionRollOptionAssetOption),

    #[serde(rename = "attached_asset_control")]
    AttachedAssetControl(ActionRollOptionAttachedAssetControl),

    #[serde(rename = "attached_asset_option")]
    AttachedAssetOption(ActionRollOptionAttachedAssetOption),

    #[serde(rename = "condition_meter")]
    ConditionMeter(ActionRollOptionConditionMeter),

    #[serde(rename = "custom")]
    Custom(ActionRollOptionCustom),

    #[serde(rename = "stat")]
    Stat(ActionRollOptionStat),
}

#[derive(Serialize, Deserialize)]
pub struct ActionRollOptionAssetControl {
    #[serde(rename = "assets")]
    pub assets: Option<Box<Vec<AssetIdwildcard>>>,

    /// The key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,
}

#[derive(Serialize, Deserialize)]
pub struct ActionRollOptionAssetOption {
    #[serde(rename = "assets")]
    pub assets: Option<Box<Vec<AssetIdwildcard>>>,

    /// The key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,
}

#[derive(Serialize, Deserialize)]
pub struct ActionRollOptionAttachedAssetControl {
    /// The key of the asset control field.
    #[serde(rename = "control")]
    pub control: DictKey,
}

#[derive(Serialize, Deserialize)]
pub struct ActionRollOptionAttachedAssetOption {
    /// The key of the asset option field.
    #[serde(rename = "option")]
    pub option: DictKey,
}

#[derive(Serialize, Deserialize)]
pub struct ActionRollOptionConditionMeter {
    #[serde(rename = "condition_meter")]
    pub conditionMeter: PlayerConditionMeter,
}

#[derive(Serialize, Deserialize)]
pub struct ActionRollOptionCustom {
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "value")]
    pub value: i16,
}

#[derive(Serialize, Deserialize)]
pub struct ActionRollOptionStat {
    #[serde(rename = "stat")]
    pub stat: PlayerStat,
}

#[derive(Serialize, Deserialize)]
pub enum ActionRollUsing {
    #[serde(rename = "asset_control")]
    AssetControl,

    #[serde(rename = "asset_option")]
    AssetOption,

    #[serde(rename = "attached_asset_control")]
    AttachedAssetControl,

    #[serde(rename = "attached_asset_option")]
    AttachedAssetOption,

    #[serde(rename = "condition_meter")]
    ConditionMeter,

    #[serde(rename = "custom")]
    Custom,

    #[serde(rename = "stat")]
    Stat,
}

#[derive(Serialize, Deserialize)]
pub struct Asset {
    #[serde(rename = "abilities")]
    pub abilities: Vec<AssetAbility>,

    /// A localized category label for this asset. This is the surtitle above
    /// the asset's name on the card.
    #[serde(rename = "asset_type")]
    pub assetType: Label,

    /// If `true`, this asset counts as an impact (Starforged) or a debility
    /// (classic Ironsworn).
    #[serde(rename = "count_as_impact")]
    pub countAsImpact: bool,

    #[serde(rename = "id")]
    pub id: AssetId,

    #[serde(rename = "name")]
    pub name: Label,

    /// Most assets only benefit to their owner, but certain assets (like
    /// Starforged's module and command vehicle assets) are shared amongst the
    /// player's allies, too.
    #[serde(rename = "shared")]
    pub shared: bool,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "attachments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Box<AssetAttachment>>,

    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<Csscolor>>,

    /// Controls are condition meters, clocks, counters, and other asset input
    /// fields whose values are expected to change throughout the life of the
    /// asset.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetControlField>>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    /// Options are asset input fields which are set once, usually when the
    /// character takes the asset. The most common example is the "name" field
    /// on companion assets. A more complex example is the choice of a god's
    /// stat for the Devotant asset.
    #[serde(rename = "options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<Box<HashMap<String, AssetOptionField>>>,

    #[serde(rename = "requirement")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub requirement: Option<Box<MarkdownString>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

#[derive(Serialize, Deserialize)]
pub struct AssetAbility {
    /// Is this asset ability enabled?
    #[serde(rename = "enabled")]
    pub enabled: bool,

    #[serde(rename = "id")]
    pub id: AssetAbilityId,

    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// Fields whose values are expected to change over the life of the asset.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetAbilityControlField>>>,

    /// Changes made to the asset, when this ability is enabled.
    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    /// Describes changes made to various moves by this asset ability. Usually
    /// these require specific trigger conditions.
    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,

    /// Unique moves added by this asset ability.
    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<HashMap<String, Move>>>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<Box<Label>>,

    /// Fields that are expected to be set once and remain the same through the
    /// life of the asset.
    #[serde(rename = "options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub options: Option<Box<HashMap<String, AssetAbilityOptionField>>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetAbilityControlField {
    #[serde(rename = "checkbox")]
    Checkbox(AssetAbilityControlFieldCheckbox),

    #[serde(rename = "clock")]
    Clock(AssetAbilityControlFieldClock),

    #[serde(rename = "counter")]
    Counter(AssetAbilityControlFieldCounter),
}

#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldCheckbox {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    #[serde(rename = "id")]
    pub id: AssetAbilityControlFieldId,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    /// Is the box checked?
    #[serde(rename = "value")]
    pub value: bool,
}

/// A clock with 4, 6, 8, or 10 segments.
#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldClock {
    #[serde(rename = "id")]
    pub id: AssetAbilityControlFieldId,

    /// The size of the clock -- in other words, the maximum number of filled
    /// clock segments.
    #[serde(rename = "max")]
    pub max: u8,

    /// The minimum number of filled clock segments. This is always 0.
    #[serde(rename = "min")]
    pub min: u8,

    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    /// The current number of filled clock segments.
    #[serde(rename = "value")]
    pub value: i16,
}

/// A counter that starts at zero, with an optional maximum value.
#[derive(Serialize, Deserialize)]
pub struct AssetAbilityControlFieldCounter {
    #[serde(rename = "id")]
    pub id: AssetAbilityControlFieldId,

    #[serde(rename = "max")]
    pub max: Option<Box<i16>>,

    /// The (inclusive) minimum value.
    #[serde(rename = "min")]
    pub min: u8,

    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    /// The current value of this input.
    #[serde(rename = "value")]
    pub value: i16,
}

pub type AssetAbilityControlFieldId = String;

pub type AssetAbilityId = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetAbilityOptionField {
    #[serde(rename = "text")]
    Text(AssetAbilityOptionFieldText),
}

/// Represents an input that accepts plain text.
#[derive(Serialize, Deserialize)]
pub struct AssetAbilityOptionFieldText {
    #[serde(rename = "id")]
    pub id: AssetAbilityOptionFieldId,

    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "value")]
    pub value: Option<Box<String>>,
}

pub type AssetAbilityOptionFieldId = String;

/// Describes which assets can be attached to this asset. Example: Starforged's
/// Module assets, which can be equipped by Command Vehicle assets. See p. 55 of
/// Starforged for more info.
#[derive(Serialize, Deserialize)]
pub struct AssetAttachment {
    /// Asset IDs (which may be wildcards) that may be attached to this asset
    #[serde(rename = "assets")]
    pub assets: Vec<AssetIdwildcard>,

    #[serde(rename = "max")]
    pub max: Option<Box<i16>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetConditionMeterControlField {
    #[serde(rename = "card_flip")]
    CardFlip(AssetConditionMeterControlFieldCardFlip),

    #[serde(rename = "checkbox")]
    Checkbox(AssetConditionMeterControlFieldCheckbox),
}

#[derive(Serialize, Deserialize)]
pub struct AssetConditionMeterControlFieldCardFlip {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    #[serde(rename = "id")]
    pub id: AssetConditionMeterControlFieldId,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    /// Is the card flipped over?
    #[serde(rename = "value")]
    pub value: bool,
}

#[derive(Serialize, Deserialize)]
pub struct AssetConditionMeterControlFieldCheckbox {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    #[serde(rename = "id")]
    pub id: AssetConditionMeterControlFieldId,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    /// Is the box checked?
    #[serde(rename = "value")]
    pub value: bool,
}

pub type AssetConditionMeterControlFieldId = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetControlField {
    #[serde(rename = "card_flip")]
    CardFlip(AssetControlFieldCardFlip),

    #[serde(rename = "checkbox")]
    Checkbox(AssetControlFieldCheckbox),

    #[serde(rename = "condition_meter")]
    ConditionMeter(AssetControlFieldConditionMeter),

    #[serde(rename = "select_enhancement")]
    SelectEnhancement(AssetControlFieldSelectEnhancement),
}

#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldCardFlip {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    #[serde(rename = "id")]
    pub id: AssetControlFieldId,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    /// Is the card flipped over?
    #[serde(rename = "value")]
    pub value: bool,
}

#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldCheckbox {
    /// Does this field disable the asset when its value is set to `true`?
    #[serde(rename = "disables_asset")]
    pub disablesAsset: bool,

    #[serde(rename = "id")]
    pub id: AssetControlFieldId,

    /// Does this field count as an impact (Starforged) or debility (Ironsworn
    /// classic) when its value is set to `true`?
    #[serde(rename = "is_impact")]
    pub isImpact: bool,

    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    /// Is the box checked?
    #[serde(rename = "value")]
    pub value: bool,
}

/// Provides hints for moves that interact with this condition meter, such as
/// suffer and recovery moves.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldConditionMeterMoves {
    /// The ID(s) of recovery moves associated with this meter.
    #[serde(rename = "recover")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recover: Option<Box<Vec<MoveIdwildcard>>>,

    /// The ID(s) of suffer moves associated with the condition meter. If the
    /// suffer move makes an action roll, this condition meter value should be
    /// made available as a roll option.
    #[serde(rename = "suffer")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suffer: Option<Box<Vec<MoveIdwildcard>>>,
}

/// Some assets provide a special condition meter of their own. The most common
/// example is the health meters on companion assets. Asset condition meters
/// may also include their own controls, such as the checkboxes that Starforged
/// companion assets use to indicate they are "out of action".
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldConditionMeter {
    #[serde(rename = "id")]
    pub id: AssetControlFieldId,

    /// The maximum value of this meter.
    #[serde(rename = "max")]
    pub max: i16,

    /// The minimum value of this meter.
    #[serde(rename = "min")]
    pub min: u8,

    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    /// The current value of this meter.
    #[serde(rename = "value")]
    pub value: i16,

    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, AssetConditionMeterControlField>>>,

    /// Provides hints for moves that interact with this condition meter, such
    /// as suffer and recovery moves.
    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<AssetControlFieldConditionMeterMoves>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "option_type")]
pub enum AssetControlFieldSelectEnhancementChoice {
    #[serde(rename = "option")]
    Option(AssetControlFieldSelectEnhancementChoiceOption),

    #[serde(rename = "option_group")]
    OptionGroup(AssetControlFieldSelectEnhancementChoiceOptionGroup),
}

/// The current value of this input.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancementChoiceOptionValue {
    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancementChoiceOption {
    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    /// The current value of this input.
    #[serde(rename = "value")]
    pub value: AssetControlFieldSelectEnhancementChoiceOptionValue,

    /// Is this option currently selected?
    #[serde(rename = "selected")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected: Option<Box<bool>>,
}

#[derive(Serialize, Deserialize)]
pub enum AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionType {
    #[serde(rename = "option")]
    Option,
}

/// The current value of this input.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceValue {
    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancementChoiceOptionGroupChoice {
    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "option_type")]
    pub optionType: AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceOptionType,

    /// The current value of this input.
    #[serde(rename = "value")]
    pub value: AssetControlFieldSelectEnhancementChoiceOptionGroupChoiceValue,

    /// Is this option currently selected?
    #[serde(rename = "selected")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected: Option<Box<bool>>,
}

/// Represents a grouping of options in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancementChoiceOptionGroup {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetControlFieldSelectEnhancementChoiceOptionGroupChoice>,

    /// A label for this option group.
    #[serde(rename = "name")]
    pub name: Label,
}

/// Select from player and/or asset enhancements. Use it to describe modal
/// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
/// (Sundered Isles).
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldSelectEnhancement {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetControlFieldSelectEnhancementChoice>,

    #[serde(rename = "id")]
    pub id: AssetControlFieldId,

    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    /// The key of the currently selected choice from the `choices` property, or
    /// `null` if none is selected.
    #[serde(rename = "value")]
    pub value: Option<Box<DictKey>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetControlFieldEnhancement {
    #[serde(rename = "condition_meter")]
    ConditionMeter(AssetControlFieldEnhancementConditionMeter),
}

/// Some assets provide a special condition meter of their own. The most common
/// example is the health meters on companion assets. Asset condition meters
/// may also include their own controls, such as the checkboxes that Starforged
/// companion assets use to indicate they are "out of action".
#[derive(Serialize, Deserialize)]
pub struct AssetControlFieldEnhancementConditionMeter {
    /// The maximum value of this meter.
    #[serde(rename = "max")]
    pub max: i16,
}

pub type AssetControlFieldId = String;

pub type AssetControlFieldIdwildcard = String;

/// Describes enhancements made to this asset in a partial asset object. The
/// changes should be applied recursively; only the values that are specified
/// should be changed.
#[derive(Serialize, Deserialize)]
pub struct AssetEnhancement {
    #[serde(rename = "attachments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub attachments: Option<Box<AssetAttachment>>,

    /// Controls are condition meters, clocks, counters, and other asset input
    /// fields whose values are expected to change throughout the life of the
    /// asset.
    #[serde(rename = "controls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub controls: Option<Box<HashMap<String, HashMap<String, AssetControlFieldEnhancement>>>>,

    /// If `true`, this asset counts as an impact (Starforged) or a debility
    /// (classic Ironsworn).
    #[serde(rename = "count_as_impact")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub countAsImpact: Option<Box<bool>>,

    /// Most assets only benefit to their owner, but certain assets (like
    /// Starforged's module and command vehicle assets) are shared amongst the
    /// player's allies, too.
    #[serde(rename = "shared")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub shared: Option<Box<bool>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

pub type AssetId = String;

pub type AssetIdwildcard = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "field_type")]
pub enum AssetOptionField {
    #[serde(rename = "select_enhancement")]
    SelectEnhancement(AssetOptionFieldSelectEnhancement),

    #[serde(rename = "select_stat")]
    SelectStat(AssetOptionFieldSelectStat),

    #[serde(rename = "text")]
    Text(AssetOptionFieldText),
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "option_type")]
pub enum AssetOptionFieldSelectEnhancementChoice {
    #[serde(rename = "option")]
    Option(AssetOptionFieldSelectEnhancementChoiceOption),

    #[serde(rename = "option_group")]
    OptionGroup(AssetOptionFieldSelectEnhancementChoiceOptionGroup),
}

/// The current value of this input.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancementChoiceOptionValue {
    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancementChoiceOption {
    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    /// The current value of this input.
    #[serde(rename = "value")]
    pub value: AssetOptionFieldSelectEnhancementChoiceOptionValue,

    /// Is this option currently selected?
    #[serde(rename = "selected")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected: Option<Box<bool>>,
}

#[derive(Serialize, Deserialize)]
pub enum AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionType {
    #[serde(rename = "option")]
    Option,
}

/// The current value of this input.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceValue {
    #[serde(rename = "enhance_asset")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceAsset: Option<Box<AssetEnhancement>>,

    #[serde(rename = "enhance_moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhanceMoves: Option<Box<Vec<MoveEnhancement>>>,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancementChoiceOptionGroupChoice {
    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "option_type")]
    pub optionType: AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceOptionType,

    /// The current value of this input.
    #[serde(rename = "value")]
    pub value: AssetOptionFieldSelectEnhancementChoiceOptionGroupChoiceValue,

    /// Is this option currently selected?
    #[serde(rename = "selected")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected: Option<Box<bool>>,
}

/// Represents a grouping of options in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancementChoiceOptionGroup {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetOptionFieldSelectEnhancementChoiceOptionGroupChoice>,

    /// A label for this option group.
    #[serde(rename = "name")]
    pub name: Label,
}

/// Select from player and/or asset enhancements. Use it to describe modal
/// abilities. For examples, see Ironclad (classic Ironsworn) and Windbinder
/// (Sundered Isles).
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectEnhancement {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetOptionFieldSelectEnhancementChoice>,

    #[serde(rename = "id")]
    pub id: AssetOptionFieldId,

    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    /// The key of the currently selected choice from the `choices` property, or
    /// `null` if none is selected.
    #[serde(rename = "value")]
    pub value: Option<Box<DictKey>>,
}

#[derive(Serialize, Deserialize)]
#[serde(tag = "option_type")]
pub enum AssetOptionFieldSelectStatChoice {
    #[serde(rename = "option")]
    Option(AssetOptionFieldSelectStatChoiceOption),

    #[serde(rename = "option_group")]
    OptionGroup(AssetOptionFieldSelectStatChoiceOptionGroup),
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectStatChoiceOption {
    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    /// The current value of this input.
    #[serde(rename = "value")]
    pub value: PlayerStat,

    /// Is this option currently selected?
    #[serde(rename = "selected")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected: Option<Box<bool>>,
}

#[derive(Serialize, Deserialize)]
pub enum AssetOptionFieldSelectStatChoiceOptionGroupChoiceOptionType {
    #[serde(rename = "option")]
    Option,
}

/// Represents an option in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectStatChoiceOptionGroupChoice {
    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "option_type")]
    pub optionType: AssetOptionFieldSelectStatChoiceOptionGroupChoiceOptionType,

    /// The current value of this input.
    #[serde(rename = "value")]
    pub value: PlayerStat,

    /// Is this option currently selected?
    #[serde(rename = "selected")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub selected: Option<Box<bool>>,
}

/// Represents a grouping of options in a list of choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectStatChoiceOptionGroup {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetOptionFieldSelectStatChoiceOptionGroupChoice>,

    /// A label for this option group.
    #[serde(rename = "name")]
    pub name: Label,
}

/// Represents a list of mutually exclusive choices.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldSelectStat {
    #[serde(rename = "choices")]
    pub choices: HashMap<String, AssetOptionFieldSelectStatChoice>,

    #[serde(rename = "id")]
    pub id: AssetOptionFieldId,

    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    /// The key of the currently selected choice from the `choices` property, or
    /// `null` if none is selected.
    #[serde(rename = "value")]
    pub value: Option<Box<DictKey>>,
}

/// Represents an input that accepts plain text.
#[derive(Serialize, Deserialize)]
pub struct AssetOptionFieldText {
    #[serde(rename = "id")]
    pub id: AssetOptionFieldId,

    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "value")]
    pub value: Option<Box<String>>,
}

pub type AssetOptionFieldId = String;

pub type AssetOptionFieldIdwildcard = String;

#[derive(Serialize, Deserialize)]
pub struct AssetType {
    #[serde(rename = "id")]
    pub id: String,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<Csscolor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, Asset>>>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<AssetTypeId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpimageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<AssetTypeId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

pub type AssetTypeId = String;

#[derive(Serialize, Deserialize)]
pub struct Atlas {
    #[serde(rename = "id")]
    pub id: String,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "collections")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collections: Option<Box<HashMap<String, Atlas>>>,

    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<Csscolor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, AtlasEntry>>>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<AtlasId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpimageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<AtlasId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

/// An atlas entry, like the Ironlands region entries found in classic
/// Ironsworn.
#[derive(Serialize, Deserialize)]
pub struct AtlasEntry {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "features")]
    pub features: Vec<MarkdownString>,

    #[serde(rename = "id")]
    pub id: AtlasEntryId,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "quest_starter")]
    pub questStarter: MarkdownString,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "your_truth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub yourTruth: Option<Box<MarkdownString>>,
}

pub type AtlasEntryId = String;

pub type AtlasEntryIdwildcard = String;

pub type AtlasId = String;

pub type AtlasIdwildcard = String;

/// A CSS color value. See: https://developer.mozilla.org/en-
/// US/docs/Web/CSS/color_value
pub type Csscolor = String;

/// Challenge rank, represented as an integer:
pub type ChallengeRank = u8;

#[derive(Serialize, Deserialize)]
pub struct ConditionMeterRule {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    /// The maximum value of this meter.
    #[serde(rename = "max")]
    pub max: i16,

    /// The minimum value of this meter.
    #[serde(rename = "min")]
    pub min: i16,

    /// A label for this input. In some contexts it may be undesirable to render
    /// this text, but it should always be exposed to assistive technology (e.g.
    /// with `aria-label` in HTML).
    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "shared")]
    pub shared: bool,
}

pub type ConditionMeterRuleId = String;

/// Describes game rules compatible with the Ironsworn tabletop role-playing
/// game by Shawn Tomkin.
#[derive(Serialize, Deserialize)]
pub struct DataswornRoot {
    #[serde(rename = "id")]
    pub id: NamespaceId,

    #[serde(rename = "source")]
    pub source: Source,

    /// A dictionary object containing asset types, which contain assets.
    #[serde(rename = "assets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assets: Option<Box<HashMap<String, AssetType>>>,

    /// A dictionary object containing atlas collections, which contain atlas
    /// entries.
    #[serde(rename = "atlas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atlas: Option<Box<HashMap<String, Atlas>>>,

    /// A dictionary object of delve sites, like the premade delve sites
    /// presented in Ironsworn: Delve
    #[serde(rename = "delve_sites")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delveSites: Option<Box<HashMap<String, DelveSite>>>,

    /// A dictionary object containing move categories, which contain moves.
    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<HashMap<String, MoveCategory>>>,

    /// A dictionary object containing NPC collections, which contain NPCs.
    #[serde(rename = "npcs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npcs: Option<Box<HashMap<String, NpcCollection>>>,

    /// A dictionary object containing oracle collections, which may contain
    /// oracle tables and/or oracle collections.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<HashMap<String, OracleCollection>>>,

    /// A dictionary object containing rarities, like those presented in
    /// Ironsworn: Delve.
    #[serde(rename = "rarities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rarities: Option<Box<HashMap<String, Rarity>>>,

    #[serde(rename = "rules")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rules: Option<Box<Rules>>,

    /// A dictionary object containing delve site domains.
    #[serde(rename = "site_domains")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteDomains: Option<Box<HashMap<String, DelveSiteDomain>>>,

    /// A dictionary object containing delve site themes.
    #[serde(rename = "site_themes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteThemes: Option<Box<HashMap<String, DelveSiteTheme>>>,

    /// A dictionary object of truth categories.
    #[serde(rename = "truths")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub truths: Option<Box<HashMap<String, Truth>>>,
}

/// A delve site with a theme, domain, and denizen table.
#[derive(Serialize, Deserialize)]
pub struct DelveSite {
    #[serde(rename = "denizens")]
    pub denizens: Vec<DelveSiteDenizen>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "domain")]
    pub domain: DelveSiteDomainId,

    #[serde(rename = "id")]
    pub id: DelveSiteId,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "rank")]
    pub rank: ChallengeRank,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "theme")]
    pub theme: DelveSiteThemeId,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// An additional theme or domain card ID, for use with optional rules in
    /// Ironsworn: Delve.
    #[serde(rename = "extra_card")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub extraCard: Option<Box<String>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    /// The ID of an atlas entry representing the region in which this delve
    /// site is located.
    #[serde(rename = "region")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub region: Option<Box<AtlasEntryId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

#[derive(Serialize, Deserialize)]
pub struct DelveSiteDenizen {
    #[serde(rename = "frequency")]
    pub frequency: DelveSiteDenizenFrequency,

    #[serde(rename = "id")]
    pub id: DelveSiteDenizenId,

    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<Box<Label>>,

    /// The ID of the relevant NPC entry, if one is specified.
    #[serde(rename = "npc")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npc: Option<Box<NpcId>>,
}

#[derive(Serialize, Deserialize)]
pub enum DelveSiteDenizenFrequency {
    #[serde(rename = "common")]
    Common,

    #[serde(rename = "rare")]
    Rare,

    #[serde(rename = "uncommon")]
    Uncommon,

    #[serde(rename = "unforeseen")]
    Unforeseen,

    #[serde(rename = "very_common")]
    VeryCommon,
}

pub type DelveSiteDenizenId = String;

#[derive(Serialize, Deserialize)]
pub struct DelveSiteDomain {}

#[derive(Serialize, Deserialize)]
pub struct DelveSiteDomainDangerRow {
    #[serde(rename = "id")]
    pub id: DomainDangerRowId,

    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,

    #[serde(rename = "result")]
    pub result: MarkdownString,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleTableId>>,

    #[serde(rename = "i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    #[serde(rename = "rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rolls: Option<Box<Vec<OracleTableRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

#[derive(Serialize, Deserialize)]
pub struct DelveSiteDomainFeatureRow {
    #[serde(rename = "id")]
    pub id: DomainFeatureRowId,

    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,

    #[serde(rename = "result")]
    pub result: MarkdownString,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleTableId>>,

    #[serde(rename = "i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    #[serde(rename = "rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rolls: Option<Box<Vec<OracleTableRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

pub type DelveSiteDomainId = String;

pub type DelveSiteId = String;

#[derive(Serialize, Deserialize)]
pub enum DelveSiteThemeCardType {
    #[serde(rename = "theme")]
    Theme,
}

#[derive(Serialize, Deserialize)]
pub struct DelveSiteTheme {
    #[serde(rename = "card_type")]
    pub cardType: DelveSiteThemeCardType,

    #[serde(rename = "dangers")]
    pub dangers: Vec<DelveSiteThemeDangerRow>,

    #[serde(rename = "features")]
    pub features: Vec<DelveSiteThemeFeatureRow>,

    #[serde(rename = "id")]
    pub id: DelveSiteThemeId,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "summary")]
    pub summary: MarkdownString,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

#[derive(Serialize, Deserialize)]
pub struct DelveSiteThemeDangerRow {
    #[serde(rename = "id")]
    pub id: ThemeDangerRowId,

    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,

    #[serde(rename = "result")]
    pub result: MarkdownString,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleTableId>>,

    #[serde(rename = "i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    #[serde(rename = "rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rolls: Option<Box<Vec<OracleTableRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

#[derive(Serialize, Deserialize)]
pub struct DelveSiteThemeFeatureRow {
    #[serde(rename = "id")]
    pub id: ThemeFeatureRowId,

    #[serde(rename = "max")]
    pub max: i16,

    #[serde(rename = "min")]
    pub min: i16,

    #[serde(rename = "result")]
    pub result: MarkdownString,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleTableId>>,

    #[serde(rename = "i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    #[serde(rename = "rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rolls: Option<Box<Vec<OracleTableRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

pub type DelveSiteThemeId = String;

pub type DiceNotation = String;

pub type DictKey = String;

pub type DomainDangerRowId = String;

pub type DomainFeatureRowId = String;

#[derive(Serialize, Deserialize)]
pub struct I18nHint {
    #[serde(rename = "part_of_speech")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partOfSpeech: Option<Box<PartOfSpeech>>,
}

#[derive(Serialize, Deserialize)]
pub struct I18nHintsTemplate {
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<I18nHint>>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<Box<I18nHint>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<I18nHint>>,
}

#[derive(Serialize, Deserialize)]
pub struct I18nHints {
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<I18nHint>>,

    #[serde(rename = "result")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<Box<I18nHint>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<I18nHint>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<I18nHintsTemplate>>,
}

#[derive(Serialize, Deserialize)]
pub struct ImpactCategory {
    #[serde(rename = "contents")]
    pub contents: HashMap<String, ImpactRule>,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "name")]
    pub name: Label,
}

#[derive(Serialize, Deserialize)]
pub struct ImpactRule {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "permanent")]
    pub permanent: bool,

    #[serde(rename = "prevents_recovery")]
    pub preventsRecovery: Vec<DictKey>,

    #[serde(rename = "shared")]
    pub shared: bool,
}

pub type ImpactRuleCollectionId = String;

pub type ImpactRuleId = String;

/// A localized plain text name or label.
pub type Label = String;

/// Localized text, formatted in Markdown.
/// 
/// It uses some custom syntax; e.g. `{{table:some_oracle_table_id}}` indicates
/// that the referenced oracle table is rendered there part of the source
/// material.
pub type MarkdownString = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "roll_type")]
pub enum Move {
    #[serde(rename = "action_roll")]
    ActionRoll(MoveActionRoll),

    #[serde(rename = "no_roll")]
    NoRoll(MoveNoRoll),

    #[serde(rename = "progress_roll")]
    ProgressRoll(MoveProgressRoll),

    #[serde(rename = "special_track")]
    SpecialTrack(MoveSpecialTrack),
}

/// A move that makes an action roll.
#[derive(Serialize, Deserialize)]
pub struct MoveActionRoll {
    #[serde(rename = "id")]
    pub id: MoveId,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    #[serde(rename = "source")]
    pub source: Source,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "trigger")]
    pub trigger: TriggerActionRoll,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// Oracles associated with this move. It's not recommended to roll these
    /// automatically, as almost all moves present them as an option, not
    /// a requirement.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<OracleTableId>>>,

    /// Indicates that this move replaces the identified move. References to the
    /// replaced move can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<MoveId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveNoRoll {
    #[serde(rename = "id")]
    pub id: MoveId,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "trigger")]
    pub trigger: TriggerNoRoll,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// Oracles associated with this move. It's not recommended to roll these
    /// automatically, as almost all moves present them as an option, not
    /// a requirement.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<OracleTableId>>>,

    /// Indicates that this move replaces the identified move. References to the
    /// replaced move can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<MoveId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

/// A progress move that rolls on a standard progress track type (defined by the
/// move object).
#[derive(Serialize, Deserialize)]
pub struct MoveProgressRoll {
    #[serde(rename = "id")]
    pub id: MoveId,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    #[serde(rename = "source")]
    pub source: Source,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    /// A category label for progress tracks associated with this move.
    #[serde(rename = "track_label")]
    pub trackLabel: Label,

    #[serde(rename = "trigger")]
    pub trigger: TriggerProgressRoll,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// Oracles associated with this move. It's not recommended to roll these
    /// automatically, as almost all moves present them as an option, not
    /// a requirement.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<OracleTableId>>>,

    /// Indicates that this move replaces the identified move. References to the
    /// replaced move can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<MoveId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveSpecialTrack {
    #[serde(rename = "id")]
    pub id: MoveId,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "outcomes")]
    pub outcomes: MoveOutcomes,

    #[serde(rename = "source")]
    pub source: Source,

    /// The complete rules text of the move.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "trigger")]
    pub trigger: TriggerSpecialTrack,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// Oracles associated with this move. It's not recommended to roll these
    /// automatically, as almost all moves present them as an option, not
    /// a requirement.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<OracleTableId>>>,

    /// Indicates that this move replaces the identified move. References to the
    /// replaced move can be considered equivalent to this move.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<MoveId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveCategory {
    #[serde(rename = "id")]
    pub id: String,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<Csscolor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, Move>>>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<MoveCategoryId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpimageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<MoveCategoryId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

pub type MoveCategoryId = String;

#[derive(Serialize, Deserialize)]
#[serde(tag = "roll_type")]
pub enum MoveEnhancement {
    #[serde(rename = "action_roll")]
    ActionRoll(MoveEnhancementActionRoll),

    #[serde(rename = "no_roll")]
    NoRoll(MoveEnhancementNoRoll),

    #[serde(rename = "progress_roll")]
    ProgressRoll(MoveEnhancementProgressRoll),

    #[serde(rename = "special_track")]
    SpecialTrack(MoveEnhancementSpecialTrack),
}

#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementActionRollTrigger {
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerActionRollConditionEnhancement>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementActionRoll {
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<MoveIdwildcard>>>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<MoveEnhancementActionRollTrigger>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementNoRollTrigger {
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerNoRollCondition>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementNoRoll {
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<MoveIdwildcard>>>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<MoveEnhancementNoRollTrigger>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementProgressRollTrigger {
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerProgressRollConditionEnhancement>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementProgressRoll {
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<MoveIdwildcard>>>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<MoveEnhancementProgressRollTrigger>>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementSpecialTrackTrigger {
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerSpecialTrackConditionEnhancement>,
}

#[derive(Serialize, Deserialize)]
pub struct MoveEnhancementSpecialTrack {
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<Vec<MoveIdwildcard>>>,

    #[serde(rename = "trigger")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trigger: Option<Box<MoveEnhancementSpecialTrackTrigger>>,
}

/// A move ID, for a standard move or a unique asset move
pub type MoveId = String;

/// A move ID with wildcards
pub type MoveIdwildcard = String;

#[derive(Serialize, Deserialize)]
pub struct MoveOutcome {
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub enum MoveOutcomeType {
    #[serde(rename = "miss")]
    Miss,

    #[serde(rename = "strong_hit")]
    StrongHit,

    #[serde(rename = "weak_hit")]
    WeakHit,
}

/// A standalone localized description for each move outcome (miss, weak hit,
/// or strong hit). This is for for e.g. VTT implementations, where it's often
/// useful to display only the rules text relevant to a roll result.
/// 
///   This often requires light editorialization to create text that can stand
/// alone without reference to the rest of the move. For example, 'as above'
/// (in reference to another move outcome) shouldn't be used here; instead, the
/// relevant text should be repeated.
#[derive(Serialize, Deserialize)]
pub struct MoveOutcomes {
    #[serde(rename = "miss")]
    pub miss: MoveOutcome,

    #[serde(rename = "strong_hit")]
    pub strongHit: MoveOutcome,

    #[serde(rename = "weak_hit")]
    pub weakHit: MoveOutcome,
}

#[derive(Serialize, Deserialize)]
pub enum MoveRollType {
    #[serde(rename = "action_roll")]
    ActionRoll,

    #[serde(rename = "no_roll")]
    NoRoll,

    #[serde(rename = "progress_roll")]
    ProgressRoll,

    #[serde(rename = "special_track")]
    SpecialTrack,
}

pub type NamespaceId = String;

/// A non-player character entry, similar to those in Chapter 5 of the Ironsworn
/// Rulebook, or Chapter 4 of Starforged.
#[derive(Serialize, Deserialize)]
pub struct Npc {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "drives")]
    pub drives: Vec<MarkdownString>,

    #[serde(rename = "features")]
    pub features: Vec<MarkdownString>,

    #[serde(rename = "id")]
    pub id: NpcId,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "nature")]
    pub nature: NpcNature,

    #[serde(rename = "quest_starter")]
    pub questStarter: MarkdownString,

    #[serde(rename = "rank")]
    pub rank: ChallengeRank,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "tactics")]
    pub tactics: Vec<MarkdownString>,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "variants")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub variants: Option<Box<HashMap<String, NpcVariant>>>,

    #[serde(rename = "your_truth")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub yourTruth: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct NpcCollection {
    #[serde(rename = "id")]
    pub id: String,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<Csscolor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, Npc>>>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<NpcCollectionId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpimageUrl>>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<NpcCollectionId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

pub type NpcCollectionId = String;

pub type NpcId = String;

pub type NpcIdwildcard = String;

/// A localized category label describing the nature of this NPC.
/// 
/// In Ironsworn classic, this is probably the singular form of the parent
/// collection's name.
/// 
/// For Starforged, see the table on p. 258 for examples.
pub type NpcNature = Label;

#[derive(Serialize, Deserialize)]
pub struct NpcVariant {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "id")]
    pub id: NpcVariantId,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "nature")]
    pub nature: NpcNature,

    #[serde(rename = "rank")]
    pub rank: ChallengeRank,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

pub type NpcVariantId = String;

#[derive(Serialize, Deserialize)]
pub struct OracleCollectionRendering0 {
    #[serde(rename = "columns")]
    pub columns: HashMap<String, OracleCollectionTableColumn>,

    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<Csscolor>>,

    #[serde(rename = "table_style")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tableStyle: Option<Box<OracleCollectionStyle>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleCollection {
    #[serde(rename = "id")]
    pub id: String,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "collections")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub collections: Option<Box<HashMap<String, OracleCollection>>>,

    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<Csscolor>>,

    #[serde(rename = "contents")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contents: Option<Box<HashMap<String, OracleTable>>>,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    /// This collection's content enhances the identified collection, rather
    /// than being a standalone collection of its own.
    #[serde(rename = "enhances")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enhances: Option<Box<OracleCollectionId>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpimageUrl>>>,

    #[serde(rename = "rendering")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rendering: Option<Box<OracleCollectionRendering0>>,

    /// This collection replaces the identified collection. References to the
    /// replaced collection can be considered equivalent to this collection.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<OracleCollectionId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

pub type OracleCollectionId = String;

#[derive(Serialize, Deserialize)]
pub struct OracleCollectionRendering {
    #[serde(rename = "columns")]
    pub columns: HashMap<String, OracleCollectionTableColumn>,

    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<Csscolor>>,

    #[serde(rename = "table_style")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tableStyle: Option<Box<OracleCollectionStyle>>,
}

#[derive(Serialize, Deserialize)]
pub enum OracleCollectionStyle {
    #[serde(rename = "multi_table")]
    MultiTable,
}

/// The value(s) from each OracleTableRow that is rendered in this column.
#[derive(Serialize, Deserialize)]
pub enum OracleCollectionTableColumnContentType {
    #[serde(rename = "description")]
    Description,

    #[serde(rename = "result")]
    Result,

    #[serde(rename = "roll")]
    Roll,

    #[serde(rename = "summary")]
    Summary,
}

#[derive(Serialize, Deserialize)]
pub struct OracleCollectionTableColumn {
    /// The value(s) from each OracleTableRow that is rendered in this column.
    #[serde(rename = "content_type")]
    pub contentType: OracleCollectionTableColumnContentType,

    /// The key of the OracleTable (within this collection), whose data is used
    /// to render this column.
    #[serde(rename = "table_key")]
    pub tableKey: DictKey,

    /// The thematic color for this column.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<Csscolor>>,

    /// The table column's header text.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<Box<Label>>,
}

/// Provides string templates that may be used in place of the static
/// row text from `OracleTableRow#result`, `OracleTableRow#summary`, and
/// `OracleTableRow#description`.
/// 
///   These strings are formatted in Markdown, but use a special syntax
/// for their placeholders: `{{result:some_oracle_table_id}}`. The
/// placeholder should be replaced with the value of a rolled (or selected)
/// `OracleTableRow#result` from the target oracle table ID.
#[derive(Serialize, Deserialize)]
pub struct OracleRollTemplate {
    /// A string template that may be used in place of
    /// OracleTableRow#description.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<TemplateString>>,

    /// A string template that may be used in place of OracleTableRow#result.
    #[serde(rename = "result")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<Box<TemplateString>>,

    /// A string template that may be used in place of OracleTableRow#summary.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<TemplateString>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTable {
    #[serde(rename = "dice")]
    pub dice: DiceNotation,

    #[serde(rename = "id")]
    pub id: OracleTableId,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "table")]
    pub table: Vec<OracleTableRow>,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    /// A longer description of the oracle table's intended usage, which might
    /// include multiple paragraphs. If it's only a couple sentences, use the
    /// `summary` key instead.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    #[serde(rename = "images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Box<Vec<WebpimageUrl>>>,

    #[serde(rename = "match")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub match_: Option<Box<OracleTableMatchBehavior>>,

    #[serde(rename = "rendering")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rendering: Option<Box<OracleTableRendering>>,

    /// Indicates that this table replaces the identified table. References to
    /// the replaced table can be considered equivalent to this table.
    #[serde(rename = "replaces")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub replaces: Option<Box<OracleTableId>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    /// A brief summary of the oracle table's intended usage, no more than a few
    /// sentences in length. This is intended for use in application tooltips
    /// and similar sorts of hints. Longer text should use the "description"
    /// key instead.
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

/// The value(s) from each OracleTableRow that is rendered in this column.
#[derive(Serialize, Deserialize)]
pub enum OracleTableColumnContentType {
    #[serde(rename = "description")]
    Description,

    #[serde(rename = "result")]
    Result,

    #[serde(rename = "roll")]
    Roll,

    #[serde(rename = "summary")]
    Summary,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableColumn {
    /// The value(s) from each OracleTableRow that is rendered in this column.
    #[serde(rename = "content_type")]
    pub contentType: OracleTableColumnContentType,

    /// The thematic color for this column.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub color: Option<Box<Csscolor>>,

    /// The table column's header text.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<Box<Label>>,
}

/// The value(s) from each OracleTableRow that is rendered in this column.
#[derive(Serialize, Deserialize)]
pub enum OracleTableColumnContentKey {
    #[serde(rename = "description")]
    Description,

    #[serde(rename = "result")]
    Result,

    #[serde(rename = "roll")]
    Roll,

    #[serde(rename = "summary")]
    Summary,
}

pub type OracleTableId = String;

/// Oracle table wildcards can also use '**' to represent any
/// number of collection levels in the oracle tree. For example,
/// 'starforged/oracles/**/location' represents any starforged table with the
/// "location" key.
pub type OracleTableIdwildcard = String;

#[derive(Serialize, Deserialize)]
pub struct OracleTableMatchBehavior {
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableRendering {
    #[serde(rename = "columns")]
    pub columns: HashMap<String, OracleTableColumn>,

    #[serde(rename = "table_style")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tableStyle: Option<Box<OracleTableStyle>>,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableRoll {
    #[serde(rename = "times")]
    pub times: i16,

    /// The rulebook explicitly cautions *against* rolling all details at once,
    /// so rolling every referenced oracle automatically is not recommended.
    /// That said, some oracle results only provide useful information once
    /// a secondary roll occurs, such as "Action + Theme". If this value is
    /// omitted, assume it's false.
    #[serde(rename = "auto")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auto: Option<Box<bool>>,

    #[serde(rename = "method")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub method: Option<Box<OracleTableRollMethod>>,

    /// The ID of the oracle table to be rolled. If omitted, it defaults to the
    /// ID of this oracle table.
    #[serde(rename = "oracle")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracle: Option<Box<OracleTableId>>,
}

/// Special roll instructions to use when rolling multiple times on a single
/// oracle table.
#[derive(Serialize, Deserialize)]
pub enum OracleTableRollMethod {
    #[serde(rename = "keep_duplicates")]
    KeepDuplicates,

    #[serde(rename = "make_it_worse")]
    MakeItWorse,

    #[serde(rename = "no_duplicates")]
    NoDuplicates,
}

#[derive(Serialize, Deserialize)]
pub struct OracleTableRow {
    #[serde(rename = "id")]
    pub id: OracleTableRowId,

    #[serde(rename = "max")]
    pub max: Option<Box<i16>>,

    #[serde(rename = "min")]
    pub min: Option<Box<i16>>,

    #[serde(rename = "result")]
    pub result: MarkdownString,

    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Box<MarkdownString>>,

    #[serde(rename = "embed_table")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub embedTable: Option<Box<OracleTableId>>,

    #[serde(rename = "i18n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub i18n: Option<Box<I18nHints>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    #[serde(rename = "rolls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rolls: Option<Box<Vec<OracleTableRoll>>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,

    #[serde(rename = "template")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template: Option<Box<OracleRollTemplate>>,
}

/// Normally, rows will end with two numbers separated by a dash, indicating
/// their dice range.
/// 
/// Rows with a single number represent unrollable rows that are sometimes
/// included for rendering purposes; in this case, the number represents the
/// row's index.
pub type OracleTableRowId = String;

#[derive(Serialize, Deserialize)]
pub enum OracleTableStyle {
    #[serde(rename = "embed_as_column")]
    EmbedAsColumn,

    #[serde(rename = "embed_in_row")]
    EmbedInRow,

    #[serde(rename = "standalone_table")]
    StandaloneTable,
}

#[derive(Serialize, Deserialize)]
pub enum PartOfSpeech {
    #[serde(rename = "adjective")]
    Adjective,

    #[serde(rename = "adjunct_common_noun")]
    AdjunctCommonNoun,

    #[serde(rename = "adjunct_proper_noun")]
    AdjunctProperNoun,

    #[serde(rename = "attributive_verb")]
    AttributiveVerb,

    #[serde(rename = "common_noun")]
    CommonNoun,

    #[serde(rename = "gerund")]
    Gerund,

    #[serde(rename = "proper_noun")]
    ProperNoun,

    #[serde(rename = "verb")]
    Verb,
}

/// A basic, rollable player character resource.
pub type PlayerConditionMeter = DictKey;

/// A basic player character stat.
pub type PlayerStat = DictKey;

#[derive(Serialize, Deserialize)]
pub enum ProgressRollMethod {
    #[serde(rename = "miss")]
    Miss,

    #[serde(rename = "progress_roll")]
    ProgressRoll,

    #[serde(rename = "strong_hit")]
    StrongHit,

    #[serde(rename = "weak_hit")]
    WeakHit,
}

#[derive(Serialize, Deserialize)]
pub enum ProgressRollOptionUsing {
    #[serde(rename = "progress_track")]
    ProgressTrack,
}

#[derive(Serialize, Deserialize)]
pub struct ProgressRollOption {
    #[serde(rename = "using")]
    pub using: ProgressRollOptionUsing,
}

/// A rarity, as described in Ironsworn: Delve.
#[derive(Serialize, Deserialize)]
pub struct Rarity {
    /// The asset augmented by this rarity.
    #[serde(rename = "asset")]
    pub asset: AssetId,

    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "id")]
    pub id: RarityId,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "source")]
    pub source: Source,

    /// From Ironsworn: Delve, p. 174:
    /// 
    ///       Some assets will bring a rarity into play more often than others,
    /// so the experience point cost for a rarity will vary by the linked asset.
    /// These costs are shown in the tables on page 175.
    /// 
    ///       If you are playing solo, and aren’t concerned with the relative
    /// balance of rarity abilities, you can ignore these variable costs. If so,
    /// spend 3 experience points to purchase a rarity.
    #[serde(rename = "xp_cost")]
    pub xpCost: i16,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

pub type RarityId = String;

#[derive(Serialize, Deserialize)]
pub struct Rules {
    #[serde(rename = "condition_meters")]
    pub conditionMeters: HashMap<String, ConditionMeterRule>,

    #[serde(rename = "impacts")]
    pub impacts: HashMap<String, ImpactCategory>,

    #[serde(rename = "special_tracks")]
    pub specialTracks: HashMap<String, SpecialTrackRule>,

    #[serde(rename = "stats")]
    pub stats: HashMap<String, StatRule>,
}

/// Describes game rules compatible with the Ironsworn tabletop role-playing
/// game by Shawn Tomkin.
#[derive(Serialize, Deserialize)]
pub struct Ruleset {
    #[serde(rename = "id")]
    pub id: NamespaceId,

    #[serde(rename = "source")]
    pub source: Source,

    /// A dictionary object containing asset types, which contain assets.
    #[serde(rename = "assets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assets: Option<Box<HashMap<String, AssetType>>>,

    /// A dictionary object containing atlas collections, which contain atlas
    /// entries.
    #[serde(rename = "atlas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atlas: Option<Box<HashMap<String, Atlas>>>,

    /// A dictionary object of delve sites, like the premade delve sites
    /// presented in Ironsworn: Delve
    #[serde(rename = "delve_sites")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delveSites: Option<Box<HashMap<String, DelveSite>>>,

    /// A dictionary object containing move categories, which contain moves.
    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<HashMap<String, MoveCategory>>>,

    /// A dictionary object containing NPC collections, which contain NPCs.
    #[serde(rename = "npcs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npcs: Option<Box<HashMap<String, NpcCollection>>>,

    /// A dictionary object containing oracle collections, which may contain
    /// oracle tables and/or oracle collections.
    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<HashMap<String, OracleCollection>>>,

    /// A dictionary object containing rarities, like those presented in
    /// Ironsworn: Delve.
    #[serde(rename = "rarities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rarities: Option<Box<HashMap<String, Rarity>>>,

    #[serde(rename = "rules")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rules: Option<Box<Rules>>,

    /// A dictionary object containing delve site domains.
    #[serde(rename = "site_domains")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteDomains: Option<Box<HashMap<String, DelveSiteDomain>>>,

    /// A dictionary object containing delve site themes.
    #[serde(rename = "site_themes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteThemes: Option<Box<HashMap<String, DelveSiteTheme>>>,

    /// A dictionary object of truth categories.
    #[serde(rename = "truths")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub truths: Option<Box<HashMap<String, Truth>>>,
}

/// A relative URL pointing to a vector image in the SVG format.
pub type SvgimageUrl = String;

#[derive(Serialize, Deserialize)]
pub struct SourceAuthor {
    #[serde(rename = "name")]
    pub name: String,

    /// An optional email contact for the author
    #[serde(rename = "email")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub email: Option<Box<String>>,
}

/// Metadata describing the original source of this item
#[derive(Serialize, Deserialize)]
pub struct Source {
    #[serde(rename = "authors")]
    pub authors: Vec<SourceAuthor>,

    /// The date of the source documents's last update, formatted YYYY-MM-DD.
    /// Required because it's used to determine whether the data needs updating.
    #[serde(rename = "date")]
    pub date: String,

    #[serde(rename = "license")]
    pub license: Option<Box<String>>,

    /// The title of the source document.
    #[serde(rename = "title")]
    pub title: String,

    /// An absolute URL where the source document is available.
    #[serde(rename = "url")]
    pub url: String,

    #[serde(rename = "page")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page: Option<Box<i16>>,
}

#[derive(Serialize, Deserialize)]
pub enum SpecialTrackRollMethod {
    #[serde(rename = "all")]
    All,

    #[serde(rename = "highest")]
    Highest,

    #[serde(rename = "lowest")]
    Lowest,

    #[serde(rename = "miss")]
    Miss,

    #[serde(rename = "player_choice")]
    PlayerChoice,

    #[serde(rename = "strong_hit")]
    StrongHit,

    #[serde(rename = "weak_hit")]
    WeakHit,
}

#[derive(Serialize, Deserialize)]
pub struct SpecialTrackRule {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "optional")]
    pub optional: bool,

    #[serde(rename = "shared")]
    pub shared: bool,
}

pub type SpecialTrackRuleId = String;

/// Special, ruleset-specific progress tracks. Usually, one exists per player
/// character, and they persist through the life of the player character.
/// 'Canonical' examples:
///   * `bonds_track`, described in the Ironsworn Rulebook. For the Starforged
/// legacy track, use `bonds_legacy` instead.
///   * `failure_track`, described in Ironsworn: Delve
///   * `quests_legacy`, `bonds_legacy`, and `discoveries_legacy`, described
/// Ironsworn: Starforged
/// 
pub type SpecialTrackType = DictKey;

#[derive(Serialize, Deserialize)]
pub struct StatRule {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "name")]
    pub name: Label,
}

pub type StatRuleId = String;

#[derive(Serialize, Deserialize)]
pub struct Suggestions {
    #[serde(rename = "assets")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assets: Option<Box<Vec<AssetId>>>,

    #[serde(rename = "atlas")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub atlas: Option<Box<Vec<AtlasEntryId>>>,

    #[serde(rename = "moves")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub moves: Option<Box<Vec<MoveId>>>,

    #[serde(rename = "npcs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub npcs: Option<Box<Vec<NpcId>>>,

    #[serde(rename = "oracles")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub oracles: Option<Box<Vec<OracleTableId>>>,

    #[serde(rename = "site_domains")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteDomains: Option<Box<Vec<DelveSiteDomainId>>>,

    #[serde(rename = "site_themes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub siteThemes: Option<Box<Vec<DelveSiteThemeId>>>,
}

/// A rich text string in Markdown with replaced values from oracle roll
/// results.
/// 
/// The custom syntax `{{some_row_key:some_oracle_table_id}}` should be replaced
/// by the `some_row_key` string of a rolled oracle table. This is usually the
/// `result` key, for example `{{result:starforged/oracles/core/action}}`
pub type TemplateString = String;

pub type ThemeDangerRowId = String;

pub type ThemeFeatureRowId = String;

#[derive(Serialize, Deserialize)]
pub struct TriggerActionRoll {
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerActionRollCondition>,

    /// A markdown string of the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be available for individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerActionRollCondition {
    #[serde(rename = "method")]
    pub method: ActionRollMethod,

    /// The options available when rolling with this trigger.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<ActionRollOption>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerActionRollConditionEnhancement {
    #[serde(rename = "method")]
    pub method: Option<Box<ActionRollMethod>>,

    /// The options available when rolling with this trigger.
    #[serde(rename = "roll_options")]
    pub rollOptions: Option<Box<Vec<ActionRollOption>>>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerActionRollEnhancement {
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerActionRollConditionEnhancement>,
}

/// Information on who can trigger this trigger condition. Usually this is just
/// the player, but some asset abilities can trigger from an ally's move.
#[derive(Serialize, Deserialize)]
pub struct TriggerBy {
    #[serde(rename = "ally")]
    pub ally: bool,

    #[serde(rename = "player")]
    pub player: bool,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerNoRoll {
    /// A markdown string of the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be available for individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,

    #[serde(rename = "conditions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Box<Vec<TriggerNoRollCondition>>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerNoRollCondition {
    #[serde(rename = "method")]
    pub method: Option<Value>,

    #[serde(rename = "roll_options")]
    pub rollOptions: Option<Value>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerNoRollEnhancement {
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerNoRollCondition>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRoll {
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerProgressRollCondition>,

    /// A markdown string of the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be available for individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRollCondition {
    #[serde(rename = "method")]
    pub method: ProgressRollMethod,

    /// The options available when rolling with this trigger.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<ProgressRollOption>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRollConditionEnhancement {
    #[serde(rename = "method")]
    pub method: Option<Box<ProgressRollMethod>>,

    /// The options available when rolling with this trigger.
    #[serde(rename = "roll_options")]
    pub rollOptions: Option<Box<Vec<ProgressRollOption>>>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerProgressRollEnhancement {
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerProgressRollConditionEnhancement>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrack {
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerSpecialTrackCondition>,

    /// A markdown string of the primary trigger text for this move.
    /// 
    /// Secondary trigger text (for specific stats or uses of an asset ability)
    /// may be available for individual trigger conditions.
    #[serde(rename = "text")]
    pub text: MarkdownString,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackCondition {
    #[serde(rename = "method")]
    pub method: SpecialTrackRollMethod,

    /// The options available when rolling with this trigger.
    #[serde(rename = "roll_options")]
    pub rollOptions: Vec<TriggerSpecialTrackConditionOption>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

/// A progress move that rolls on one or more special tracks, like Bonds
/// (classic Ironsworn), Failure (Delve), or Legacy (Starforged).
#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackConditionEnhancement {
    #[serde(rename = "method")]
    pub method: Option<Box<SpecialTrackRollMethod>>,

    /// The options available when rolling with this trigger.
    #[serde(rename = "roll_options")]
    pub rollOptions: Option<Box<Vec<TriggerSpecialTrackConditionOption>>>,

    #[serde(rename = "by")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub by: Option<Box<TriggerBy>>,

    /// A markdown string of any trigger text specific to this trigger
    /// condition.
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text: Option<Box<MarkdownString>>,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackConditionOption {
    #[serde(rename = "using")]
    pub using: SpecialTrackType,
}

#[derive(Serialize, Deserialize)]
pub struct TriggerSpecialTrackEnhancement {
    #[serde(rename = "conditions")]
    pub conditions: Vec<TriggerSpecialTrackConditionEnhancement>,
}

/// A setting truth category.
#[derive(Serialize, Deserialize)]
pub struct Truth {
    #[serde(rename = "id")]
    pub id: TruthId,

    #[serde(rename = "name")]
    pub name: Label,

    #[serde(rename = "options")]
    pub options: Vec<TruthOption>,

    #[serde(rename = "source")]
    pub source: Source,

    #[serde(rename = "canonical_name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub canonicalName: Option<Box<Label>>,

    #[serde(rename = "icon")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub icon: Option<Box<SvgimageUrl>>,

    #[serde(rename = "suggestions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub suggestions: Option<Box<Suggestions>>,
}

pub type TruthId = String;

#[derive(Serialize, Deserialize)]
pub struct TruthOption {
    #[serde(rename = "description")]
    pub description: MarkdownString,

    #[serde(rename = "id")]
    pub id: TruthOptionId,

    #[serde(rename = "quest_starter")]
    pub questStarter: MarkdownString,

    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub summary: Option<Box<MarkdownString>>,
}

pub type TruthOptionId = String;

/// A relative URL pointing to a raster image in the WEBP format.
pub type WebpimageUrl = String;
